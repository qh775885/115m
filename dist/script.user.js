(o=>{if(typeof GM_addStyle=="function"){GM_addStyle(o);return}const t=document.createElement("style");t.textContent=o,document.head.append(t)})(" /*! PhotoSwipe main CSS by Dmytro Semenov | photoswipe.com */.pswp{--pswp-bg: #000;--pswp-placeholder-bg: #222;--pswp-root-z-index: 100000;--pswp-preloader-color: rgba(79, 79, 79, .4);--pswp-preloader-color-secondary: rgba(255, 255, 255, .9);--pswp-icon-color: #fff;--pswp-icon-color-secondary: #4f4f4f;--pswp-icon-stroke-color: #4f4f4f;--pswp-icon-stroke-width: 2px;--pswp-error-text-color: var(--pswp-icon-color)}.pswp{position:fixed;top:0;left:0;width:100%;height:100%;z-index:var(--pswp-root-z-index);display:none;touch-action:none;outline:0;opacity:.003;contain:layout style size;-webkit-tap-highlight-color:rgba(0,0,0,0)}.pswp:focus{outline:0}.pswp *{box-sizing:border-box}.pswp img{max-width:none}.pswp--open{display:block}.pswp,.pswp__bg{transform:translateZ(0);will-change:opacity}.pswp__bg{opacity:.005;background:var(--pswp-bg)}.pswp,.pswp__scroll-wrap{overflow:hidden}.pswp__scroll-wrap,.pswp__bg,.pswp__container,.pswp__item,.pswp__content,.pswp__img,.pswp__zoom-wrap{position:absolute;top:0;left:0;width:100%;height:100%}.pswp__img,.pswp__zoom-wrap{width:auto;height:auto}.pswp--click-to-zoom.pswp--zoom-allowed .pswp__img{cursor:-webkit-zoom-in;cursor:-moz-zoom-in;cursor:zoom-in}.pswp--click-to-zoom.pswp--zoomed-in .pswp__img{cursor:move;cursor:-webkit-grab;cursor:-moz-grab;cursor:grab}.pswp--click-to-zoom.pswp--zoomed-in .pswp__img:active{cursor:-webkit-grabbing;cursor:-moz-grabbing;cursor:grabbing}.pswp--no-mouse-drag.pswp--zoomed-in .pswp__img,.pswp--no-mouse-drag.pswp--zoomed-in .pswp__img:active,.pswp__img{cursor:-webkit-zoom-out;cursor:-moz-zoom-out;cursor:zoom-out}.pswp__container,.pswp__img,.pswp__button,.pswp__counter{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.pswp__item{z-index:1;overflow:hidden}.pswp__hidden{display:none!important}.pswp__content{pointer-events:none}.pswp__content>*{pointer-events:auto}.pswp__error-msg-container{display:grid}.pswp__error-msg{margin:auto;font-size:1em;line-height:1;color:var(--pswp-error-text-color)}.pswp .pswp__hide-on-close{opacity:.005;will-change:opacity;transition:opacity var(--pswp-transition-duration) cubic-bezier(.4,0,.22,1);z-index:10;pointer-events:none}.pswp--ui-visible .pswp__hide-on-close{opacity:1;pointer-events:auto}.pswp__button{position:relative;display:block;width:50px;height:60px;padding:0;margin:0;overflow:hidden;cursor:pointer;background:none;border:0;box-shadow:none;opacity:.85;-webkit-appearance:none;-webkit-touch-callout:none}.pswp__button:hover,.pswp__button:active,.pswp__button:focus{transition:none;padding:0;background:none;border:0;box-shadow:none;opacity:1}.pswp__button:disabled{opacity:.3;cursor:auto}.pswp__icn{fill:var(--pswp-icon-color);color:var(--pswp-icon-color-secondary)}.pswp__icn{position:absolute;top:14px;left:9px;width:32px;height:32px;overflow:hidden;pointer-events:none}.pswp__icn-shadow{stroke:var(--pswp-icon-stroke-color);stroke-width:var(--pswp-icon-stroke-width);fill:none}.pswp__icn:focus{outline:0}div.pswp__img--placeholder,.pswp__img--with-bg{background:var(--pswp-placeholder-bg)}.pswp__top-bar{position:absolute;left:0;top:0;width:100%;height:60px;display:flex;flex-direction:row;justify-content:flex-end;z-index:10;pointer-events:none!important}.pswp__top-bar>*{pointer-events:auto;will-change:opacity}.pswp__button--close{margin-right:6px}.pswp__button--arrow{position:absolute;width:75px;height:100px;top:50%;margin-top:-50px}.pswp__button--arrow:disabled{display:none;cursor:default}.pswp__button--arrow .pswp__icn{top:50%;margin-top:-30px;width:60px;height:60px;background:none;border-radius:0}.pswp--one-slide .pswp__button--arrow{display:none}.pswp--touch .pswp__button--arrow{visibility:hidden}.pswp--has_mouse .pswp__button--arrow{visibility:visible}.pswp__button--arrow--prev{right:auto;left:0}.pswp__button--arrow--next{right:0}.pswp__button--arrow--next .pswp__icn{left:auto;right:14px;transform:scaleX(-1)}.pswp__button--zoom{display:none}.pswp--zoom-allowed .pswp__button--zoom{display:block}.pswp--zoomed-in .pswp__zoom-icn-bar-v{display:none}.pswp__preloader{position:relative;overflow:hidden;width:50px;height:60px;margin-right:auto}.pswp__preloader .pswp__icn{opacity:0;transition:opacity .2s linear;animation:pswp-clockwise .6s linear infinite}.pswp__preloader--active .pswp__icn{opacity:.85}@keyframes pswp-clockwise{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.pswp__counter{height:30px;margin-top:15px;margin-inline-start:20px;font-size:14px;line-height:30px;color:var(--pswp-icon-color);text-shadow:1px 1px 3px var(--pswp-icon-color-secondary);opacity:.85}.pswp--one-slide .pswp__counter{display:none}.list-contents li.with-ext-info{height:auto!important;padding-bottom:12px;flex-wrap:wrap;align-content:flex-start}.list-contents li.with-ext-info .ext-info-root{width:100%;position:relative;display:flex}.list-contents li.with-actress-info{height:auto!important}.list-contents li.with-actress-info .file-type{top:50%;transform:translateY(-50%);transition:none}.list-contents li.with-actress-info .file-name-wrap{display:flex;align-items:center;flex-direction:row;justify-content:flex-start;height:auto!important;padding-top:12px;padding-bottom:12px}.list-contents li.with-actress-info .file-name-wrap .actress-info-img{width:50px;height:50px;border-radius:50%;object-fit:cover;margin-right:12px;border:3px solid #f1f1f1;box-shadow:0 0 5px #0000001a;background-color:#f1f1f1}.list-contents li.with-ext-video-cover{height:auto!important;flex-wrap:wrap;align-content:flex-start;padding-top:0;padding-bottom:12px}.list-contents li.with-ext-video-cover:first-child{padding-top:16px}.list-contents li.with-ext-video-cover .file-name-wrap{margin-bottom:0}.list-contents li.with-ext-video-cover .ext-video-cover-root{width:100%;height:100%;position:relative;display:flex;padding-left:83px}.master-back-button{display:inline-flex;align-items:center;text-align:center;padding:4px 13px;font-size:12px;border-radius:4px;margin:auto 9px auto -6px;background-color:#f2f4f8;color:#666;vertical-align:middle;flex-shrink:0}.master-back-button:hover{background-color:color-mix(in srgb,var(--official-theme) 10%,transparent 0%);color:var(--office-theme)}.master-back-button:active{background-color:color-mix(in srgb,var(--official-theme) 15%,transparent 0%)}.master-back-button iconify-icon{margin-right:4px;font-size:14px}:root{--official-theme: #2777f8}.x-popup[data-v-935c5311]>*{position:relative;z-index:1}@keyframes loading-bounce-c8313f62{0%,80%,to{transform:scale(0);opacity:.3}40%{transform:scale(1);opacity:1}}.loading-dot-bounce[data-v-c8313f62]{animation:loading-bounce-c8313f62 1.4s infinite ease-in-out both}.loading-dot-delay-1[data-v-c8313f62]{animation-delay:-.32s}.loading-dot-delay-2[data-v-c8313f62]{animation-delay:-.16s}.loading-dot-delay-3[data-v-c8313f62]{animation-delay:0s}@keyframes fadeOut{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(1.4)}} ");

System.addImportMap({ imports: {"vue":"user:vue","lodash":"user:lodash","blueimp-md5":"user:blueimp-md5","big-integer":"user:big-integer","photoswipe/lightbox":"user:photoswipe/lightbox","photoswipe":"user:photoswipe","localforage":"user:localforage","m3u8-parser":"user:m3u8-parser","dayjs":"user:dayjs","hls.js":"user:hls.js"} });
System.set("user:vue", (()=>{const _=Vue;('default' in _)||(_.default=_);return _})());
System.set("user:lodash", (()=>{const _1=_;('default' in _1)||(_1.default=_1);return _1})());
System.set("user:blueimp-md5", (()=>{const _=md5;('default' in _)||(_.default=_);return _})());
System.set("user:big-integer", (()=>{const _=bigInt;('default' in _)||(_.default=_);return _})());
System.set("user:photoswipe/lightbox", (()=>{const _=PhotoSwipeLightbox;('default' in _)||(_.default=_);return _})());
System.set("user:photoswipe", (()=>{const _=photoswipe;('default' in _)||(_.default=_);return _})());
System.set("user:localforage", (()=>{const _=localforage;('default' in _)||(_.default=_);return _})());
System.set("user:m3u8-parser", (()=>{const _=m3u8Parser;('default' in _)||(_.default=_);return _})());
System.set("user:dayjs", (()=>{const _=dayjs;('default' in _)||(_.default=_);return _})());
System.set("user:hls.js", (()=>{const _=Hls;('default' in _)||(_.default=_);return _})());

System.register("./__entry.js", ['./__monkey.entry-BzBceu9h.js'], (function (exports, module) {
	'use strict';
	return {
		setters: [null],
		execute: (function () {



		})
	};
}));

System.register("./__monkey.entry-BzBceu9h.js", ['lodash', 'localforage', 'blueimp-md5', 'big-integer', 'vue', 'photoswipe/lightbox', 'm3u8-parser'], (function (exports, module) {
  'use strict';
  var merge, defer, throttle, localforage, md5, bigInt, defineComponent, ref, shallowRef, onMounted, watch, onUnmounted, h, nextTick, createApp, defineAsyncComponent, computed, onBeforeUnmount, createElementBlock, openBlock, normalizeClass, createElementVNode, createCommentVNode, unref, createVNode, Fragment, renderList, withModifiers, toValue, renderSlot, createTextVNode, toDisplayString, reactive, getCurrentInstance, isRef, toRef$1, readonly, customRef, getCurrentScope, onScopeDispose, toRaw, PhotoSwipeLightbox, Parser;
  return {
    setters: [module => {
      merge = module.merge;
      defer = module.defer;
      throttle = module.throttle;
    }, module => {
      localforage = module.default;
    }, module => {
      md5 = module.default;
    }, module => {
      bigInt = module.default;
    }, module => {
      defineComponent = module.defineComponent;
      ref = module.ref;
      shallowRef = module.shallowRef;
      onMounted = module.onMounted;
      watch = module.watch;
      onUnmounted = module.onUnmounted;
      h = module.h;
      nextTick = module.nextTick;
      createApp = module.createApp;
      defineAsyncComponent = module.defineAsyncComponent;
      computed = module.computed;
      onBeforeUnmount = module.onBeforeUnmount;
      createElementBlock = module.createElementBlock;
      openBlock = module.openBlock;
      normalizeClass = module.normalizeClass;
      createElementVNode = module.createElementVNode;
      createCommentVNode = module.createCommentVNode;
      unref = module.unref;
      createVNode = module.createVNode;
      Fragment = module.Fragment;
      renderList = module.renderList;
      withModifiers = module.withModifiers;
      toValue = module.toValue;
      renderSlot = module.renderSlot;
      createTextVNode = module.createTextVNode;
      toDisplayString = module.toDisplayString;
      reactive = module.reactive;
      getCurrentInstance = module.getCurrentInstance;
      isRef = module.isRef;
      toRef$1 = module.toRef;
      readonly = module.readonly;
      customRef = module.customRef;
      getCurrentScope = module.getCurrentScope;
      onScopeDispose = module.onScopeDispose;
      toRaw = module.toRaw;
    }, module => {
      PhotoSwipeLightbox = module.default;
    }, module => {
      Parser = module.Parser;
    }],
    execute: (function () {

      exports({
        B: useVModel,
        C: useElementBounding,
        D: onClickOutside,
        E: getDefaultExportFromCjs,
        G: syncRef,
        H: toReactive,
        J: useIntervalFn,
        d: useAsyncState,
        e: useThrottleFn,
        f: useDebounceFn,
        g: useTitle,
        k: goToPlayer,
        m: blurTime,
        o: useVModels,
        p: useSmartVideoCover,
        r: getImageResize,
        s: setVideoCookie,
        t: tryOnUnmounted,
        u: useStorage,
        v: useEventListener,
        w: useElementSize,
        x: useCssVar,
        y: useMouseInElement
      });

      var __defProp = Object.defineProperty;
      var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      var globToRegexp;
      var hasRequiredGlobToRegexp;
      function requireGlobToRegexp() {
        if (hasRequiredGlobToRegexp) return globToRegexp;
        hasRequiredGlobToRegexp = 1;
        globToRegexp = function(glob, opts) {
          if (typeof glob !== "string") {
            throw new TypeError("Expected a string");
          }
          var str = String(glob);
          var reStr = "";
          var extended = opts ? !!opts.extended : false;
          var globstar = opts ? !!opts.globstar : false;
          var inGroup = false;
          var flags = opts && typeof opts.flags === "string" ? opts.flags : "";
          var c;
          for (var i = 0, len = str.length; i < len; i++) {
            c = str[i];
            switch (c) {
              case "/":
              case "$":
              case "^":
              case "+":
              case ".":
              case "(":
              case ")":
              case "=":
              case "!":
              case "|":
                reStr += "\\" + c;
                break;
              case "?":
                if (extended) {
                  reStr += ".";
                  break;
                }
              case "[":
              case "]":
                if (extended) {
                  reStr += c;
                  break;
                }
              case "{":
                if (extended) {
                  inGroup = true;
                  reStr += "(";
                  break;
                }
              case "}":
                if (extended) {
                  inGroup = false;
                  reStr += ")";
                  break;
                }
              case ",":
                if (inGroup) {
                  reStr += "|";
                  break;
                }
                reStr += "\\" + c;
                break;
              case "*":
                var prevChar = str[i - 1];
                var starCount = 1;
                while (str[i + 1] === "*") {
                  starCount++;
                  i++;
                }
                var nextChar = str[i + 1];
                if (!globstar) {
                  reStr += ".*";
                } else {
                  var isGlobstar = starCount > 1 && (prevChar === "/" || prevChar === void 0) && (nextChar === "/" || nextChar === void 0);
                  if (isGlobstar) {
                    reStr += "((?:[^/]*(?:/|$))*)";
                    i++;
                  } else {
                    reStr += "([^/]*)";
                  }
                }
                break;
              default:
                reStr += c;
            }
          }
          if (!flags || !~flags.indexOf("g")) {
            reStr = "^" + reStr + "$";
          }
          return new RegExp(reStr, flags);
        };
        return globToRegexp;
      }
      var globToRegexpExports = requireGlobToRegexp();
      const globToRegex = /* @__PURE__ */ getDefaultExportFromCjs(globToRegexpExports);
      const NORMAL_HOST_155 = "115.com";
      const WEB_API_HOST_155 = "webapi.115.com";
      const PRO_API_HOST_155 = "proapi.115.com";
      const VOD_HOST_155 = "115vod.com";
      const APS_HOST_155 = "aps.115.com";
      const DL_HOST_155 = "dl.115cdn.net";
      const NORMAL_URL_115 = `https://${NORMAL_HOST_155}`;
      const WEB_API_URL_115 = `https://${WEB_API_HOST_155}`;
      const PRO_API_URL_115 = `https://${PRO_API_HOST_155}`;
      const VOD_URL_115 = `https://${VOD_HOST_155}`;
      const APS_URL_115 = `https://${APS_HOST_155}`;
      const DL_URL_115 = `https://${DL_HOST_155}`;
      const ROUTE_MATCH = {
        HOME: `*://${NORMAL_HOST_155}/?*`,
        VIDEO: `*://${NORMAL_HOST_155}/web/lixian/master/video/*`,
        VIDEO_TOKEN: `*://${DL_HOST_155}/video/token`
      };
      class BaseMod {
      }
      class ModManager {
        constructor(mods) {
          Object.defineProperty(this, "mods", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
          });
          this.mods = mods;
        }
        register(mod) {
          this.mods.push(mod);
        }
        destroy() {
          this.mods.forEach((mod) => {
            mod.destroy();
          });
        }
      }
      var _GM_addStyle = /* @__PURE__ */ (() => typeof GM_addStyle != "undefined" ? GM_addStyle : void 0)();
      var _GM_cookie = /* @__PURE__ */ (() => typeof GM_cookie != "undefined" ? GM_cookie : void 0)();
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_info = /* @__PURE__ */ (() => typeof GM_info != "undefined" ? GM_info : void 0)();
      var _GM_openInTab = /* @__PURE__ */ (() => typeof GM_openInTab != "undefined" ? GM_openInTab : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      var _unsafeWindow = exports("L", /* @__PURE__ */ (() => typeof unsafeWindow != "undefined" ? unsafeWindow : void 0)());
      var FileType;
      (function(FileType2) {
        FileType2["folder"] = "0";
        FileType2["file"] = "1";
      })(FileType || (FileType = {}));
      var IvType;
      (function(IvType2) {
        IvType2["Yes"] = "1";
      })(IvType || (IvType = {}));
      var FileListType;
      (function(FileListType2) {
        FileListType2["list"] = "list";
        FileListType2["grid"] = "grid";
      })(FileListType || (FileListType = {}));
      const PLUS_VERSION = exports("P", void 0);
      const CDN_BASE_URL = exports("K", "https://fastly.jsdelivr.net");
      const FRIENDLY_ERROR_MESSAGE = exports("F", {
        // 未知错误
        UNKNOWN_ERROR: "未知错误",
        // 视频未转码，无法获取封面
        CANNOT_VIDEO_COVER_WITHOUT_TRANSCODING: "视频未转码，无法获取封面"
      });
      function blurTime(time, blur, max) {
        const _blurTime = time - time % blur + blur / 2;
        return Math.max(0, Math.min(_blurTime, max));
      }
      function getDuration(time) {
        if (!time) {
          return 0;
        }
        const [seconds = 0, minutes = 0, hours = 0] = time.split(":").map(Number).reverse();
        return hours * 3600 + minutes * 60 + seconds;
      }
      class FileItemModLoader {
        constructor(itemNode, fileListType, listScrollBoxNode, mods) {
          Object.defineProperty(this, "itemNode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: itemNode
          });
          Object.defineProperty(this, "fileListType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: fileListType
          });
          Object.defineProperty(this, "listScrollBoxNode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: listScrollBoxNode
          });
          Object.defineProperty(this, "mods", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mods
          });
          Object.defineProperty(this, "loadedMods", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
          });
        }
        /** 获取属性 */
        get attributes() {
          return Object.fromEntries(Array.from(this.itemNode.attributes).map((attr) => [
            attr.name,
            attr.value
          ]));
        }
        /** 获取视频时长节点 */
        get durationNode() {
          return this.itemNode.querySelector(".duration") ?? null;
        }
        /** 获取视频时长 */
        get duration() {
          var _a;
          return getDuration(((_a = this.durationNode) == null ? void 0 : _a.getAttribute("duration")) ?? "");
        }
        /** itemInfo */
        get itemInfo() {
          return {
            attributes: this.attributes,
            fileListType: this.fileListType,
            duration: this.duration,
            listScrollBoxNode: this.listScrollBoxNode
          };
        }
        /** 加载 */
        async load() {
          this.mods.forEach((Mod) => {
            const mod = new Mod(this.itemNode, this.itemInfo);
            if (mod.IS_PLUS && !PLUS_VERSION) {
              return;
            }
            mod.load();
            this.loadedMods.push(mod);
          });
        }
        /** 销毁 */
        destroy() {
          this.loadedMods.forEach((mod) => {
            mod.destroy();
          });
        }
      }
      const GM_VALUE_KEY = {
        PLAYING_VIDEO_INFO: "playingVideoInfo"
      };
      function goToPlayer(playingVideoInfo, isOpenInTab = false) {
        _GM_setValue(GM_VALUE_KEY.PLAYING_VIDEO_INFO, playingVideoInfo);
        const params = new URLSearchParams({
          cid: playingVideoInfo.cid || "",
          pick_code: playingVideoInfo.pickCode
        });
        const url = `https://${NORMAL_HOST_155}/web/lixian/master/video/?${params.toString()}`;
        if (isOpenInTab) {
          _GM_openInTab(url, {
            active: true
          });
          return;
        }
        history.pushState({}, "", url);
      }
      const DEFAULT_SETTINGS = {
        enableFilelistPreview: true
      };
      class UserSettings {
        constructor() {
          Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "watchTasks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
          });
          this.value = this.create();
        }
        /** 监听设置 */
        watch(key, callback) {
          const watchTask = {
            key,
            callback
          };
          this.watchTasks.push(watchTask);
          return () => {
            const index = this.watchTasks.indexOf(watchTask);
            if (index > -1) {
              this.watchTasks.splice(index, 1);
            }
          };
        }
        /** 创建用户设置 */
        create() {
          const namespace = "USER_SETTINGS";
          const value = _GM_getValue(namespace) ?? {};
          const userSettings2 = { ...DEFAULT_SETTINGS, ...value };
          const proxy = new Proxy(userSettings2, {
            get: (target, key) => {
              return target[key];
            },
            set: (target, key, newValue) => {
              const oldValue = target[key];
              target[key] = newValue;
              _GM_setValue(namespace, target);
              this.watchTasks.forEach((task) => {
                if (task.key === key) {
                  task.callback(oldValue, newValue);
                }
              });
              return true;
            }
          });
          return proxy;
        }
      }
      const userSettings = new UserSettings();
      class FileItemModBase {
        /**
         * 构造函数
         * @param itemNode item dom
         * @param itemInfo item 信息
         */
        constructor(itemNode, itemInfo) {
          Object.defineProperty(this, "itemNode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: itemNode
          });
          Object.defineProperty(this, "itemInfo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: itemInfo
          });
          Object.defineProperty(this, "IS_PLUS", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
          });
          Object.defineProperty(this, "ENABLE_KEY_IN_USER_SETTING", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
        }
        /** 加载 */
        load() {
          if (this.ENABLE_KEY_IN_USER_SETTING) {
            if (userSettings.value[this.ENABLE_KEY_IN_USER_SETTING]) {
              this.onLoad();
            }
            userSettings.watch(this.ENABLE_KEY_IN_USER_SETTING, (_, newValue) => {
              if (newValue) {
                this.onLoad();
              } else {
                this.destroy();
              }
            });
          } else {
            this.onLoad();
          }
        }
        /** 销毁 */
        destroy() {
          this.onDestroy();
        }
      }
      class FileItemModClickPlay extends FileItemModBase {
        /** 文件名节点 */
        get fileNameNode() {
          return this.itemNode.querySelector(".file-thumb") ?? this.itemNode.querySelector(".file-name .name");
        }
        /** 加载 */
        onLoad() {
          var _a;
          if (this.itemInfo.attributes.iv !== IvType.Yes) {
            return;
          }
          (_a = this.fileNameNode) == null ? void 0 : _a.addEventListener("click", this.handleClickPlayer.bind(this), true);
          this.itemNode.addEventListener("dblclick", this.handleClickPlayer.bind(this));
          this.itemNode.addEventListener("auxclick", this.handleAuxclick.bind(this));
        }
        /** 销毁 */
        onDestroy() {
          var _a;
          (_a = this.fileNameNode) == null ? void 0 : _a.removeEventListener("click", this.handleClickPlayer.bind(this), true);
          this.itemNode.removeEventListener("dblclick", this.handleClickPlayer.bind(this));
          this.itemNode.removeEventListener("auxclick", this.handleAuxclick.bind(this));
        }
        /** 中键文件115播放 */
        handleAuxclick(e) {
          if (e.button === 1) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            _GM_openInTab(new URL(`/?pickcode=${this.itemInfo.attributes.pick_code}&share_id=0`, VOD_URL_115).href, { active: true });
          }
        }
        /** 点击文件名 master 播放 */
        handleClickPlayer(e) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          goToPlayer({
            pickCode: this.itemInfo.attributes.pick_code,
            cid: this.itemInfo.attributes.cid
          }, true);
        }
      }
      const qualityNumMap = exports("q", {
        360: "360P",
        480: "480P",
        720: "720P",
        1080: "1080P",
        2160: "4K",
        9999: "原画"
      });
      const qualityCodeMap = {
        "3G": 360,
        "SD": 480,
        "HD": 720,
        "UD": 1080,
        "BD": 2160,
        "YH": 9999
      };
      const is115Browser = navigator.userAgent.match(/115Browser/i);
      class IRequest {
      }
      const DEFAULT_OPTIONS$1 = {
        /** 缓存策略 */
        cache: "no-cache",
        /** 凭证 */
        credentials: "include"
      };
      class FetchRequest extends IRequest {
        /**
         * 构造函数
         * @param options 请求选项
         */
        constructor(options = {}) {
          super();
          Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
          });
          this.options = {
            ...DEFAULT_OPTIONS$1,
            ...options
          };
        }
        /**
         * 发起请求
         */
        async request(url, _options = {}) {
          const options = { ...this.options, ..._options };
          const requestUrl = this.processUrl(url, options.params);
          try {
            const response = await fetch(requestUrl, options);
            return response;
          } catch (error) {
            throw new Error(`请求失败: ${error instanceof Error ? error.message : String(error)}`);
          }
        }
        /**
         * GET 请求
         * @param url 请求 URL
         * @param options 请求选项
         * @returns Promise<Response>
         */
        get(url, options) {
          return this.request(url, { ...options, method: "GET" });
        }
        /**
         * POST 请求
         * @param url 请求 URL
         * @param options 请求选项
         * @returns Promise<Response>
         */
        post(url, options) {
          var _a;
          let finalOptions = options ? { ...options } : {};
          if (finalOptions.data) {
            const contentType = ((_a = finalOptions.headers) == null ? void 0 : _a["Content-Type"]) || "application/x-www-form-urlencoded";
            let body;
            if (contentType.includes("application/json")) {
              body = JSON.stringify(finalOptions.data);
            } else if (contentType.includes("application/x-www-form-urlencoded")) {
              body = new URLSearchParams(finalOptions.data);
            } else if (contentType.includes("multipart/form-data")) {
              const formData = new FormData();
              Object.entries(finalOptions.data).forEach(([key, value]) => {
                formData.append(key, value);
              });
              body = formData;
              if (finalOptions.headers) {
                const newHeaders = {};
                Object.entries(finalOptions.headers).forEach(([key, value]) => {
                  if (key.toLowerCase() !== "content-type") {
                    newHeaders[key] = value;
                  }
                });
                finalOptions.headers = newHeaders;
              }
            } else {
              body = String(finalOptions.data);
            }
            const { data, ...restOptions } = finalOptions;
            finalOptions = {
              ...restOptions,
              body
            };
          }
          return this.request(url, merge({
            method: "POST",
            headers: {
              "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
            }
          }, finalOptions));
        }
        /**
         * 处理 URL 参数
         * @param url 请求 URL
         * @param params 查询参数
         * @returns 处理后的 URL
         */
        processUrl(url, params) {
          if (!params)
            return url;
          const urlObj = new URL(url);
          Object.entries(params).forEach(([key, value]) => {
            urlObj.searchParams.append(key, value.toString());
          });
          return urlObj.href;
        }
      }
      const fetchRequest = new FetchRequest();
      const STORE_NAME = `115master_cache${""}`;
      const STORAGE_QUOTA_THRESHOLD = 0.8;
      const CLEANUP_BATCH_SIZE = 10;
      const META_STORE_NAME = "meta";
      class MetaStore {
        /**
         * 构造函数
         * @param name 缓存名称
         * @param storeName 存储实例名称
         */
        constructor(name = STORE_NAME, storeName = "cache") {
          Object.defineProperty(this, "storage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "storeName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.name = name;
          this.storeName = storeName;
          this.storage = localforage.createInstance({
            name: this.name,
            storeName: META_STORE_NAME,
            version: 1,
            description: "缓存元数据",
            driver: localforage.INDEXEDDB
          });
        }
        /**
         * 更新缓存项的元数据
         * @param key 缓存键
         * @param size 缓存项大小（可选）
         * @param createdAt 创建时间（可选，如果不提供则使用现有值或当前时间）
         * @param updatedAt 更新时间（可选，如果不提供则使用当前时间）
         */
        async updateMeta(key, size, createdAt, updatedAt) {
          try {
            const fullKey = this.generateFullKey(key);
            const now = Date.now();
            const existingMeta = await this.getMeta(key);
            const meta = {
              key,
              fullKey,
              storeName: this.storeName,
              lastAccessed: now,
              // 如果提供了创建时间，使用提供的值；否则使用现有值或当前时间
              createdAt: createdAt ?? (existingMeta == null ? void 0 : existingMeta.createdAt) ?? now,
              // 如果提供了更新时间，使用提供的值；否则使用当前时间
              updatedAt: updatedAt ?? now
            };
            if (size !== void 0) {
              meta.size = size;
            } else if ((existingMeta == null ? void 0 : existingMeta.size) !== void 0) {
              meta.size = existingMeta.size;
            }
            await this.storage.setItem(fullKey, meta);
          } catch (error) {
            console.error("更新缓存元数据失败:", error);
          }
        }
        /**
         * 获取缓存项的元数据
         * @param key 缓存键
         */
        async getMeta(key) {
          const fullKey = this.generateFullKey(key);
          return await this.storage.getItem(fullKey);
        }
        /**
         * 删除缓存项的元数据
         * @param key 缓存键
         */
        async removeMeta(key) {
          const fullKey = this.generateFullKey(key);
          await this.storage.removeItem(fullKey);
        }
        /**
         * 获取所有缓存项的元数据
         * @returns 所有缓存项的元数据数组
         */
        async getAllMeta() {
          const items = [];
          await this.storage.iterate((value) => {
            if (value.storeName === this.storeName) {
              items.push(value);
            }
          });
          return items;
        }
        /**
         * 获取按最后访问时间排序的缓存项元数据
         * @param ascending 是否按升序排序（默认为true，即最旧的在前）
         * @returns 排序后的缓存项元数据数组
         */
        async getSortedByLastAccessed(ascending = true) {
          const items = await this.getAllMeta();
          return items.sort((a, b) => {
            return ascending ? a.lastAccessed - b.lastAccessed : b.lastAccessed - a.lastAccessed;
          });
        }
        /**
         * 清除所有元数据
         * 注意：只清除当前 name 和 storeName 的元数据
         */
        async clear() {
          const allItems = await this.getAllMeta();
          for (const item of allItems) {
            await this.storage.removeItem(item.fullKey);
          }
        }
        /**
         * 获取缓存项的创建时间
         * @param key 缓存键
         * @returns 创建时间戳，如果元数据不存在则返回 undefined
         */
        async getCreatedAt(key) {
          const meta = await this.getMeta(key);
          return meta == null ? void 0 : meta.createdAt;
        }
        /**
         * 获取缓存项的更新时间
         * @param key 缓存键
         * @returns 更新时间戳，如果元数据不存在则返回 undefined
         */
        async getUpdatedAt(key) {
          const meta = await this.getMeta(key);
          return meta == null ? void 0 : meta.updatedAt;
        }
        /**
         * 获取按创建时间排序的缓存项元数据
         * @param ascending 是否按升序排序（默认为true，即最早创建的在前）
         * @returns 排序后的缓存项元数据数组
         */
        async getSortedByCreatedAt(ascending = true) {
          const items = await this.getAllMeta();
          return items.sort((a, b) => {
            return ascending ? a.createdAt - b.createdAt : b.createdAt - a.createdAt;
          });
        }
        /**
         * 获取按更新时间排序的缓存项元数据
         * @param ascending 是否按升序排序（默认为true，即最早更新的在前）
         * @returns 排序后的缓存项元数据数组
         */
        async getSortedByUpdatedAt(ascending = true) {
          const items = await this.getAllMeta();
          return items.sort((a, b) => {
            return ascending ? a.updatedAt - b.updatedAt : b.updatedAt - a.updatedAt;
          });
        }
        /**
         * 生成完整的元数据键
         * @param key 原始缓存键
         * @returns 完整的元数据键
         */
        generateFullKey(key) {
          return `${this.storeName}:${key}`;
        }
      }
      class QuotaManager {
        /**
         * 构造函数
         * @param cacheInstance 缓存实例
         * @param name 缓存名称
         * @param storeName 存储实例名称
         */
        constructor(cacheInstance, name, storeName) {
          Object.defineProperty(this, "metaStore", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "cacheInstance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.cacheInstance = cacheInstance;
          this.metaStore = new MetaStore(name, storeName);
        }
        /**
         * 获取当前存储空间使用情况
         * @returns 存储空间使用情况
         */
        async getStorageUsage() {
          var _a;
          if ((_a = navigator.storage) == null ? void 0 : _a.estimate) {
            const estimate = await navigator.storage.estimate();
            const usage = estimate.usage || 0;
            const quota = estimate.quota || 0;
            const usageRatio = quota > 0 ? usage / quota : 0;
            return {
              usage,
              quota,
              usageRatio
            };
          }
          return {
            usage: 0,
            quota: 0,
            usageRatio: 0
          };
        }
        /**
         * 检查是否需要清理存储空间
         * @returns 是否需要清理
         */
        async shouldCleanup() {
          const { usageRatio } = await this.getStorageUsage();
          return usageRatio > STORAGE_QUOTA_THRESHOLD;
        }
        /**
         * 清理旧数据
         * @param batchSize 每批清理的数量，默认使用常量定义的值
         * @returns 已清理的键数组
         */
        async cleanup(batchSize = CLEANUP_BATCH_SIZE) {
          const needCleanup = await this.shouldCleanup();
          if (!needCleanup) {
            return [];
          }
          const oldestItems = await this.metaStore.getSortedByLastAccessed(true);
          if (oldestItems.length === 0) {
            return [];
          }
          const itemsToCleanup = oldestItems.slice(0, batchSize);
          const cleanedKeys = [];
          for (const item of itemsToCleanup) {
            try {
              await this.cacheInstance.remove(item.key);
              await this.metaStore.removeMeta(item.key);
              cleanedKeys.push(item.key);
            } catch (error) {
              console.error(`清理缓存项 ${item.key} 失败:`, error);
            }
          }
          console.warn(`已清理 ${cleanedKeys.length} 个旧缓存项`);
          return cleanedKeys;
        }
        /**
         * 记录缓存项访问
         * @param key 缓存键
         * @param size 缓存项大小（可选）
         * @param createdAt 创建时间（可选）
         * @param updatedAt 更新时间（可选）
         */
        async recordAccess(key, size, createdAt, updatedAt) {
          await this.metaStore.updateMeta(key, size, createdAt, updatedAt);
        }
        /**
         * 记录缓存项删除
         * @param key 缓存键
         */
        async recordRemoval(key) {
          await this.metaStore.removeMeta(key);
        }
        /**
         * 清空所有元数据
         */
        async clearAllMeta() {
          await this.metaStore.clear();
        }
        /**
         * 自动清理
         * 检查存储空间使用情况，如果超过阈值则进行清理
         * @returns 是否进行了清理
         */
        async autoCleanup() {
          const needCleanup = await this.shouldCleanup();
          if (needCleanup) {
            const cleanedKeys = await this.cleanup();
            return cleanedKeys.length > 0;
          }
          return false;
        }
      }
      class CacheCore {
        /**
         * 构造函数
         * @param options 存储配置
         */
        constructor(options = {}) {
          Object.defineProperty(this, "storage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "quotaManager", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "enableQuotaManagement", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "storeName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          const { enableQuotaManagement = true, ...storageOptions } = options;
          this.name = storageOptions.name || STORE_NAME;
          this.storeName = storageOptions.storeName || "cache";
          this.storage = localforage.createInstance({
            name: this.name,
            storeName: this.storeName,
            version: 1,
            description: "cache",
            driver: localforage.INDEXEDDB,
            ...storageOptions
          });
          this.enableQuotaManagement = enableQuotaManagement;
          this.quotaManager = new QuotaManager(this, this.name, this.storeName);
        }
        /**
         * 获取缓存项
         * @param key 缓存键
         * @returns 缓存值
         */
        async get(key) {
          const cache = await this.storage.getItem(key);
          if (cache && this.enableQuotaManagement) {
            await this.quotaManager.recordAccess(key, cache.size);
          }
          return cache;
        }
        /**
         * 设置缓存项
         * @param key 缓存键
         * @param value 缓存值
         * @returns Promise<void>
         */
        async set(key, value) {
          try {
            let size;
            if (this.enableQuotaManagement) {
              size = this.estimateSize(value, key);
            }
            const now = Date.now();
            const existingCache = await this.storage.getItem(key);
            const cacheValue = {
              value,
              ...size !== void 0 ? { size } : {},
              createdAt: (existingCache == null ? void 0 : existingCache.createdAt) || now,
              // 如果是新项目则设置创建时间，否则保留原创建时间
              updatedAt: now
              // 更新时间总是当前时间
            };
            await this.storage.setItem(key, cacheValue);
            if (this.enableQuotaManagement) {
              await this.quotaManager.recordAccess(key, size, cacheValue.createdAt, cacheValue.updatedAt);
              await this.quotaManager.autoCleanup();
            }
          } catch (error) {
            if (error instanceof DOMException && error.name === "QuotaExceededError") {
              console.error("缓存失败: 超出配额");
              if (this.enableQuotaManagement) {
                const cleaned = await this.quotaManager.cleanup();
                if (cleaned.length > 0) {
                  await this.set(key, value);
                }
              }
            } else {
              console.error("缓存失败:", error);
            }
          }
        }
        /**
         * 删除缓存项
         * @param key 缓存键
         */
        async remove(key) {
          await this.storage.removeItem(key);
          if (this.enableQuotaManagement) {
            await this.quotaManager.recordRemoval(key);
          }
        }
        /**
         * 清空缓存
         */
        async clear() {
          await this.storage.clear();
          if (this.enableQuotaManagement) {
            await this.quotaManager.clearAllMeta();
          }
        }
        /**
         * 获取空间限额管理器
         * @returns 空间限额管理器实例
         */
        getQuotaManager() {
          return this.quotaManager;
        }
        /**
         * 获取缓存项的创建时间
         * @param key 缓存键
         * @returns 创建时间戳，如果缓存项不存在则返回 undefined
         */
        async getCreatedAt(key) {
          const cache = await this.storage.getItem(key);
          return cache == null ? void 0 : cache.createdAt;
        }
        /**
         * 获取缓存项的更新时间
         * @param key 缓存键
         * @returns 更新时间戳，如果缓存项不存在则返回 undefined
         */
        async getUpdatedAt(key) {
          const cache = await this.storage.getItem(key);
          return cache == null ? void 0 : cache.updatedAt;
        }
        /**
         * 获取缓存项的年龄（从创建到现在的时间）
         * @param key 缓存键
         * @returns 缓存项年龄（毫秒），如果缓存项不存在则返回 undefined
         */
        async getAge(key) {
          const createdAt = await this.getCreatedAt(key);
          if (createdAt === void 0)
            return void 0;
          return Date.now() - createdAt;
        }
        /**
         * 获取缓存项的新鲜度（从上次更新到现在的时间）
         * @param key 缓存键
         * @returns 缓存项新鲜度（毫秒），如果缓存项不存在则返回 undefined
         */
        async getFreshness(key) {
          const updatedAt = await this.getUpdatedAt(key);
          if (updatedAt === void 0)
            return void 0;
          return Date.now() - updatedAt;
        }
        /**
         * 估算数据大小
         * @param value 需要估算大小的数据
         * @param key 缓存键（用于日志记录）
         * @returns 估算的数据大小（字节）或 undefined（如果无法估算）
         */
        estimateSize(value, key) {
          try {
            if (value instanceof Blob) {
              return value.size;
            }
            if (Array.isArray(value) && value.length > 0 && value[0] instanceof Blob) {
              return value.reduce((total, item) => {
                if (item instanceof Blob) {
                  return total + item.size;
                }
                return total;
              }, 0);
            }
            const valueStr = JSON.stringify(value);
            return new Blob([valueStr]).size;
          } catch (e) {
            console.warn(`无法估算缓存项 ${key} 的大小:`, e);
            return void 0;
          }
        }
      }
      class GMRequestCache {
        /**
         * 构造函数
         * @param storeName 存储名称，默认为 "gm-request-cache"
         * @param defaultCacheTime 默认缓存时间（毫秒），默认为 1 小时
         */
        constructor(storeName = "gm-request-cache", defaultCacheTime = 36e5) {
          Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "defaultCacheTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.cache = new CacheCore({
            name: STORE_NAME,
            storeName,
            enableQuotaManagement: true
          });
          this.defaultCacheTime = defaultCacheTime;
        }
        /**
         * 获取缓存的响应
         * @param url 请求 URL
         * @param options 请求选项
         * @returns 缓存的响应，如果没有缓存或缓存已过期则返回 null
         */
        async get(url, options = {}) {
          const key = this.generateCacheKey(url, options);
          const cacheItem = await this.cache.get(key);
          if (!cacheItem) {
            return null;
          }
          const { serializedResponse, timestamp } = cacheItem.value;
          const cacheTime = options.cacheTime || this.defaultCacheTime;
          if (Date.now() - timestamp > cacheTime) {
            await this.cache.remove(key);
            return null;
          }
          return this.deserializeResponse(serializedResponse);
        }
        /**
         * 缓存响应
         * @param url 请求 URL
         * @param response 响应对象
         * @param options 请求选项
         */
        async set(url, response, options = {}) {
          const cacheStatus = options.cacheStatus || [200];
          if (!cacheStatus.includes(response.status)) {
            return;
          }
          try {
            const key = this.generateCacheKey(url, options);
            const { serialized } = await this.serializeResponse(response);
            await this.cache.set(key, {
              serializedResponse: serialized,
              timestamp: Date.now(),
              url
            });
          } catch (error) {
            console.error("缓存响应失败:", error);
          }
        }
        /**
         * 清除指定 URL 的缓存
         * @param url 请求 URL
         * @param options 请求选项
         */
        async remove(url, options = {}) {
          const key = this.generateCacheKey(url, options);
          await this.cache.remove(key);
        }
        /**
         * 清除所有缓存
         */
        async clear() {
          await this.cache.clear();
        }
        /**
         * 获取缓存管理器
         * @returns 缓存核心实例
         */
        getCacheCore() {
          return this.cache;
        }
        /**
         * 生成缓存键
         * @param url 请求 URL
         * @param options 请求选项
         * @returns 缓存键
         */
        generateCacheKey(url, options = {}) {
          const method = options.method || "GET";
          let key = `${method}:${url}`;
          if (options.params) {
            const paramsStr = JSON.stringify(options.params);
            key += `:params:${paramsStr}`;
          }
          if (options.body) {
            try {
              const bodyStr = typeof options.body === "string" ? options.body : JSON.stringify(options.body);
              key += `:body:${bodyStr}`;
            } catch {
              key += `:body:${typeof options.body}`;
            }
          }
          return key;
        }
        /**
         * 将 Response 对象转换为可序列化的格式
         * @param response Response 对象
         * @returns 序列化后的响应数据和原始响应的 Promise
         */
        async serializeResponse(response) {
          const clonedResponse = response.clone();
          const headers = {};
          clonedResponse.headers.forEach((value, key) => {
            headers[key] = value;
          });
          let body = null;
          if (clonedResponse.bodyUsed) {
            body = null;
          } else {
            try {
              const contentType = clonedResponse.headers.get("content-type") || "";
              if (contentType.includes("application/json")) {
                body = await clonedResponse.text();
              } else if (contentType.includes("text/") || contentType.includes("application/javascript") || contentType.includes("application/xml")) {
                body = await clonedResponse.text();
              } else {
                body = await clonedResponse.arrayBuffer();
              }
            } catch (error) {
              console.error("序列化响应体失败:", error);
              body = null;
            }
          }
          const serialized = {
            body,
            status: clonedResponse.status,
            statusText: clonedResponse.statusText,
            headers,
            url: clonedResponse.url,
            type: clonedResponse.type,
            redirected: clonedResponse.redirected,
            bodyUsed: clonedResponse.bodyUsed
          };
          return { serialized, original: response };
        }
        /**
         * 将序列化的响应数据转换回 Response 对象
         * @param serialized 序列化的响应数据
         * @returns Response 对象
         */
        deserializeResponse(serialized) {
          const headers = new Headers();
          Object.entries(serialized.headers).forEach(([key, value]) => {
            headers.append(key, value);
          });
          const body = serialized.body;
          return new Response(body, {
            status: serialized.status,
            statusText: serialized.statusText,
            headers
          });
        }
      }
      const isChrome = _GM_info.userAgentData.brands.some((brand) => brand.brand === "Google Chrome");
      const DEFAULT_OPTIONS = {
        cacheStatus: [200],
        cache: "no-cache"
      };
      class GMRequest extends IRequest {
        constructor(options = {}, cacheName = "gm-request-cache") {
          super();
          Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
          });
          Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.options = {
            ...DEFAULT_OPTIONS,
            ...options
          };
          this.cache = new GMRequestCache(cacheName);
        }
        async request(url, _options = {}) {
          const options = { ...this.options, ..._options };
          const urlRe = new URL(url);
          if (options.params) {
            Object.entries(options.params).forEach(([key, value]) => {
              urlRe.searchParams.set(key, value.toString());
            });
          }
          const redirect = isChrome ? options.redirect || "manual" : "follow";
          const requestUrl = urlRe.href;
          const useCache = options.cache !== "no-cache";
          if (useCache) {
            const cachedResponse = await this.cache.get(requestUrl, options);
            if (cachedResponse) {
              return cachedResponse;
            }
          }
          return new Promise((resolve, reject) => {
            _GM_xmlhttpRequest({
              method: options.method || "GET",
              url: requestUrl,
              headers: Object.fromEntries(Object.entries(options.headers || {})),
              data: options.body,
              timeout: options.timeout || 5e3,
              responseType: options.responseType,
              nocache: !useCache,
              redirect,
              onload: async (rawResponse) => {
                const headers = this.parseResponseHeaders(rawResponse.responseHeaders);
                const responseHeaders = new Headers();
                Object.entries(headers).forEach(([key, value]) => {
                  responseHeaders.append(key, value);
                });
                const response = new Response(rawResponse.response, {
                  status: rawResponse.status,
                  statusText: rawResponse.statusText,
                  headers: responseHeaders
                });
                if (useCache) {
                  await this.cache.set(requestUrl, response.clone(), options);
                }
                resolve(response);
              },
              onerror: (e) => {
                reject(new Error("请求失败", { cause: e.error }));
              },
              ontimeout: () => {
                reject(new Error("请求超时"));
              }
            });
          });
        }
        get(url, options) {
          return this.request(url, { ...options, method: "GET" });
        }
        post(url, options) {
          return this.request(url, merge({
            method: "POST",
            body: new URLSearchParams(options == null ? void 0 : options.data),
            headers: {
              "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
            }
          }, options));
        }
        /**
         * 清除指定 URL 的缓存
         * @param url 请求 URL
         * @param options 请求选项
         */
        async clearCache(url, options) {
          await this.cache.remove(url, options);
        }
        /**
         * 清除所有缓存
         */
        async clearAllCache() {
          await this.cache.clear();
        }
        /**
         * 获取缓存管理器
         * @returns 缓存管理器实例
         */
        getCache() {
          return this.cache;
        }
        parseResponseHeaders(headerStr) {
          const headers = {};
          if (!headerStr)
            return headers;
          const headerPairs = headerStr.split("\n");
          for (let i = 0; i < headerPairs.length; i++) {
            const headerPair = headerPairs[i].trim();
            if (headerPair) {
              const index = headerPair.indexOf(":");
              if (index > 0) {
                const key = headerPair.substring(0, index).trim();
                const val = headerPair.substring(index + 1).trim();
                headers[key.toLowerCase()] = val;
              }
            }
          }
          return headers;
        }
      }
      new GMRequest();
      function getXUrl(url) {
        if (!url.includes("cpats01")) {
          return url;
        }
        return url.replace(/&s=\d+/, `&s=${52428800}`);
      }
      class Rsa115 {
        constructor() {
          Object.defineProperty(this, "n", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "e", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.n = bigInt("8686980c0f5a24c4b9d43020cd2c22703ff3f450756529058b1cf88f09b8602136477198a6e2683149659bd122c33592fdb5ad47944ad1ea4d36c6b172aad6338c3bb6ac6227502d010993ac967d1aef00f0c8e038de2e4d3bc2ec368af2e9f10a6f1eda4f7262f136420c07c331b871bf139f74f3010e3c4fe57df3afb71683", 16);
          this.e = bigInt("10001", 16);
        }
        a2hex(byteArray) {
          let hexString = "";
          let nextHexByte;
          for (let i = 0; i < byteArray.length; i++) {
            nextHexByte = byteArray[i].toString(16);
            if (nextHexByte.length < 2) {
              nextHexByte = `0${nextHexByte}`;
            }
            hexString += nextHexByte;
          }
          return hexString;
        }
        hex2a(hex) {
          let str = "";
          for (let i = 0; i < hex.length; i += 2) {
            str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
          }
          return str;
        }
        pkcs1pad2(s, n) {
          if (n < s.length + 11) {
            return null;
          }
          const ba = [];
          let pos = n;
          let i = s.length - 1;
          while (i >= 0 && pos > 0) {
            ba[--pos] = s.charCodeAt(i--);
          }
          ba[--pos] = 0;
          while (pos > 2) {
            ba[--pos] = 255;
          }
          ba[--pos] = 2;
          ba[--pos] = 0;
          const c = this.a2hex(ba);
          return bigInt(c, 16);
        }
        pkcs1unpad2(a) {
          let b = a.toString(16);
          if (b.length % 2 !== 0) {
            b = `0${b}`;
          }
          const c = this.hex2a(b);
          let i = 1;
          while (c.charCodeAt(i) !== 0) {
            i++;
          }
          return c.slice(i + 1);
        }
        encrypt(text) {
          const m = this.pkcs1pad2(text, 128);
          if (!m) {
            throw new Error("pkcs1pad2 failed");
          }
          const c = m.modPow(this.e, this.n);
          let h2 = c.toString(16);
          while (h2.length < 256) {
            h2 = `0${h2}`;
          }
          return h2;
        }
        decrypt(text) {
          const ba = [];
          let i = 0;
          while (i < text.length) {
            ba[i] = text.charCodeAt(i);
            i += 1;
          }
          const a = bigInt(this.a2hex(ba), 16);
          const c = a.modPow(this.e, this.n);
          const d = this.pkcs1unpad2(c);
          return d;
        }
      }
      class Crypto115 {
        constructor() {
          Object.defineProperty(this, "rsa", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "kts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "keyS", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "keyL", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.rsa = new Rsa115();
          this.kts = [
            240,
            229,
            105,
            174,
            191,
            220,
            191,
            138,
            26,
            69,
            232,
            190,
            125,
            166,
            115,
            184,
            222,
            143,
            231,
            196,
            69,
            218,
            134,
            196,
            155,
            100,
            139,
            20,
            106,
            180,
            241,
            170,
            56,
            1,
            53,
            158,
            38,
            105,
            44,
            134,
            0,
            107,
            79,
            165,
            54,
            52,
            98,
            166,
            42,
            150,
            104,
            24,
            242,
            74,
            253,
            189,
            107,
            151,
            143,
            77,
            143,
            137,
            19,
            183,
            108,
            142,
            147,
            237,
            14,
            13,
            72,
            62,
            215,
            47,
            136,
            216,
            254,
            254,
            126,
            134,
            80,
            149,
            79,
            209,
            235,
            131,
            38,
            52,
            219,
            102,
            123,
            156,
            126,
            157,
            122,
            129,
            50,
            234,
            182,
            51,
            222,
            58,
            169,
            89,
            52,
            102,
            59,
            170,
            186,
            129,
            96,
            72,
            185,
            213,
            129,
            156,
            248,
            108,
            132,
            119,
            255,
            84,
            120,
            38,
            95,
            190,
            232,
            30,
            54,
            159,
            52,
            128,
            92,
            69,
            44,
            155,
            118,
            213,
            27,
            143,
            204,
            195,
            184,
            245
          ];
          this.keyS = [41, 35, 33, 94];
          this.keyL = [120, 6, 173, 76, 51, 134, 93, 24, 76, 1, 63, 70];
        }
        xor115Enc(src, srclen, key, keylen) {
          const mod4 = srclen % 4;
          const ret = [];
          for (let i = 0; i < mod4; i++) {
            ret.push(src[i] ^ key[i % keylen]);
          }
          for (let i = mod4; i < srclen; i++) {
            ret.push(src[i] ^ key[(i - mod4) % keylen]);
          }
          return ret;
        }
        getkey(length, key) {
          if (key) {
            const results = [];
            for (let i = 0; i < length; i++) {
              const v1 = key[i] + this.kts[length * i] & 255;
              const v2 = this.kts[length * (length - 1 - i)];
              results.push(v1 ^ v2);
            }
            return results;
          }
          return length === 12 ? this.keyL.slice(0) : this.keyS.slice(0);
        }
        asymEncode(src, srclen) {
          const m = 117;
          let ret = "";
          for (let i = 0; i < Math.floor((srclen + m - 1) / m); i++) {
            ret += this.rsa.encrypt(this.bytesToString(src.slice(i * m, Math.min((i + 1) * m, srclen))));
          }
          return btoa(this.rsa.hex2a(ret));
        }
        asymDecode(src, srclen) {
          const m = 128;
          let ret = "";
          for (let i = 0; i < Math.floor((srclen + m - 1) / m); i++) {
            ret += this.rsa.decrypt(this.bytesToString(src.slice(i * m, Math.min((i + 1) * m, srclen))));
          }
          return this.stringToBytes(ret);
        }
        symEncode(src, srclen, key1, key2) {
          const k1 = this.getkey(4, key1);
          const k2 = this.getkey(12, key2);
          let ret = this.xor115Enc(src, srclen, k1, 4);
          ret.reverse();
          ret = this.xor115Enc(ret, srclen, k2, 12);
          return ret;
        }
        symDecode(src, srclen, key1, key2) {
          const k1 = this.getkey(4, key1);
          const k2 = this.getkey(12, key2);
          let ret = this.xor115Enc(src, srclen, k2, 12);
          ret.reverse();
          ret = this.xor115Enc(ret, srclen, k1, 4);
          return ret;
        }
        bytesToString(buf) {
          return buf.map((b) => String.fromCharCode(b)).join("");
        }
        stringToBytes(str) {
          return Array.from(str).map((c) => c.charCodeAt(0));
        }
        m115_encode(str, timestamp) {
          const key = this.stringToBytes(md5(`!@###@#${timestamp}DFDR@#@#`));
          let temp = this.stringToBytes(str);
          temp = this.symEncode(temp, temp.length, key);
          temp = key.slice(0, 16).concat(temp);
          return {
            data: this.asymEncode(temp, temp.length),
            key
          };
        }
        m115_decode(str, key) {
          let temp = this.stringToBytes(atob(str));
          temp = this.asymDecode(temp, temp.length);
          return this.bytesToString(this.symDecode(temp.slice(16), temp.length - 16, key, temp.slice(0, 16)));
        }
      }
      class Drive115Error {
      }
      Object.defineProperty(Drive115Error, "NotFoundM3u8File", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: class extends Error {
          constructor() {
            super("Not found m3u8 file");
          }
        }
      });
      class Drive115Core {
        constructor() {
          Object.defineProperty(this, "crypto115", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Crypto115()
          });
          Object.defineProperty(this, "BASE_URL", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: NORMAL_URL_115
          });
          Object.defineProperty(this, "WEB_API_URL", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: WEB_API_URL_115
          });
          Object.defineProperty(this, "PRO_API_URL", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: PRO_API_URL_115
          });
          Object.defineProperty(this, "VOD_URL_115", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: VOD_URL_115
          });
          Object.defineProperty(this, "APS_URL_115", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: APS_URL_115
          });
          Object.defineProperty(this, "verifying", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
          });
        }
        /** 获取原文件地址 (普通下载，有限制下载大小) */
        async webApiFilesDownload(pickcode) {
          const response = await fetchRequest.get(new URL(`/files/download?pickcode=${pickcode}`, this.WEB_API_URL).href);
          const res = await response.json();
          if (res.errNo === 990001) {
            alert("登录已过期，请重新登录");
          }
          if (!res.state || !res.file_url) {
            throw new Error(`服务器返回数据格式错误: ${JSON.stringify(res)}`);
          }
          return {
            url: {
              url: res.file_url
            }
          };
        }
        /** 获取原文件地址 (Pro 下载，无限制下载大小) */
        async ProPostAppChromeDownurl(pickcode) {
          const tm = Math.floor(Date.now() / 1e3).toString();
          const src = JSON.stringify({ pickcode });
          const encoded = this.crypto115.m115_encode(src, tm);
          const data = `data=${encodeURIComponent(encoded.data)}`;
          const request = is115Browser ? new GMRequest() : fetchRequest;
          const response = await request.post(new URL(`/app/chrome/downurl?t=${tm}`, this.PRO_API_URL).href, {
            body: data
          });
          const res = await response.json();
          if (!res.state) {
            throw new Error(`获取下载地址失败: ${JSON.stringify(res)}`);
          }
          const result2 = JSON.parse(this.crypto115.m115_decode(res.data, encoded.key));
          const downloadInfo = Object.values(result2)[0];
          return downloadInfo;
        }
        /** 获取 m3u8 根 url */
        getM3u8Url(pickcode) {
          return new URL(`/api/video/m3u8/${pickcode}.m3u8`, this.BASE_URL).href;
        }
        /** 解析 m3u8 列表 */
        async getM3u8Info(url, pickcode) {
          const response = await fetchRequest.get(url, {
            headers: {
              "Content-Type": "application/json"
            }
          });
          const htmlText = await response.text();
          if (!htmlText.startsWith("#")) {
            let res;
            try {
              res = JSON.parse(htmlText);
            } catch {
              throw new Drive115Error.NotFoundM3u8File();
            }
            if (res && res.state === false) {
              if (res.code === 911) {
                this.jumpVerify(pickcode);
              }
              throw new Error(`获取m3u8文件失败: ${res.error}`);
            }
          }
          const lines = htmlText.split("\n");
          const m3u8List = [];
          htmlText.split("\n").forEach((line, index) => {
            var _a, _b;
            if (line.includes('NAME="')) {
              const extXStreamInf = line.match(/#EXT-X-STREAM-INF/);
              if (extXStreamInf) {
                const name = ((_a = line.match(/NAME="([^"]*)"/)) == null ? void 0 : _a[1]) ?? "";
                const url2 = (_b = lines[index + 1]) == null ? void 0 : _b.trim();
                m3u8List.push({
                  name,
                  quality: qualityCodeMap[name],
                  url: getXUrl(url2)
                });
              }
            }
          });
          m3u8List.sort((a, b) => b.quality - a.quality);
          return m3u8List;
        }
        /** 获取文件列表 (以前老旧的文件夹需要使用它来获取) */
        async ApsGetNatsortFiles(params) {
          const response = await fetchRequest.get(new URL("/natsort/files.php", this.APS_URL_115).href, {
            params
          });
          return await response.json();
        }
        /** 获取文件列表 */
        async webApiGetFiles(params) {
          const response = await fetchRequest.get(new URL("/files", this.WEB_API_URL).href, {
            params
          });
          return await response.json();
        }
        /** 获取视频文件信息 */
        async webApiGetFilesVideo(params) {
          const response = await fetchRequest.get(new URL("/files/video", this.WEB_API_URL).href, {
            params
          });
          return await response.json();
        }
        /** 获取播放历史 */
        async webApiGetWebApiFilesHistory(params) {
          const response = await fetchRequest.get(new URL("/files/history", this.WEB_API_URL).href, {
            params
          });
          return await response.json();
        }
        /** 更新播放历史 */
        async webApiPostWebApiFilesHistory(data) {
          const response = await fetchRequest.post(new URL("/files/history", this.WEB_API_URL).href, {
            data
          });
          return await response.json();
        }
        /** 文件收藏 */
        async webApiPostFilesStar(params) {
          const response = await fetchRequest.post(new URL("/files/star", this.WEB_API_URL).href, {
            data: params
          });
          return await response.json();
        }
        /** 获取电影字幕 */
        async webApiGetMoviesSubtitle(params) {
          const response = await fetchRequest.get(new URL("/movies/subtitle", this.WEB_API_URL).href, {
            params
          });
          return await response.json();
        }
        /** 跳转验证 */
        jumpVerify(pickcode) {
          if (this.verifying) {
            return;
          }
          this.verifying = true;
          alert("你已经高频操作了!\n先去通过一下人机验证再回来刷新页面哦~");
          _GM_openInTab(new URL(`?pickcode=${pickcode}`, this.VOD_URL_115).href, {
            active: true
          });
        }
      }
      class Drive115Wrap extends Drive115Core {
        /** 获取文件列表 */
        async getFiles(params) {
          try {
            const response = await this.webApiGetFiles(params);
            if (response.state) {
              return response;
            }
            throw new Error("webapiFiles 获取播放列表失败");
          } catch {
            const response = await this.ApsGetNatsortFiles(params);
            if (response.state) {
              return response;
            }
            throw new Error(`获取播放列表失败: ${JSON.stringify(response)}`);
          }
        }
        /** 获取播放列表 */
        async getPlaylist(cid, offset = 0) {
          const params = {
            aid: 1,
            cid,
            offset,
            limit: 1150,
            show_dir: 0,
            nf: "",
            qid: 0,
            type: 4,
            source: "",
            format: "json",
            star: "",
            is_q: "",
            is_share: "",
            r_all: 1,
            o: "file_name",
            asc: 1,
            cur: 1,
            natsort: 1
          };
          return this.getFiles(params);
        }
        /** 获取 m3u8 列表 */
        async getM3u8(pickcode) {
          const url = this.getM3u8Url(pickcode);
          const m3u8List = await this.getM3u8Info(url, pickcode);
          return m3u8List;
        }
        /** 获取下载地址 */
        async getFileDownloadUrl(pickcode) {
          try {
            return await this.ProPostAppChromeDownurl(pickcode);
          } catch (error) {
            console.warn("第一种获取下载链接失败", error);
            const res = await this.webApiFilesDownload(pickcode);
            return res;
          }
        }
      }
      const drive115 = exports("l", new Drive115Wrap());
      class FileItemModDownload extends FileItemModBase {
        get fileOprNode() {
          return this.itemNode.querySelector(".file-opr");
        }
        get downloadOneNode() {
          var _a;
          return (_a = this.fileOprNode) == null ? void 0 : _a.querySelector('a[menu="download_one"]');
        }
        get downloadDirOneNode() {
          var _a;
          return (_a = this.fileOprNode) == null ? void 0 : _a.querySelector('a[menu="download_dir_one"]');
        }
        onLoad() {
          if (!this.fileOprNode) {
            return;
          }
          if (is115Browser) {
            return;
          }
          if (this.downloadDirOneNode) {
            this.downloadDirOneNode.onclick = async (e) => {
              e.stopImmediatePropagation();
              e.preventDefault();
              alert("当前未支持文件夹下载");
            };
          }
          if (this.downloadOneNode) {
            this.downloadOneNode.onclick = async (e) => {
              e.stopImmediatePropagation();
              e.preventDefault();
              try {
                const res = await drive115.getFileDownloadUrl(this.itemInfo.attributes.pick_code);
                if (res.url.url) {
                  window.open(res.url.url, "_blank");
                  return;
                }
                throw new Error("下载失败");
              } catch (error) {
                if (error instanceof Error) {
                  alert(error.message);
                } else {
                  alert("下载失败");
                }
              }
            };
          }
        }
        onDestroy() {
        }
      }
      class FileItemModExtMenu extends FileItemModBase {
        /** 按钮配置 */
        get buttonConfig() {
          return [
            {
              class: "115-player",
              title: "使用【115官方播放器】",
              text: "5️⃣ 官方播放",
              visible: this.itemInfo.attributes.iv === IvType.Yes,
              click: () => {
                _GM_openInTab(new URL(`/?pickcode=${this.itemInfo.attributes.pick_code}&share_id=0`, VOD_URL_115).href, { active: true });
              }
            },
            {
              class: "master-player",
              title: "使用【Master播放器】",
              text: "▶️ Master 播放",
              visible: this.itemInfo.attributes.iv === IvType.Yes,
              click: () => {
                goToPlayer({
                  pickCode: this.itemInfo.attributes.pick_code,
                  cid: this.itemInfo.attributes.cid
                }, true);
              }
            }
          ];
        }
        /** 文件操作节点 */
        get fileOprNode() {
          return this.itemNode.querySelector(".file-opr") ?? this.itemNode.querySelector(".file-opt");
        }
        /** 加载 */
        onLoad() {
          if (this.itemInfo.fileListType === FileListType.grid) {
            return;
          }
          this.createButtons();
        }
        /** 销毁 */
        onDestroy() {
        }
        /** 创建文件操作菜单按钮 */
        createButtons() {
          this.buttonConfig.forEach((button) => {
            var _a;
            if (!button.visible)
              return;
            const link = this.createNormalItemButtonElement(button);
            (_a = this.fileOprNode) == null ? void 0 : _a.prepend(link);
            link.addEventListener("mousedown", async (e) => {
              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation();
              button.click();
            });
          });
        }
        /** 创建普通文件项按钮元素 */
        createNormalItemButtonElement(button) {
          const link = document.createElement("a");
          link.href = "javascript:void(0)";
          link.className = button.class;
          link.title = button.title;
          link.style.cssText = `
      pointer-events: all;
      position: relative;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 4px;
    `;
          if (button.icon) {
            const icon = document.createElement("img");
            icon.src = button.icon;
            icon.style.cssText = "width: 16px; height: 16px;";
            link.prepend(icon);
          }
          const textSpan = document.createElement("span");
          textSpan.textContent = button.text;
          textSpan.style.pointerEvents = "none";
          link.appendChild(textSpan);
          return link;
        }
      }
      const mainStyles = `/*! tailwindcss v4.1.12 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-border-style:solid;--tw-gradient-position:initial;--tw-gradient-from:#0000;--tw-gradient-via:#0000;--tw-gradient-to:#0000;--tw-gradient-stops:initial;--tw-gradient-via-stops:initial;--tw-gradient-from-position:0%;--tw-gradient-via-position:50%;--tw-gradient-to-position:100%;--tw-leading:initial;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-ease:initial;--tw-text-shadow-color:initial;--tw-text-shadow-alpha:100%;--tw-content:""}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-400:oklch(70.4% .191 22.216);--color-yellow-300:oklch(90.5% .182 98.111);--color-yellow-400:oklch(85.2% .199 91.936);--color-gray-100:oklch(96.7% .003 264.542);--color-neutral-300:oklch(87% 0 0);--color-neutral-800:oklch(26.9% 0 0);--color-neutral-950:oklch(14.5% 0 0);--color-black:#000;--color-white:#fff;--spacing:.25rem;--container-lg:32rem;--container-xl:36rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height: 1.5 ;--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-xl:1.25rem;--text-xl--line-height:calc(1.75/1.25);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--text-3xl:1.875rem;--text-3xl--line-height: 1.2 ;--text-4xl:2.25rem;--text-4xl--line-height:calc(2.5/2.25);--text-5xl:3rem;--text-5xl--line-height:1;--text-6xl:3.75rem;--text-6xl--line-height:1;--text-8xl:6rem;--text-8xl--line-height:1;--font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--leading-relaxed:1.625;--radius-lg:.5rem;--radius-xl:.75rem;--radius-2xl:1rem;--drop-shadow-xs:0 1px 1px #0000000d;--drop-shadow-xl:0 9px 7px #0000001a;--ease-out:cubic-bezier(0,0,.2,1);--ease-in-out:cubic-bezier(.4,0,.2,1);--animate-spin:spin 1s linear infinite;--blur-xs:4px;--blur-2xl:40px;--aspect-video:16/9;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){-webkit-appearance:button;-moz-appearance:button;appearance:button}::file-selector-button{-webkit-appearance:button;-moz-appearance:button;appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E")}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}:root:has(input.theme-controller[value=dark]:checked),[data-theme=dark]{color-scheme:dark;--color-base-100:oklch(14% 0 0);--color-base-200:oklch(20% 0 0);--color-base-300:oklch(43% 0 0);--color-base-content:oklch(100% 0 0);--color-primary:oklch(62% .214 259.815);--color-primary-content:oklch(98% 0 0);--color-secondary:oklch(64.092% .027 229.389);--color-secondary-content:oklch(12.818% .005 229.389);--color-accent:oklch(67.271% .167 35.791);--color-accent-content:oklch(13.454% .033 35.791);--color-neutral:oklch(27.441% .013 253.041);--color-neutral-content:oklch(85.488% .002 253.041);--color-info:oklch(62.616% .143 240.033);--color-info-content:oklch(12.523% .028 240.033);--color-success:oklch(70.226% .094 156.596);--color-success-content:oklch(14.045% .018 156.596);--color-warning:oklch(77.482% .115 81.519);--color-warning-content:oklch(15.496% .023 81.519);--color-error:oklch(51.61% .146 29.674);--color-error-content:oklch(90.322% .029 29.674);--radius-selector:2rem;--radius-field:2rem;--radius-box:1rem;--size-selector:.25rem;--size-field:.25rem;--border:1px;--depth:0;--noise:0}:root:has(input.theme-controller[value=light]:checked),[data-theme=light]{color-scheme:light;--color-base-100:oklch(100% 0 0);--color-base-200:oklch(98% 0 0);--color-base-300:oklch(95% 0 0);--color-base-content:oklch(21% .006 285.885);--color-primary:oklch(62% .214 259.815);--color-primary-content:oklch(98% 0 0);--color-secondary:oklch(65% .241 354.308);--color-secondary-content:oklch(94% .028 342.258);--color-accent:oklch(77% .152 181.912);--color-accent-content:oklch(38% .063 188.416);--color-neutral:oklch(14% .005 285.823);--color-neutral-content:oklch(92% .004 286.32);--color-info:oklch(74% .16 232.661);--color-info-content:oklch(29% .066 243.157);--color-success:oklch(76% .177 163.223);--color-success-content:oklch(37% .077 168.94);--color-warning:oklch(82% .189 84.429);--color-warning-content:oklch(41% .112 45.904);--color-error:oklch(71% .194 13.428);--color-error-content:oklch(27% .105 12.094);--radius-selector:2rem;--radius-field:2rem;--radius-box:1rem;--size-selector:.25rem;--size-field:.25rem;--border:1px;--depth:0;--noise:0}}@layer components;@layer utilities{.diff{webkit-user-select:none;-webkit-user-select:none;user-select:none;direction:ltr;grid-template-columns:auto 1fr;width:100%;display:grid;position:relative;overflow:hidden;container-type:inline-size}.diff:focus-visible,.diff:has(.diff-item-1:focus-visible){outline-style:var(--tw-outline-style);outline-offset:1px;outline-width:2px;outline-color:var(--color-base-content)}.diff:focus-visible .diff-resizer{min-width:90cqi;max-width:90cqi}.diff:has(.diff-item-2:focus-visible){outline-style:var(--tw-outline-style);outline-offset:1px;outline-width:2px}.diff:has(.diff-item-2:focus-visible) .diff-resizer{min-width:10cqi;max-width:10cqi}@supports (-webkit-overflow-scrolling:touch) and (overflow:-webkit-paged-x){.diff:focus .diff-resizer{min-width:10cqi;max-width:10cqi}.diff:has(.diff-item-1:focus) .diff-resizer{min-width:90cqi;max-width:90cqi}}.tooltip{--tt-bg:var(--color-neutral);--tt-off: calc(100% + .5rem) ;--tt-tail: calc(100% + 1px + .25rem) ;display:inline-block;position:relative}.tooltip>:where(.tooltip-content),.tooltip:where([data-tip]):before{border-radius:var(--radius-field);text-align:center;white-space:normal;max-width:20rem;color:var(--color-neutral-content);opacity:0;background-color:var(--tt-bg);pointer-events:none;z-index:2;--tw-content:attr(data-tip);content:var(--tw-content);width:max-content;padding-block:.25rem;padding-inline:.5rem;font-size:.875rem;line-height:1.25;position:absolute}@media (prefers-reduced-motion:no-preference){.tooltip>:where(.tooltip-content),.tooltip:where([data-tip]):before,.tooltip:after{transition:opacity .2s cubic-bezier(.4,0,.2,1) 75ms,transform .2s cubic-bezier(.4,0,.2,1) 75ms}}.tooltip:after{opacity:0;background-color:var(--tt-bg);content:"";pointer-events:none;--mask-tooltip:url("data:image/svg+xml,%3Csvg width='10' height='4' viewBox='0 0 8 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0.500009 1C3.5 1 3.00001 4 5.00001 4C7 4 6.5 1 9.5 1C10 1 10 0.499897 10 0H0C-1.99338e-08 0.5 0 1 0.500009 1Z' fill='black'/%3E%3C/svg%3E%0A");width:.625rem;height:.25rem;-webkit-mask-position:-1px 0;mask-position:-1px 0;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-image:var(--mask-tooltip);mask-image:var(--mask-tooltip);display:block;position:absolute}:is(.tooltip.tooltip-open,.tooltip[data-tip]:not([data-tip=""]):hover,.tooltip:not(:has(.tooltip-content:empty)):has(.tooltip-content):hover,.tooltip:has(:focus-visible))>.tooltip-content,:is(.tooltip.tooltip-open,.tooltip[data-tip]:not([data-tip=""]):hover,.tooltip:not(:has(.tooltip-content:empty)):has(.tooltip-content):hover,.tooltip:has(:focus-visible))[data-tip]:before,:is(.tooltip.tooltip-open,.tooltip[data-tip]:not([data-tip=""]):hover,.tooltip:not(:has(.tooltip-content:empty)):has(.tooltip-content):hover,.tooltip:has(:focus-visible)):after{opacity:1;--tt-pos:0rem}@media (prefers-reduced-motion:no-preference){:is(.tooltip.tooltip-open,.tooltip[data-tip]:not([data-tip=""]):hover,.tooltip:not(:has(.tooltip-content:empty)):has(.tooltip-content):hover,.tooltip:has(:focus-visible))>.tooltip-content,:is(.tooltip.tooltip-open,.tooltip[data-tip]:not([data-tip=""]):hover,.tooltip:not(:has(.tooltip-content:empty)):has(.tooltip-content):hover,.tooltip:has(:focus-visible))[data-tip]:before,:is(.tooltip.tooltip-open,.tooltip[data-tip]:not([data-tip=""]):hover,.tooltip:not(:has(.tooltip-content:empty)):has(.tooltip-content):hover,.tooltip:has(:focus-visible)):after{transition:opacity .2s cubic-bezier(.4,0,.2,1),transform .2s cubic-bezier(.4,0,.2,1)}}.tooltip>.tooltip-content,.tooltip[data-tip]:before{transform:translate(-50%)translateY(var(--tt-pos,.25rem));inset:auto auto var(--tt-off)50%}.tooltip:after{transform:translate(-50%)translateY(var(--tt-pos,.25rem));inset:auto auto var(--tt-tail)50%}.menu{--menu-active-fg:var(--color-neutral-content);--menu-active-bg:var(--color-neutral);flex-flow:column wrap;width:fit-content;padding:.5rem;font-size:.875rem;display:flex}.menu :where(li ul){white-space:nowrap;margin-inline-start:1rem;padding-inline-start:.5rem;position:relative}.menu :where(li ul):before{background-color:var(--color-base-content);opacity:.1;width:var(--border);content:"";inset-inline-start:0;position:absolute;top:.75rem;bottom:.75rem}.menu :where(li>.menu-dropdown:not(.menu-dropdown-show)){display:none}.menu :where(li:not(.menu-title)>:not(ul,details,.menu-title,.btn)),.menu :where(li:not(.menu-title)>details>summary:not(.menu-title)){border-radius:var(--radius-field);text-align:start;text-wrap:balance;-webkit-user-select:none;user-select:none;grid-auto-columns:minmax(auto,max-content) auto max-content;grid-auto-flow:column;align-content:flex-start;align-items:center;gap:.5rem;padding-block:.375rem;padding-inline:.75rem;transition-property:color,background-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:grid}.menu :where(li>details>summary){--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li>details>summary){outline-offset:2px;outline:2px solid #0000}}.menu :where(li>details>summary)::-webkit-details-marker{display:none}:is(.menu :where(li>details>summary),.menu :where(li>.menu-dropdown-toggle)):after{content:"";transform-origin:50%;pointer-events:none;justify-self:flex-end;width:.375rem;height:.375rem;transition-property:rotate,translate;transition-duration:.2s;display:block;translate:0 -1px;rotate:-135deg;box-shadow:inset 2px 2px}.menu :where(li>details[open]>summary):after,.menu :where(li>.menu-dropdown-toggle.menu-dropdown-show):after{translate:0 1px;rotate:45deg}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{cursor:pointer;background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{color:var(--color-base-content);--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{outline-offset:2px;outline:2px solid #0000}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){cursor:pointer;background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){outline-offset:2px;outline:2px solid #0000}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){box-shadow:inset 0 1px #00000003,inset 0 -1px #ffffff03}.menu :where(li:empty){background-color:var(--color-base-content);opacity:.1;height:1px;margin:.5rem 1rem}.menu :where(li){flex-flow:column wrap;flex-shrink:0;align-items:stretch;display:flex;position:relative}.menu :where(li) .badge{justify-self:flex-end}.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active{outline-offset:2px;outline:2px solid #0000}}.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active{color:var(--menu-active-fg);background-color:var(--menu-active-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise)}:is(.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active):not(:is(.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active):active){box-shadow:0 2px calc(var(--depth)*3px) -2px var(--menu-active-bg)}.menu :where(li).menu-disabled{pointer-events:none;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.menu :where(li).menu-disabled{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.menu .dropdown:focus-within .menu-dropdown-toggle:after{translate:0 1px;rotate:45deg}.menu .dropdown-content{margin-top:.5rem;padding:.5rem}.menu .dropdown-content:before{display:none}.dropdown{position-area:var(--anchor-v,bottom)var(--anchor-h,span-right);display:inline-block;position:relative}.dropdown>:not(summary):focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.dropdown>:not(summary):focus{outline-offset:2px;outline:2px solid #0000}}.dropdown .dropdown-content{position:absolute}.dropdown:not(details,.dropdown-open,.dropdown-hover:hover,:focus-within) .dropdown-content{transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover],.dropdown .dropdown-content{z-index:999}@media (prefers-reduced-motion:no-preference){.dropdown[popover],.dropdown .dropdown-content{transition-behavior:allow-discrete;transition-property:opacity,scale,display;transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,.2,1);animation:.2s dropdown}}@starting-style{.dropdown[popover],.dropdown .dropdown-content{opacity:0;scale:95%}}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within)>[tabindex]:first-child{pointer-events:none}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within) .dropdown-content{opacity:1}.dropdown.dropdown-hover:hover .dropdown-content{opacity:1;scale:100%}.dropdown:is(details) summary::-webkit-details-marker{display:none}:is(.dropdown.dropdown-open,.dropdown:focus,.dropdown:focus-within) .dropdown-content{scale:100%}.dropdown:where([popover]){background:0 0}.dropdown[popover]{color:inherit;position:fixed}@supports not (position-area:bottom){.dropdown[popover]{margin:auto}.dropdown[popover].dropdown-open:not(:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover]::backdrop{background-color:oklab(0% none none/.3)}}.dropdown[popover]:not(.dropdown-open,:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible,.btn:has(:focus-visible){isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.btn:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn:is(input[type=checkbox],input[type=radio]){-webkit-appearance:none;-moz-appearance:none;appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.loading{pointer-events:none;aspect-ratio:1;vertical-align:middle;width:calc(var(--size-selector,.25rem)*6);background-color:currentColor;display:inline-block;-webkit-mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E");-webkit-mask-position:50%;mask-position:50%;-webkit-mask-size:100%;mask-size:100%;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat}.pointer-events-auto{pointer-events:auto}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.list{flex-direction:column;font-size:.875rem;display:flex}.list :where(.list-row){--list-grid-cols:minmax(0,auto)1fr;border-radius:var(--radius-box);word-break:break-word;grid-auto-flow:column;grid-template-columns:var(--list-grid-cols);gap:1rem;padding:1rem;display:grid;position:relative}.list :where(.list-row):has(.list-col-grow:first-child){--list-grid-cols:1fr}.list :where(.list-row):has(.list-col-grow:nth-child(2)){--list-grid-cols:minmax(0,auto)1fr}.list :where(.list-row):has(.list-col-grow:nth-child(3)){--list-grid-cols:minmax(0,auto)minmax(0,auto)1fr}.list :where(.list-row):has(.list-col-grow:nth-child(4)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list :where(.list-row):has(.list-col-grow:nth-child(5)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list :where(.list-row):has(.list-col-grow:nth-child(6)){--list-grid-cols:minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)minmax(0,auto)1fr}.list :where(.list-row) :not(.list-col-wrap){grid-row-start:1}:is(.list>:not(:last-child).list-row,.list>:not(:last-child) .list-row):after{content:"";border-bottom:var(--border)solid;inset-inline:var(--radius-box);border-color:var(--color-base-content);position:absolute;bottom:0}@supports (color:color-mix(in lab,red,red)){:is(.list>:not(:last-child).list-row,.list>:not(:last-child) .list-row):after{border-color:color-mix(in oklab,var(--color-base-content)5%,transparent)}}.toast{translate:var(--toast-x,0)var(--toast-y,0);inset-inline:auto 1rem;background-color:#0000;flex-direction:column;gap:.5rem;width:max-content;max-width:calc(100vw - 2rem);display:flex;position:fixed;top:auto;bottom:1rem}@media (prefers-reduced-motion:no-preference){.toast>*{animation:.25s ease-out toast}}.toast:where(.toast-start){--toast-x:0;inset-inline:1rem auto}.toast:where(.toast-center){--toast-x:-50%;inset-inline:50%}.toast:where(.toast-end){--toast-x:0;inset-inline:auto 1rem}.toast:where(.toast-bottom){--toast-y:0;top:auto;bottom:1rem}.toast:where(.toast-middle){--toast-y:-50%;top:50%;bottom:auto}.toast:where(.toast-top){--toast-y:0;top:1rem;bottom:auto}.toggle{border:var(--border)solid currentColor;color:var(--input-color);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;vertical-align:middle;webkit-user-select:none;-webkit-user-select:none;user-select:none;--radius-selector-max:calc(var(--radius-selector) + var(--radius-selector) + var(--radius-selector));border-radius:calc(var(--radius-selector) + min(var(--toggle-p),var(--radius-selector-max)) + min(var(--border),var(--radius-selector-max)));padding:var(--toggle-p);flex-shrink:0;grid-template-columns:0fr 1fr 1fr;place-content:center;display:inline-grid;position:relative;box-shadow:inset 0 1px}@supports (color:color-mix(in lab,red,red)){.toggle{box-shadow:0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000) inset}}.toggle{--input-color:var(--color-base-content);transition:color .3s,grid-template-columns .2s}@supports (color:color-mix(in lab,red,red)){.toggle{--input-color:color-mix(in oklab,var(--color-base-content)50%,#0000)}}.toggle{--toggle-p:calc(var(--size)*.125);--size:calc(var(--size-selector,.25rem)*6);width:calc((var(--size)*2) - (var(--border) + var(--toggle-p))*2);height:var(--size)}.toggle>*{z-index:1;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#0000;border:none;grid-column:2/span 1;grid-row-start:1;height:100%;padding:.125rem;transition:opacity .2s,rotate .4s}.toggle>:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.toggle>:focus{outline-offset:2px;outline:2px solid #0000}}.toggle>:nth-child(2){color:var(--color-base-100);rotate:none}.toggle>:nth-child(3){color:var(--color-base-100);opacity:0;rotate:-15deg}.toggle:has(:checked)>:nth-child(2){opacity:0;rotate:15deg}.toggle:has(:checked)>:nth-child(3){opacity:1;rotate:none}.toggle:before{aspect-ratio:1;border-radius:var(--radius-selector);--tw-content:"";content:var(--tw-content);height:100%;box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px currentColor;background-color:currentColor;grid-row-start:1;grid-column-start:2;transition:background-color .1s,translate .2s,inset-inline-start .2s;position:relative;inset-inline-start:0;translate:0}@supports (color:color-mix(in lab,red,red)){.toggle:before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000)}}.toggle:before{background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise)}@media (forced-colors:active){.toggle:before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{.toggle:before{outline-offset:-1rem;outline:.25rem solid}}.toggle:focus-visible,.toggle:has(:focus-visible){outline-offset:2px;outline:2px solid}.toggle:checked,.toggle[aria-checked=true],.toggle:has(>input:checked){background-color:var(--color-base-100);--input-color:var(--color-base-content);grid-template-columns:1fr 1fr 0fr}:is(.toggle:checked,.toggle[aria-checked=true],.toggle:has(>input:checked)):before{background-color:currentColor}@starting-style{:is(.toggle:checked,.toggle[aria-checked=true],.toggle:has(>input:checked)):before{opacity:0}}.toggle:indeterminate{grid-template-columns:.5fr 1fr .5fr}.toggle:disabled{cursor:not-allowed;opacity:.3}.toggle:disabled:before{border:var(--border)solid currentColor;background-color:#0000}.input{cursor:text;border:var(--border)solid #0000;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-flex}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input)::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input)::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]),fieldset:disabled .input{box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.input:has(>input[type=date]) :where(input[type=date]){webkit-appearance:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;display:inline-flex}.input:has(>input[type=date]) input[type=date]::-webkit-calendar-picker-indicator{cursor:pointer;width:1em;height:1em;position:absolute;inset-inline-end:.75em}.table{border-radius:var(--radius-box);text-align:left;width:100%;font-size:.875rem;position:relative}.table:where(:dir(rtl),[dir=rtl],[dir=rtl] *){text-align:right}@media (hover:hover){:is(.table tr.row-hover,.table tr.row-hover:nth-child(2n)):hover{background-color:var(--color-base-200)}}.table :where(th,td){vertical-align:middle;padding-block:.75rem;padding-inline:1rem}.table :where(thead,tfoot){white-space:nowrap;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead,tfoot){color:color-mix(in oklab,var(--color-base-content)60%,transparent)}}.table :where(thead,tfoot){font-size:.875rem;font-weight:600}.table :where(tfoot){border-top:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(tfoot){border-top:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.table :where(.table-pin-rows thead tr){z-index:1;background-color:var(--color-base-100);position:sticky;top:0}.table :where(.table-pin-rows tfoot tr){z-index:1;background-color:var(--color-base-100);position:sticky;bottom:0}.table :where(.table-pin-cols tr th){background-color:var(--color-base-100);position:sticky;left:0;right:0}.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.diff-resizer{z-index:1;resize:horizontal;opacity:0;cursor:ew-resize;transform-origin:100% 100%;clip-path:inset(calc(100% - .75rem) 0 0 calc(100% - .75rem));grid-row-start:1;grid-column-start:1;width:50cqi;min-width:1rem;max-width:calc(100cqi - 1rem);height:.5rem;transition:min-width .3s ease-out,max-width .3s ease-out;position:relative;top:50%;overflow:hidden;transform:scaleY(3)translate(.35rem,.08rem)}.range{-webkit-appearance:none;-moz-appearance:none;appearance:none;webkit-appearance:none;--range-thumb:var(--color-base-100);--range-thumb-size:calc(var(--size-selector,.25rem)*6);--range-progress:currentColor;--range-fill:1;--range-p:.25rem;--range-bg:currentColor}@supports (color:color-mix(in lab,red,red)){.range{--range-bg:color-mix(in oklab,currentColor 10%,#0000)}}.range{cursor:pointer;vertical-align:middle;--radius-selector-max:calc(var(--radius-selector) + var(--radius-selector) + var(--radius-selector));border-radius:calc(var(--radius-selector) + min(var(--range-p),var(--radius-selector-max)));width:clamp(3rem,20rem,100%);height:var(--range-thumb-size);background-color:#0000;border:none;overflow:hidden}[dir=rtl] .range{--range-dir:-1}.range:focus{outline:none}.range:focus-visible{outline-offset:2px;outline:2px solid}.range::-webkit-slider-runnable-track{background-color:var(--range-bg);border-radius:var(--radius-selector);width:100%;height:calc(var(--range-thumb-size)*.5)}@media (forced-colors:active){.range::-webkit-slider-runnable-track{border:1px solid}.range::-moz-range-track{border:1px solid}}.range::-webkit-slider-thumb{box-sizing:border-box;border-radius:calc(var(--radius-selector) + min(var(--range-p),var(--radius-selector-max)));height:var(--range-thumb-size);width:var(--range-thumb-size);border:var(--range-p)solid;-webkit-appearance:none;-moz-appearance:none;appearance:none;webkit-appearance:none;color:var(--range-progress);box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px currentColor,0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill));background-color:currentColor;position:relative;top:50%;transform:translateY(-50%)}@supports (color:color-mix(in lab,red,red)){.range::-webkit-slider-thumb{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000),0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill))}}.range::-moz-range-track{background-color:var(--range-bg);border-radius:var(--radius-selector);width:100%;height:calc(var(--range-thumb-size)*.5)}.range::-moz-range-thumb{box-sizing:border-box;border-radius:calc(var(--radius-selector) + min(var(--range-p),var(--radius-selector-max)));height:var(--range-thumb-size);width:var(--range-thumb-size);border:var(--range-p)solid;color:var(--range-progress);box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px currentColor,0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill));background-color:currentColor;position:relative;top:50%}@supports (color:color-mix(in lab,red,red)){.range::-moz-range-thumb{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000),0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill))}}.range:disabled{cursor:not-allowed;opacity:.3}.card{border-radius:var(--radius-box);outline-offset:2px;outline:0 solid #0000;flex-direction:column;transition:outline .2s ease-in-out;display:flex;position:relative}.card:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.card:focus{outline-offset:2px;outline:2px solid #0000}}.card:focus-visible{outline-color:currentColor}.card :where(figure:first-child){border-start-start-radius:inherit;border-start-end-radius:inherit;border-end-end-radius:unset;border-end-start-radius:unset;overflow:hidden}.card :where(figure:last-child){border-start-start-radius:unset;border-start-end-radius:unset;border-end-end-radius:inherit;border-end-start-radius:inherit;overflow:hidden}.card:where(.card-border){border:var(--border)solid var(--color-base-200)}.card:where(.card-dash){border:var(--border)dashed var(--color-base-200)}.card.image-full{display:grid}.card.image-full>*{grid-row-start:1;grid-column-start:1}.card.image-full>.card-body{color:var(--color-neutral-content);position:relative}.card.image-full :where(figure){border-radius:inherit;overflow:hidden}.card.image-full>figure img{object-fit:cover;filter:brightness(28%);height:100%}.card figure{justify-content:center;align-items:center;display:flex}.card:has(>input:is(input[type=checkbox],input[type=radio])){cursor:pointer;-webkit-user-select:none;user-select:none}.card:has(>:checked){outline:2px solid}.swap{cursor:pointer;vertical-align:middle;webkit-user-select:none;-webkit-user-select:none;user-select:none;place-content:center;display:inline-grid;position:relative}.swap input{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none}.swap>*{grid-row-start:1;grid-column-start:1}@media (prefers-reduced-motion:no-preference){.swap>*{transition-property:transform,rotate,opacity;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1)}}.swap .swap-on,.swap .swap-indeterminate,.swap input:indeterminate~.swap-on,.swap input:is(:checked,:indeterminate)~.swap-off{opacity:0}.swap input:checked~.swap-on,.swap input:indeterminate~.swap-indeterminate{opacity:1;backface-visibility:visible}.checkbox{border:var(--border)solid var(--input-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.checkbox{border:var(--border)solid var(--input-color,color-mix(in oklab,var(--color-base-content)20%,#0000))}}.checkbox{cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;border-radius:var(--radius-selector);vertical-align:middle;color:var(--color-base-content);box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 0 #0000 inset,0 0 #0000;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);flex-shrink:0;padding:.25rem;transition:background-color .2s,box-shadow .2s;display:inline-block;position:relative}.checkbox:before{--tw-content:"";content:var(--tw-content);opacity:0;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,70% 80%,70% 100%);width:100%;height:100%;box-shadow:0 3px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-color:currentColor;font-size:1rem;line-height:.75;transition:clip-path .3s .1s,opacity .1s .1s,rotate .3s .1s,translate .3s .1s;display:block;rotate:45deg}.checkbox:focus-visible{outline:2px solid var(--input-color,currentColor);outline-offset:2px}.checkbox:checked,.checkbox[aria-checked=true]{background-color:var(--input-color,#0000);box-shadow:0 0 #0000 inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1))}:is(.checkbox:checked,.checkbox[aria-checked=true]):before{clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 0%,70% 0%,70% 100%);opacity:1}@media (forced-colors:active){:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}@media print{:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}.checkbox:indeterminate{background-color:var(--input-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.checkbox:indeterminate{background-color:var(--input-color,color-mix(in oklab,var(--color-base-content)20%,#0000))}}.checkbox:indeterminate:before{opacity:1;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,80% 80%,80% 100%);translate:0 -35%;rotate:none}.checkbox:disabled{cursor:not-allowed;opacity:.2}.radio{cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;vertical-align:middle;border:var(--border)solid var(--input-color,currentColor);border-radius:3.40282e38px;flex-shrink:0;padding:.25rem;display:inline-block;position:relative}@supports (color:color-mix(in lab,red,red)){.radio{border:var(--border)solid var(--input-color,color-mix(in srgb,currentColor 20%,#0000))}}.radio{box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);color:var(--input-color,currentColor)}.radio:before{--tw-content:"";content:var(--tw-content);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);border-radius:3.40282e38px;width:100%;height:100%;display:block}.radio:focus-visible{outline:2px solid}.radio:checked,.radio[aria-checked=true]{background-color:var(--color-base-100);border-color:currentColor}@media (prefers-reduced-motion:no-preference){.radio:checked,.radio[aria-checked=true]{animation:.2s ease-out radio}}:is(.radio:checked,.radio[aria-checked=true]):before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1));background-color:currentColor}@media (forced-colors:active){:is(.radio:checked,.radio[aria-checked=true]):before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{:is(.radio:checked,.radio[aria-checked=true]):before{outline-offset:-1rem;outline:.25rem solid}}.radio:disabled{cursor:not-allowed;opacity:.2}.rating{vertical-align:middle;display:inline-flex;position:relative}.rating input{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none}.rating :where(*){background-color:var(--color-base-content);opacity:.2;border-radius:0;width:1.5rem;height:1.5rem}@media (prefers-reduced-motion:no-preference){.rating :where(*){animation:.25s ease-out rating}}.rating :where(*):is(input){cursor:pointer}.rating .rating-hidden{background-color:#0000;width:.5rem}.rating input[type=radio]:checked{background-image:none}.rating :checked,.rating [aria-checked=true],.rating [aria-current=true],.rating :has(~:checked,~[aria-checked=true],~[aria-current=true]){opacity:1}.rating :focus-visible{scale:1.1}@media (prefers-reduced-motion:no-preference){.rating :focus-visible{transition:scale .2s ease-out}}.rating :active:focus{animation:none;scale:1.1}.rating.rating-xs :where(:not(.rating-hidden)){width:1rem;height:1rem}.rating.rating-sm :where(:not(.rating-hidden)){width:1.25rem;height:1.25rem}.rating.rating-md :where(:not(.rating-hidden)){width:1.5rem;height:1.5rem}.rating.rating-lg :where(:not(.rating-hidden)){width:1.75rem;height:1.75rem}.rating.rating-xl :where(:not(.rating-hidden)){width:2rem;height:2rem}.stats{border-radius:var(--radius-box);grid-auto-flow:column;display:inline-grid;position:relative;overflow-x:auto}.progress{-webkit-appearance:none;-moz-appearance:none;appearance:none;border-radius:var(--radius-box);background-color:currentColor;width:100%;height:.5rem;position:relative;overflow:hidden}@supports (color:color-mix(in lab,red,red)){.progress{background-color:color-mix(in oklab,currentColor 20%,transparent)}}.progress{color:var(--color-base-content)}.progress:indeterminate{background-image:repeating-linear-gradient(90deg,currentColor -1% 10%,#0000 10% 90%);background-position-x:15%;background-size:200%}@media (prefers-reduced-motion:no-preference){.progress:indeterminate{animation:5s ease-in-out infinite progress}}@supports ((-moz-appearance:none)){.progress:indeterminate::-moz-progress-bar{background-color:#0000}@media (prefers-reduced-motion:no-preference){.progress:indeterminate::-moz-progress-bar{background-image:repeating-linear-gradient(90deg,currentColor -1% 10%,#0000 10% 90%);background-position-x:15%;background-size:200%;animation:5s ease-in-out infinite progress}}.progress::-moz-progress-bar{border-radius:var(--radius-box);background-color:currentColor}}@supports ((-webkit-appearance:none)){.progress::-webkit-progress-bar{border-radius:var(--radius-box);background-color:#0000}.progress::-webkit-progress-value{border-radius:var(--radius-box);background-color:currentColor}}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.relative\\!{position:relative!important}.static{position:static}.sticky{position:sticky}.tooltip-bottom>.tooltip-content,.tooltip-bottom[data-tip]:before{transform:translate(-50%)translateY(var(--tt-pos,-.25rem));inset:var(--tt-off)auto auto 50%}.tooltip-bottom:after{transform:translate(-50%)translateY(var(--tt-pos,-.25rem))rotate(180deg);inset:var(--tt-tail)auto auto 50%}.tooltip-left>.tooltip-content,.tooltip-left[data-tip]:before{transform:translate(calc(var(--tt-pos,.25rem) - .25rem))translateY(-50%);inset:50% var(--tt-off)auto auto}.tooltip-left:after{transform:translate(var(--tt-pos,.25rem))translateY(-50%)rotate(-90deg);inset:50% calc(var(--tt-tail) + 1px)auto auto}.tooltip-top>.tooltip-content,.tooltip-top[data-tip]:before{transform:translate(-50%)translateY(var(--tt-pos,.25rem));inset:auto auto var(--tt-off)50%}.tooltip-top:after{transform:translate(-50%)translateY(var(--tt-pos,.25rem));inset:auto auto var(--tt-tail)50%}.inset-0{inset:calc(var(--spacing)*0)}.inset-x-0{inset-inline:calc(var(--spacing)*0)}.inset-y-0{inset-block:calc(var(--spacing)*0)}.top-0{top:calc(var(--spacing)*0)}.top-1{top:calc(var(--spacing)*1)}.top-1\\.5{top:calc(var(--spacing)*1.5)}.top-1\\/2{top:50%}.top-4{top:calc(var(--spacing)*4)}.top-4\\!{top:calc(var(--spacing)*4)!important}.top-\\[-30px\\]{top:-30px}.right-0{right:calc(var(--spacing)*0)}.right-1{right:calc(var(--spacing)*1)}.right-1\\.5{right:calc(var(--spacing)*1.5)}.bottom-0{bottom:calc(var(--spacing)*0)}.bottom-1{bottom:calc(var(--spacing)*1)}.bottom-1\\.5{bottom:calc(var(--spacing)*1.5)}.bottom-\\[-50px\\]{bottom:-50px}.left-0{left:calc(var(--spacing)*0)}.left-1{left:calc(var(--spacing)*1)}.left-1\\.5{left:calc(var(--spacing)*1.5)}.left-1\\/2{left:50%}.left-4{left:calc(var(--spacing)*4)}.left-4\\!{left:calc(var(--spacing)*4)!important}.textarea{border:var(--border)solid #0000;-webkit-appearance:none;-moz-appearance:none;appearance:none;border-radius:var(--radius-field);background-color:var(--color-base-100);vertical-align:middle;touch-action:manipulation;border-color:var(--input-color);width:clamp(3rem,20rem,100%);min-height:5rem;box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;flex-shrink:1;padding-block:.5rem;padding-inline:.75rem;font-size:.875rem}@supports (color:color-mix(in lab,red,red)){.textarea{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.textarea{--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.textarea{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.textarea textarea{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#0000;border:none}.textarea textarea:focus,.textarea textarea:focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.textarea textarea:focus,.textarea textarea:focus-within{outline-offset:2px;outline:2px solid #0000}}.textarea:focus,.textarea:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.textarea:focus,.textarea:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.textarea:focus,.textarea:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate}.textarea:has(>textarea[disabled]),.textarea:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.textarea:has(>textarea[disabled]),.textarea:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.textarea:has(>textarea[disabled]),.textarea:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.textarea:has(>textarea[disabled]),.textarea:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.textarea:has(>textarea[disabled]),.textarea:is(:disabled,[disabled]){box-shadow:none}.textarea:has(>textarea[disabled])>textarea[disabled]{cursor:not-allowed}.btn-active{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn-active{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn-active{--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0);isolation:isolate}.stack{grid-template-rows:3px 4px 1fr 4px 3px;grid-template-columns:3px 4px 1fr 4px 3px;display:inline-grid}.stack>*{width:100%;height:100%}.stack>:nth-child(n+2){opacity:.7;width:100%}.stack>:nth-child(2){z-index:2;opacity:.9}.stack>:first-child{z-index:3;width:100%}:is(.stack,.stack.stack-bottom)>*{grid-area:3/3/6/4}:is(.stack,.stack.stack-bottom)>:nth-child(2){grid-area:2/2/5/5}:is(.stack,.stack.stack-bottom)>:first-child{grid-area:1/1/4/6}.stack.stack-top>*{grid-area:1/3/4/4}.stack.stack-top>:nth-child(2){grid-area:2/2/5/5}.stack.stack-top>:first-child{grid-area:3/1/6/6}.stack.stack-start>*{grid-area:3/1/4/4}.stack.stack-start>:nth-child(2){grid-area:2/2/5/5}.stack.stack-start>:first-child{grid-area:1/3/6/6}.stack.stack-end>*{grid-area:3/3/4/6}.stack.stack-end>:nth-child(2){grid-area:2/2/5/5}.stack.stack-end>:first-child{grid-area:1/1/6/4}.z-1{z-index:1}.z-2{z-index:2}.z-50{z-index:50}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.divider{white-space:nowrap;height:1rem;margin:var(--divider-m,1rem 0);--divider-color:var(--color-base-content);flex-direction:row;align-self:stretch;align-items:center;display:flex}@supports (color:color-mix(in lab,red,red)){.divider{--divider-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.divider:before,.divider:after{content:"";background-color:var(--divider-color);flex-grow:1;width:100%;height:.125rem}@media print{.divider:before,.divider:after{border:.5px solid}}.divider:not(:empty){gap:1rem}.m-0{margin:calc(var(--spacing)*0)}.m-auto{margin:auto}.filter{flex-wrap:wrap;display:flex}.filter input[type=radio]{width:auto}.filter input{opacity:1;transition:margin .1s,opacity .3s,padding .3s,border-width .1s;overflow:hidden;scale:1}.filter input:not(:last-child){margin-inline-end:.25rem}.filter input.filter-reset{aspect-ratio:1}.filter input.filter-reset:after{content:"×"}.filter:not(:has(input:checked:not(.filter-reset))) .filter-reset,.filter:not(:has(input:checked:not(.filter-reset))) input[type=reset],.filter:has(input:checked:not(.filter-reset)) input:not(:checked,.filter-reset,input[type=reset]){opacity:0;border-width:0;width:0;margin-inline:0;padding-inline:0;scale:0}.mx-2{margin-inline:calc(var(--spacing)*2)}.mx-auto{margin-inline:auto}.label{white-space:nowrap;color:currentColor;align-items:center;gap:.375rem;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.label{color:color-mix(in oklab,currentColor 60%,transparent)}}.label:has(input){cursor:pointer}.label:is(.input>*,.select>*){white-space:nowrap;height:calc(100% - .5rem);font-size:inherit;align-items:center;padding-inline:.75rem;display:flex}.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid currentColor;margin-inline:-.75rem .75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid currentColor;margin-inline:.75rem -.75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.join-item:where(:not(:first-child,:disabled,[disabled],.btn-disabled)){margin-block-start:0;margin-inline-start:calc(var(--border,1px)*-1)}.join-item:where(:is(:disabled,[disabled],.btn-disabled)){border-width:var(--border,1px)0 var(--border,1px)var(--border,1px)}.mt-1{margin-top:calc(var(--spacing)*1)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-3{margin-top:calc(var(--spacing)*3)}.mt-4{margin-top:calc(var(--spacing)*4)}.mt-5{margin-top:calc(var(--spacing)*5)}.mt-6{margin-top:calc(var(--spacing)*6)}.breadcrumbs{max-width:100%;padding-block:.5rem;overflow-x:auto}.breadcrumbs>menu,.breadcrumbs>ul,.breadcrumbs>ol{white-space:nowrap;align-items:center;min-height:min-content;display:flex}:is(.breadcrumbs>menu,.breadcrumbs>ul,.breadcrumbs>ol)>li{align-items:center;display:flex}:is(.breadcrumbs>menu,.breadcrumbs>ul,.breadcrumbs>ol)>li>*{cursor:pointer;align-items:center;gap:.5rem;display:flex}@media (hover:hover){:is(.breadcrumbs>menu,.breadcrumbs>ul,.breadcrumbs>ol)>li>:hover{text-decoration-line:underline}}:is(.breadcrumbs>menu,.breadcrumbs>ul,.breadcrumbs>ol)>li>:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){:is(.breadcrumbs>menu,.breadcrumbs>ul,.breadcrumbs>ol)>li>:focus{outline-offset:2px;outline:2px solid #0000}}:is(.breadcrumbs>menu,.breadcrumbs>ul,.breadcrumbs>ol)>li>:focus-visible{outline-offset:2px;outline:2px solid}:is(.breadcrumbs>menu,.breadcrumbs>ul,.breadcrumbs>ol)>li+:before{content:"";opacity:.4;background-color:#0000;border-top:1px solid;border-right:1px solid;width:.375rem;height:.375rem;margin-left:.5rem;margin-right:.75rem;display:block;rotate:45deg}[dir=rtl] :is(:is(.breadcrumbs>menu,.breadcrumbs>ul,.breadcrumbs>ol)>li)+:before{rotate:-135deg}.mr-2{margin-right:calc(var(--spacing)*2)}.fieldset-legend{color:var(--color-base-content);justify-content:space-between;align-items:center;gap:.5rem;margin-bottom:-.25rem;padding-block:.5rem;font-weight:600;display:flex}.mb-1{margin-bottom:calc(var(--spacing)*1)}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-3{margin-bottom:calc(var(--spacing)*3)}.mb-4{margin-bottom:calc(var(--spacing)*4)}.mb-5{margin-bottom:calc(var(--spacing)*5)}.mb-6{margin-bottom:calc(var(--spacing)*6)}.box-border{box-sizing:border-box}.status{aspect-ratio:1;border-radius:var(--radius-selector);background-color:var(--color-base-content);width:.5rem;height:.5rem;display:inline-block}@supports (color:color-mix(in lab,red,red)){.status{background-color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.status{vertical-align:middle;color:#0000004d;background-position:50%;background-repeat:no-repeat}@supports (color:color-mix(in lab,red,red)){.status{color:#0000004d}@supports (color:color-mix(in lab,red,red)){.status{color:color-mix(in oklab,var(--color-black)30%,transparent)}}}.status{background-image:radial-gradient(circle at 35% 30%,oklch(1 0 0/calc(var(--depth)*.5)),#0000);box-shadow:0 2px 3px -1px}@supports (color:color-mix(in lab,red,red)){.status{box-shadow:0 2px 3px -1px color-mix(in oklab,currentColor calc(var(--depth)*100%),#0000)}}.status\\!{aspect-ratio:1!important;border-radius:var(--radius-selector)!important;background-color:var(--color-base-content)!important;width:.5rem!important;height:.5rem!important;display:inline-block!important}@supports (color:color-mix(in lab,red,red)){.status\\!{background-color:color-mix(in oklab,var(--color-base-content)20%,transparent)!important}}.status\\!{vertical-align:middle!important;color:#0000004d!important;background-position:50%!important;background-repeat:no-repeat!important}@supports (color:color-mix(in lab,red,red)){.status\\!{color:#0000004d!important}@supports (color:color-mix(in lab,red,red)){.status\\!{color:color-mix(in oklab,var(--color-black)30%,transparent)!important}}}.status\\!{background-image:radial-gradient(circle at 35% 30%,oklch(1 0 0/calc(var(--depth)*.5)),#0000)!important;box-shadow:0 2px 3px -1px!important}@supports (color:color-mix(in lab,red,red)){.status\\!{box-shadow:0 2px 3px -1px color-mix(in oklab,currentColor calc(var(--depth)*100%),#0000)!important}}.badge{border-radius:var(--radius-selector);vertical-align:middle;color:var(--badge-fg);border:var(--border)solid var(--badge-color,var(--color-base-200));width:fit-content;padding-inline:calc(.25rem*3 - var(--border));background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);background-color:var(--badge-bg);--badge-bg:var(--badge-color,var(--color-base-100));--badge-fg:var(--color-base-content);--size:calc(var(--size-selector,.25rem)*6);height:var(--size);justify-content:center;align-items:center;gap:.5rem;font-size:.875rem;display:inline-flex}.footer{grid-auto-flow:row;place-items:start;gap:2.5rem 1rem;width:100%;font-size:.875rem;line-height:1.25rem;display:grid}.footer>*{place-items:start;gap:.5rem;display:grid}.footer.footer-center{text-align:center;grid-auto-flow:column dense;place-items:center}.footer.footer-center>*{place-items:center}.card-body{padding:var(--card-p,1.5rem);font-size:var(--card-fs,.875rem);flex-direction:column;flex:auto;gap:.5rem;display:flex}.card-body :where(p){flex-grow:1}.alert{border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;border:var(--border)solid var(--color-base-200);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}.alert.alert-outline{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none}.alert.alert-dash{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none;border-style:dashed}.alert.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert.alert-soft{border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert.alert-soft{box-shadow:none;background-image:none}.fieldset{grid-template-columns:1fr;grid-auto-rows:max-content;gap:.375rem;padding-block:.25rem;font-size:.75rem;display:grid}.card-title{font-size:var(--cardtitle-fs,1.125rem);align-items:center;gap:.5rem;font-weight:600;display:flex}.line-clamp-2{-webkit-line-clamp:2;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.line-clamp-3{-webkit-line-clamp:3;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}:root .prose{--tw-prose-body:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:root .prose{--tw-prose-body:color-mix(in oklab,var(--color-base-content)80%,#0000)}}:root .prose{--tw-prose-headings:var(--color-base-content);--tw-prose-lead:var(--color-base-content);--tw-prose-links:var(--color-base-content);--tw-prose-bold:var(--color-base-content);--tw-prose-counters:var(--color-base-content);--tw-prose-bullets:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:root .prose{--tw-prose-bullets:color-mix(in oklab,var(--color-base-content)50%,#0000)}}:root .prose{--tw-prose-hr:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:root .prose{--tw-prose-hr:color-mix(in oklab,var(--color-base-content)20%,#0000)}}:root .prose{--tw-prose-quotes:var(--color-base-content);--tw-prose-quote-borders:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:root .prose{--tw-prose-quote-borders:color-mix(in oklab,var(--color-base-content)20%,#0000)}}:root .prose{--tw-prose-captions:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:root .prose{--tw-prose-captions:color-mix(in oklab,var(--color-base-content)50%,#0000)}}:root .prose{--tw-prose-code:var(--color-base-content);--tw-prose-pre-code:var(--color-neutral-content);--tw-prose-pre-bg:var(--color-neutral);--tw-prose-th-borders:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:root .prose{--tw-prose-th-borders:color-mix(in oklab,var(--color-base-content)50%,#0000)}}:root .prose{--tw-prose-td-borders:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:root .prose{--tw-prose-td-borders:color-mix(in oklab,var(--color-base-content)20%,#0000)}}:root .prose{--tw-prose-kbd:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:root .prose{--tw-prose-kbd:color-mix(in oklab,var(--color-base-content)80%,#0000)}}:root .prose :where(code):not(pre>code){background-color:var(--color-base-200);border-radius:var(--radius-selector);border:var(--border)solid var(--color-base-300);font-weight:inherit;padding-inline:.5em}:root .prose :where(code):not(pre>code):before,:root .prose :where(code):not(pre>code):after{display:none}.mask{vertical-align:middle;display:inline-block;-webkit-mask-position:50%;mask-position:50%;-webkit-mask-size:contain;mask-size:contain;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.inline{display:inline}.inline-block{display:inline-block}.inline-flex{display:inline-flex}.table{display:table}.aspect-video{aspect-ratio:var(--aspect-video)}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.size-3{width:calc(var(--spacing)*3);height:calc(var(--spacing)*3)}.size-3\\.5{width:calc(var(--spacing)*3.5);height:calc(var(--spacing)*3.5)}.size-4{width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.size-6{width:calc(var(--spacing)*6);height:calc(var(--spacing)*6)}.size-7{width:calc(var(--spacing)*7);height:calc(var(--spacing)*7)}.size-8{width:calc(var(--spacing)*8);height:calc(var(--spacing)*8)}.size-12{width:calc(var(--spacing)*12);height:calc(var(--spacing)*12)}.size-20{width:calc(var(--spacing)*20);height:calc(var(--spacing)*20)}.size-\\[61\\.8\\%\\]{width:61.8%;height:61.8%}.h-\\(--app-playlist-header-height\\){height:var(--app-playlist-header-height)}.h-1{height:calc(var(--spacing)*1)}.h-2{height:calc(var(--spacing)*2)}.h-2\\.5{height:calc(var(--spacing)*2.5)}.h-5{height:calc(var(--spacing)*5)}.h-7{height:calc(var(--spacing)*7)}.h-8{height:calc(var(--spacing)*8)}.h-12{height:calc(var(--spacing)*12)}.h-16{height:calc(var(--spacing)*16)}.h-20{height:calc(var(--spacing)*20)}.h-24{height:calc(var(--spacing)*24)}.h-28{height:calc(var(--spacing)*28)}.h-32{height:calc(var(--spacing)*32)}.h-auto{height:auto}.h-full{height:100%}.h-screen{height:100vh}.min-h-screen{min-height:100vh}.w-\\(--app-playlist-width\\)\\!{width:var(--app-playlist-width)!important}.w-0{width:calc(var(--spacing)*0)}.w-1{width:calc(var(--spacing)*1)}.w-1\\/3{width:33.3333%}.w-2{width:calc(var(--spacing)*2)}.w-2\\.5{width:calc(var(--spacing)*2.5)}.w-8{width:calc(var(--spacing)*8)}.w-12{width:calc(var(--spacing)*12)}.w-16{width:calc(var(--spacing)*16)}.w-20{width:calc(var(--spacing)*20)}.w-24{width:calc(var(--spacing)*24)}.w-32{width:calc(var(--spacing)*32)}.w-35{width:calc(var(--spacing)*35)}.w-50{width:calc(var(--spacing)*50)}.w-80{width:calc(var(--spacing)*80)}.w-\\[calc\\(100\\%-var\\(--app-playlist-width\\)\\)\\]\\!{width:calc(100% - var(--app-playlist-width))!important}.w-full{width:100%}.w-lg{width:var(--container-lg)}.max-w-214{max-width:calc(var(--spacing)*214)}.max-w-full{max-width:100%}.max-w-xl{max-width:var(--container-xl)}.min-w-32{min-width:calc(var(--spacing)*32)}.flex-1{flex:1}.flex-shrink{flex-shrink:1}.flex-shrink-0{flex-shrink:0}.table-fixed{table-layout:fixed}.-translate-x-1{--tw-translate-x:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-x-1\\/2{--tw-translate-x: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1{--tw-translate-y:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1\\/2{--tw-translate-y: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.\\!scale-80{--tw-scale-x:80%!important;--tw-scale-y:80%!important;--tw-scale-z:80%!important;scale:var(--tw-scale-x)var(--tw-scale-y)!important}.\\!scale-100{--tw-scale-x:100%!important;--tw-scale-y:100%!important;--tw-scale-z:100%!important;scale:var(--tw-scale-x)var(--tw-scale-y)!important}.scale-0{--tw-scale-x:0%;--tw-scale-y:0%;--tw-scale-z:0%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-100{--tw-scale-x:100%;--tw-scale-y:100%;--tw-scale-z:100%;scale:var(--tw-scale-x)var(--tw-scale-y)}.swap-rotate .swap-on,.swap-rotate input:indeterminate~.swap-on{rotate:45deg}.swap-rotate input:is(:checked,:indeterminate)~.swap-on,.swap-rotate.swap-active .swap-on{rotate:none}.swap-rotate input:is(:checked,:indeterminate)~.swap-off,.swap-rotate.swap-active .swap-off{rotate:-45deg}.rotate-90{rotate:90deg}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.transform-gpu{transform:translateZ(0)var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.skeleton{border-radius:var(--radius-box);background-color:var(--color-base-300)}@media (prefers-reduced-motion:reduce){.skeleton{transition-duration:15s}}.skeleton{will-change:background-position;background-image:linear-gradient(105deg,#0000 0% 40%,var(--color-base-100)50%,#0000 60% 100%);background-position-x:-50%;background-repeat:no-repeat;background-size:200%}@media (prefers-reduced-motion:no-preference){.skeleton{animation:1.8s ease-in-out infinite skeleton}}.animate-\\[fadeOut_350ms_linear_forwards\\]{animation:.35s linear forwards fadeOut}.link{cursor:pointer;text-decoration-line:underline}.link:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.link:focus{outline-offset:2px;outline:2px solid #0000}}.link:focus-visible{outline-offset:2px;outline:2px solid}.cursor-pointer{cursor:pointer}.cursor-zoom-in{cursor:zoom-in}.resize{resize:both}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.items-baseline{align-items:baseline}.items-center{align-items:center}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-end{justify-content:flex-end}.gap-1{gap:calc(var(--spacing)*1)}.gap-1\\.5{gap:calc(var(--spacing)*1.5)}.gap-2{gap:calc(var(--spacing)*2)}.gap-2\\.5{gap:calc(var(--spacing)*2.5)}.gap-3{gap:calc(var(--spacing)*3)}.gap-4{gap:calc(var(--spacing)*4)}.gap-5{gap:calc(var(--spacing)*5)}.gap-8{gap:calc(var(--spacing)*8)}.overflow-hidden{overflow:hidden}.overflow-y-auto{overflow-y:auto}.rounded{border-radius:.25rem}.rounded-2xl{border-radius:var(--radius-2xl)}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius-lg)}.rounded-xl{border-radius:var(--radius-xl)}.rounded-t-xl{border-top-left-radius:var(--radius-xl);border-top-right-radius:var(--radius-xl)}.border{border-style:var(--tw-border-style);border-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-l{border-left-style:var(--tw-border-style);border-left-width:1px}.border-l-2{border-left-style:var(--tw-border-style);border-left-width:2px}.border-base-300,.border-base-300\\/15{border-color:var(--color-base-300)}@supports (color:color-mix(in lab,red,red)){.border-base-300\\/15{border-color:color-mix(in oklab,var(--color-base-300)15%,transparent)}}.border-base-content{border-color:var(--color-base-content)}.border-error{border-color:var(--color-error)}.border-neutral-950{border-color:var(--color-neutral-950)}.\\!bg-white\\/50{background-color:#ffffff80!important}@supports (color:color-mix(in lab,red,red)){.\\!bg-white\\/50{background-color:color-mix(in oklab,var(--color-white)50%,transparent)!important}}.bg-base-100,.bg-base-100\\/60{background-color:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){.bg-base-100\\/60{background-color:color-mix(in oklab,var(--color-base-100)60%,transparent)}}.bg-base-100\\/90{background-color:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){.bg-base-100\\/90{background-color:color-mix(in oklab,var(--color-base-100)90%,transparent)}}.bg-base-200{background-color:var(--color-base-200)}.bg-base-300{background-color:var(--color-base-300)}.bg-base-content{background-color:var(--color-base-content)}.bg-base-content\\!{background-color:var(--color-base-content)!important}.bg-base-content\\/30{background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.bg-base-content\\/30{background-color:color-mix(in oklab,var(--color-base-content)30%,transparent)}}.bg-black{background-color:var(--color-black)}.bg-black\\/30{background-color:#0000004d}@supports (color:color-mix(in lab,red,red)){.bg-black\\/30{background-color:color-mix(in oklab,var(--color-black)30%,transparent)}}.bg-black\\/90{background-color:#000000e6}@supports (color:color-mix(in lab,red,red)){.bg-black\\/90{background-color:color-mix(in oklab,var(--color-black)90%,transparent)}}.bg-error{background-color:var(--color-error)}.bg-neutral-800{background-color:var(--color-neutral-800)}.bg-primary,.bg-primary\\/10{background-color:var(--color-primary)}@supports (color:color-mix(in lab,red,red)){.bg-primary\\/10{background-color:color-mix(in oklab,var(--color-primary)10%,transparent)}}.bg-white{background-color:var(--color-white)}.bg-linear-to-b{--tw-gradient-position:to bottom}@supports (background-image:linear-gradient(in lab,red,red)){.bg-linear-to-b{--tw-gradient-position:to bottom in oklab}}.bg-linear-to-b{background-image:linear-gradient(var(--tw-gradient-stops))}.bg-linear-to-t{--tw-gradient-position:to top}@supports (background-image:linear-gradient(in lab,red,red)){.bg-linear-to-t{--tw-gradient-position:to top in oklab}}.bg-linear-to-t{background-image:linear-gradient(var(--tw-gradient-stops))}.from-black{--tw-gradient-from:var(--color-black);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-black\\/30{--tw-gradient-from:#0000004d}@supports (color:color-mix(in lab,red,red)){.from-black\\/30{--tw-gradient-from:color-mix(in oklab,var(--color-black)30%,transparent)}}.from-black\\/30{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-black\\/50{--tw-gradient-from:#00000080}@supports (color:color-mix(in lab,red,red)){.from-black\\/50{--tw-gradient-from:color-mix(in oklab,var(--color-black)50%,transparent)}}.from-black\\/50{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-10\\%{--tw-gradient-from-position:10%}.to-transparent{--tw-gradient-to:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.loading-spinner{-webkit-mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3Csvg width='24' height='24' stroke='black' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cg transform-origin='center'%3E%3Ccircle cx='12' cy='12' r='9.5' fill='none' stroke-width='3' stroke-linecap='round'%3E%3CanimateTransform attributeName='transform' type='rotate' from='0 12 12' to='360 12 12' dur='2s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dasharray' values='0,150;42,150;42,150' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-dashoffset' values='0;-16;-59' keyTimes='0;0.475;1' dur='1.5s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E")}.object-contain{object-fit:contain}.object-cover{object-fit:cover}.object-center{object-position:center}.p-0{padding:calc(var(--spacing)*0)}.p-0\\.5{padding:calc(var(--spacing)*.5)}.p-1{padding:calc(var(--spacing)*1)}.p-2{padding:calc(var(--spacing)*2)}.p-2\\.5{padding:calc(var(--spacing)*2.5)}.p-3{padding:calc(var(--spacing)*3)}.p-4{padding:calc(var(--spacing)*4)}.p-6{padding:calc(var(--spacing)*6)}.p-7{padding:calc(var(--spacing)*7)}.p-8{padding:calc(var(--spacing)*8)}.p-10{padding:calc(var(--spacing)*10)}.badge-sm{--size:calc(var(--size-selector,.25rem)*5);padding-inline:calc(.25rem*2.5 - var(--border));font-size:.75rem}.px-\\(--app-playlist-space\\){padding-inline:var(--app-playlist-space)}.px-1{padding-inline:calc(var(--spacing)*1)}.px-1\\.5{padding-inline:calc(var(--spacing)*1.5)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-4{padding-inline:calc(var(--spacing)*4)}.px-5{padding-inline:calc(var(--spacing)*5)}.px-6{padding-inline:calc(var(--spacing)*6)}.px-7{padding-inline:calc(var(--spacing)*7)}.px-20{padding-inline:calc(var(--spacing)*20)}.py-0{padding-block:calc(var(--spacing)*0)}.py-0\\.5{padding-block:calc(var(--spacing)*.5)}.py-1{padding-block:calc(var(--spacing)*1)}.py-2{padding-block:calc(var(--spacing)*2)}.py-3{padding-block:calc(var(--spacing)*3)}.py-4{padding-block:calc(var(--spacing)*4)}.py-8{padding-block:calc(var(--spacing)*8)}.pt-2{padding-top:calc(var(--spacing)*2)}.pt-\\[calc\\(var\\(--app-playlist-header-height\\)\\+var\\(--spacing\\)\\*5\\)\\]{padding-top:calc(var(--app-playlist-header-height) + var(--spacing)*5)}.pr-3{padding-right:calc(var(--spacing)*3)}.pb-2{padding-bottom:calc(var(--spacing)*2)}.pb-5{padding-bottom:calc(var(--spacing)*5)}.pl-3{padding-left:calc(var(--spacing)*3)}.text-center{text-align:center}.text-right{text-align:right}.align-middle{vertical-align:middle}.align-top{vertical-align:top}.font-mono{font-family:var(--font-mono)}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-3xl{font-size:var(--text-3xl);line-height:var(--tw-leading,var(--text-3xl--line-height))}.text-4xl{font-size:var(--text-4xl);line-height:var(--tw-leading,var(--text-4xl--line-height))}.text-5xl{font-size:var(--text-5xl);line-height:var(--tw-leading,var(--text-5xl--line-height))}.text-6xl{font-size:var(--text-6xl);line-height:var(--tw-leading,var(--text-6xl--line-height))}.text-8xl{font-size:var(--text-8xl);line-height:var(--tw-leading,var(--text-8xl--line-height))}.text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xl{font-size:var(--text-xl);line-height:var(--tw-leading,var(--text-xl--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.leading-6{--tw-leading:calc(var(--spacing)*6);line-height:calc(var(--spacing)*6)}.leading-relaxed{--tw-leading:var(--leading-relaxed);line-height:var(--leading-relaxed)}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.break-words{overflow-wrap:break-word}.break-all{word-break:break-all}.whitespace-nowrap{white-space:nowrap}.whitespace-pre-wrap{white-space:pre-wrap}.range-primary{color:var(--color-primary);--range-thumb:var(--color-primary-content)}.progress-primary{color:var(--color-primary)}.text-base-content,.text-base-content\\/30{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.text-base-content\\/30{color:color-mix(in oklab,var(--color-base-content)30%,transparent)}}.text-base-content\\/50{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.text-base-content\\/50{color:color-mix(in oklab,var(--color-base-content)50%,transparent)}}.text-base-content\\/60{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.text-base-content\\/60{color:color-mix(in oklab,var(--color-base-content)60%,transparent)}}.text-base-content\\/70{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.text-base-content\\/70{color:color-mix(in oklab,var(--color-base-content)70%,transparent)}}.text-base-content\\/80{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.text-base-content\\/80{color:color-mix(in oklab,var(--color-base-content)80%,transparent)}}.text-error-content{color:var(--color-error-content)}.text-gray-100{color:var(--color-gray-100)}.text-neutral-300{color:var(--color-neutral-300)}.text-primary{color:var(--color-primary)}.text-red-400{color:var(--color-red-400)}.text-white{color:var(--color-white)}.text-yellow-400{color:var(--color-yellow-400)}.btn-link{--btn-border:#0000;--btn-bg:#0000;--btn-fg:var(--color-primary);--btn-noise:none;--btn-shadow:"";outline-color:currentColor;text-decoration-line:underline}.btn-link:is(.btn-active,:hover,:active:focus,:focus-visible){--btn-border:#0000;--btn-bg:#0000;text-decoration-line:underline}@media (hover:none){.btn-link:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){text-decoration-line:none}}.no-underline{text-decoration-line:none}.subpixel-antialiased{-webkit-font-smoothing:auto;-moz-osx-font-smoothing:auto}.swap-active .swap-off{opacity:0}.swap-active .swap-on{opacity:1}.opacity-0{opacity:0}.opacity-60{opacity:.6}.opacity-80{opacity:.8}.opacity-100{opacity:1}.shadow-xl\\/60{--tw-shadow-alpha:60%;--tw-shadow:0 20px 25px -5px var(--tw-shadow-color,oklab(0% 0 0/.6)),0 8px 10px -6px var(--tw-shadow-color,oklab(0% 0 0/.6));box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xs\\/30{--tw-shadow-alpha:30%;--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,oklab(0% 0 0/.3));box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xs\\/90{--tw-shadow-alpha:90%;--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,oklab(0% 0 0/.9));box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow,.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xl{--tw-shadow:0 20px 25px -5px var(--tw-shadow-color,#0000001a),0 8px 10px -6px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xs{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-4{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-base-content,.ring-base-content\\/90{--tw-ring-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.ring-base-content\\/90{--tw-ring-color:color-mix(in oklab,var(--color-base-content)90%,transparent)}}.ring-primary{--tw-ring-color:var(--color-primary)}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible):not(:disabled,[disabled],.btn-disabled){--btn-fg:currentColor;outline-color:currentColor}@media (hover:none){.btn-ghost:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none;--btn-fg:currentColor}}.blur{--tw-blur:blur(8px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.drop-shadow-xl\\/30{--tw-drop-shadow-alpha:30%;--tw-drop-shadow-size:drop-shadow(0 9px 7px var(--tw-drop-shadow-color,oklab(0% 0 0/.3)));--tw-drop-shadow:var(--tw-drop-shadow-size);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.drop-shadow-xs\\/60{--tw-drop-shadow-alpha:60%;--tw-drop-shadow-size:drop-shadow(0 1px 1px var(--tw-drop-shadow-color,oklab(0% 0 0/.6)));--tw-drop-shadow:var(--tw-drop-shadow-size);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.drop-shadow-xs\\/90{--tw-drop-shadow-alpha:90%;--tw-drop-shadow-size:drop-shadow(0 1px 1px var(--tw-drop-shadow-color,oklab(0% 0 0/.9)));--tw-drop-shadow:var(--tw-drop-shadow-size);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.drop-shadow-xl{--tw-drop-shadow-size:drop-shadow(0 9px 7px var(--tw-drop-shadow-color,#0000001a));--tw-drop-shadow:drop-shadow(var(--drop-shadow-xl));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.drop-shadow-xs{--tw-drop-shadow-size:drop-shadow(0 1px 1px var(--tw-drop-shadow-color,#0000000d));--tw-drop-shadow:drop-shadow(var(--drop-shadow-xs));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.backdrop-blur-2xl{--tw-backdrop-blur:blur(var(--blur-2xl));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-blur-xs{--tw-backdrop-blur:blur(var(--blur-xs));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-brightness-50{--tw-backdrop-brightness:brightness(50%);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-saturate-200{--tw-backdrop-saturate:saturate(200%);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-filter{-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-\\[height\\]{transition-property:height;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-\\[width\\]{transition-property:width;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-opacity{transition-property:opacity;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-none{transition-property:none}.delay-60{transition-delay:60ms}.duration-100{--tw-duration:.1s;transition-duration:.1s}.duration-150{--tw-duration:.15s;transition-duration:.15s}.duration-200{--tw-duration:.2s;transition-duration:.2s}.duration-300{--tw-duration:.3s;transition-duration:.3s}.duration-450{--tw-duration:.45s;transition-duration:.45s}.duration-550{--tw-duration:.55s;transition-duration:.55s}.ease-in-out{--tw-ease:var(--ease-in-out);transition-timing-function:var(--ease-in-out)}.ease-linear{--tw-ease:linear;transition-timing-function:linear}.ease-out{--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.\\[will-change\\:transform\\]{will-change:transform}.btn-sm{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8)}.btn-xs{--fontsize:.6875rem;--btn-p:.5rem;--size:calc(var(--size-field,.25rem)*6)}.card-sm .card-body{--card-p:1rem;--card-fs:.75rem}.card-sm .card-title{--cardtitle-fs:1rem}.btn-error{--btn-color:var(--color-error);--btn-fg:var(--color-error-content)}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.select-none{-webkit-user-select:none;user-select:none}.select-text{-webkit-user-select:text;user-select:text}.text-shadow-xs\\/60{--tw-text-shadow-alpha:60%;text-shadow:0px 1px 1px var(--tw-text-shadow-color,oklab(0% 0 0/.6))}.\\[--app-playlist-header-height\\:calc\\(var\\(--spacing\\)\\*16\\)\\]{--app-playlist-header-height:calc(var(--spacing)*16)}.\\[--app-playlist-space\\:calc\\(var\\(--spacing\\)\\*4\\)\\]{--app-playlist-space:calc(var(--spacing)*4)}.\\[--app-playlist-width\\:min\\(400px\\,30vw\\)\\]{--app-playlist-width:min(400px,30vw)}.\\[content-visibility\\:auto\\]{content-visibility:auto}.range-xs{--range-thumb-size:calc(var(--size-selector,.25rem)*4)}.text-shadow-\\[0_0_1px_rgb\\(0_0_0_\\/0\\.5\\)\\,0_0_2px_rgb\\(55_55_55_\\/0\\.7\\)\\]{text-shadow:0 0 1px var(--tw-text-shadow-color,#00000080),0 0 2px var(--tw-text-shadow-color,#373737b3)}.text-shadow-\\[0_0_2px_rgba\\(0_0_0_\\/0\\.3\\)\\,0_0_2px_rgba\\(0_0_0_\\/0\\.3\\)\\,0_0_2px_rgba\\(0_0_0_\\/0\\.3\\)\\]{text-shadow:0 0 2px var(--tw-text-shadow-color,#0000004d),0 0 2px var(--tw-text-shadow-color,#0000004d),0 0 2px var(--tw-text-shadow-color,#0000004d)}.text-shadow-xs{text-shadow:0px 1px 1px var(--tw-text-shadow-color,#0003)}.toggle-primary:checked,.toggle-primary[aria-checked=true]{--input-color:var(--color-primary)}.toggle-sm[type=checkbox],.toggle-sm:has([type=checkbox]){--size:calc(var(--size-selector,.25rem)*5)}.before\\:absolute:before{content:var(--tw-content);position:absolute}.before\\:inset-0:before{content:var(--tw-content);inset:calc(var(--spacing)*0)}.before\\:ml-8:before{content:var(--tw-content);margin-left:calc(var(--spacing)*8)}.before\\:rounded-lg:before{content:var(--tw-content);border-radius:var(--radius-lg)}.before\\:bg-black:before{content:var(--tw-content);background-color:var(--color-black)}.before\\:content-\\[\\'\\'\\]:before{--tw-content:"";content:var(--tw-content)}.before\\:content-\\[\\\\\\'\\\\\\'\\]:before{--tw-content:\\'\\';content:var(--tw-content)}@media (hover:hover){.hover\\:scale-105:hover{--tw-scale-x:105%;--tw-scale-y:105%;--tw-scale-z:105%;scale:var(--tw-scale-x)var(--tw-scale-y)}.hover\\:scale-\\[1\\.02\\]:hover{scale:1.02}.hover\\:bg-base-content\\/5:hover{background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-base-content\\/5:hover{background-color:color-mix(in oklab,var(--color-base-content)5%,transparent)}}.hover\\:bg-primary\\/15:hover{background-color:var(--color-primary)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-primary\\/15:hover{background-color:color-mix(in oklab,var(--color-primary)15%,transparent)}}.hover\\:text-base-content\\/80:hover{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.hover\\:text-base-content\\/80:hover{color:color-mix(in oklab,var(--color-base-content)80%,transparent)}}.hover\\:no-underline\\!:hover{text-decoration-line:none!important}.hover\\:opacity-90:hover{opacity:.9}.hover\\:btn-error:hover{--btn-color:var(--color-error);--btn-fg:var(--color-error-content)}}.active\\:scale-95:active{--tw-scale-x:95%;--tw-scale-y:95%;--tw-scale-z:95%;scale:var(--tw-scale-x)var(--tw-scale-y)}.disabled\\:text-base-content\\/30:disabled{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.disabled\\:text-base-content\\/30:disabled{color:color-mix(in oklab,var(--color-base-content)30%,transparent)}}@media (prefers-reduced-motion:no-preference){.motion-safe\\:animate-spin{animation:var(--animate-spin)}}@media (min-width:80rem){.xl\\:px-36{padding-inline:calc(var(--spacing)*36)}}.\\[\\&\\:\\:-webkit-scrollbar-track\\]\\:mt-\\(--app-playlist-header-height\\)::-webkit-scrollbar-track{margin-top:var(--app-playlist-header-height)}}.range{--range-bg:var(--color-primary)}@supports (color:color-mix(in lab,red,red)){.range{--range-bg:color-mix(in oklch,var(--color-primary)30%,transparent)}}.range-xs{--range-thumb-size:calc(var(--size-selector,.25rem)*3);--range-p:0rem}.range-2xs{--range-thumb-size:calc(var(--size-selector,.25rem)*2);--range-p:0rem}[data-theme=dark] .skeleton{background-image:linear-gradient(105deg,#0000,#0000 40%,#fff5,#0000 60%,#0000)}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes progress{50%{background-position-x:-115%}}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-scale-x{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-y{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-z{syntax:"*";inherits:false;initial-value:1}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-gradient-position{syntax:"*";inherits:false}@property --tw-gradient-from{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-via{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-to{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-stops{syntax:"*";inherits:false}@property --tw-gradient-via-stops{syntax:"*";inherits:false}@property --tw-gradient-from-position{syntax:"<length-percentage>";inherits:false;initial-value:0%}@property --tw-gradient-via-position{syntax:"<length-percentage>";inherits:false;initial-value:50%}@property --tw-gradient-to-position{syntax:"<length-percentage>";inherits:false;initial-value:100%}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-backdrop-blur{syntax:"*";inherits:false}@property --tw-backdrop-brightness{syntax:"*";inherits:false}@property --tw-backdrop-contrast{syntax:"*";inherits:false}@property --tw-backdrop-grayscale{syntax:"*";inherits:false}@property --tw-backdrop-hue-rotate{syntax:"*";inherits:false}@property --tw-backdrop-invert{syntax:"*";inherits:false}@property --tw-backdrop-opacity{syntax:"*";inherits:false}@property --tw-backdrop-saturate{syntax:"*";inherits:false}@property --tw-backdrop-sepia{syntax:"*";inherits:false}@property --tw-duration{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}@property --tw-text-shadow-color{syntax:"*";inherits:false}@property --tw-text-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-content{syntax:"*";inherits:false;initial-value:""}@keyframes spin{to{transform:rotate(360deg)}}`;
      const scriptRel = /* @__PURE__ */ (function detectScriptRel() {
        const relList = typeof document !== "undefined" && document.createElement("link").relList;
        return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
      })();
      const assetsURL = function(dep) {
        return "/" + dep;
      };
      const seen = {};
      const __vitePreload = function preload(baseModule, deps, importerUrl) {
        let promise = Promise.resolve();
        if (deps && deps.length > 0) {
          let allSettled2 = function(promises) {
            return Promise.all(
              promises.map(
                (p) => Promise.resolve(p).then(
                  (value) => ({ status: "fulfilled", value }),
                  (reason) => ({ status: "rejected", reason })
                )
              )
            );
          };
          document.getElementsByTagName("link");
          const cspNonceMeta = document.querySelector(
            "meta[property=csp-nonce]"
          );
          const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
          promise = allSettled2(
            deps.map((dep) => {
              dep = assetsURL(dep);
              if (dep in seen) return;
              seen[dep] = true;
              const isCss = dep.endsWith(".css");
              const cssSelector = isCss ? '[rel="stylesheet"]' : "";
              if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
                return;
              }
              const link = document.createElement("link");
              link.rel = isCss ? "stylesheet" : scriptRel;
              if (!isCss) {
                link.as = "script";
              }
              link.crossOrigin = "";
              link.href = dep;
              if (cspNonce) {
                link.setAttribute("nonce", cspNonce);
              }
              document.head.appendChild(link);
              if (isCss) {
                return new Promise((res, rej) => {
                  link.addEventListener("load", res);
                  link.addEventListener(
                    "error",
                    () => rej(new Error(`Unable to preload CSS for ${dep}`))
                  );
                });
              }
            })
          );
        }
        function handlePreloadError(err) {
          const e = new Event("vite:preloadError", {
            cancelable: true
          });
          e.payload = err;
          window.dispatchEvent(e);
          if (!e.defaultPrevented) {
            throw err;
          }
        }
        return promise.then((res) => {
          for (const item of res || []) {
            if (item.status !== "rejected") continue;
            handlePreloadError(item.reason);
          }
          return baseModule().catch(handlePreloadError);
        });
      };
      const matchIconName$1 = /^[a-z0-9]+(-[a-z0-9]+)*$/;
      const stringToIcon$1 = (value, validate, allowSimpleName, provider = "") => {
        const colonSeparated = value.split(":");
        if (value.slice(0, 1) === "@") {
          if (colonSeparated.length < 2 || colonSeparated.length > 3) {
            return null;
          }
          provider = colonSeparated.shift().slice(1);
        }
        if (colonSeparated.length > 3 || !colonSeparated.length) {
          return null;
        }
        if (colonSeparated.length > 1) {
          const name2 = colonSeparated.pop();
          const prefix2 = colonSeparated.pop();
          const result2 = {
            // Allow provider without '@': "provider:prefix:name"
            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
            prefix: prefix2,
            name: name2
          };
          return validate && !validateIconName$1(result2) ? null : result2;
        }
        const name = colonSeparated[0];
        const dashSeparated = name.split("-");
        if (dashSeparated.length > 1) {
          const result2 = {
            provider,
            prefix: dashSeparated.shift(),
            name: dashSeparated.join("-")
          };
          return validate && !validateIconName$1(result2) ? null : result2;
        }
        if (allowSimpleName && provider === "") {
          const result2 = {
            provider,
            prefix: "",
            name
          };
          return validate && !validateIconName$1(result2, allowSimpleName) ? null : result2;
        }
        return null;
      };
      const validateIconName$1 = (icon, allowSimpleName) => {
        if (!icon) {
          return false;
        }
        return !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
        // Check name: cannot be empty
        ((allowSimpleName && icon.prefix === "" || !!icon.prefix) && !!icon.name);
      };
      const defaultIconDimensions$1 = Object.freeze(
        {
          left: 0,
          top: 0,
          width: 16,
          height: 16
        }
      );
      const defaultIconTransformations$1 = Object.freeze({
        rotate: 0,
        vFlip: false,
        hFlip: false
      });
      const defaultIconProps$1 = Object.freeze({
        ...defaultIconDimensions$1,
        ...defaultIconTransformations$1
      });
      const defaultExtendedIconProps$1 = Object.freeze({
        ...defaultIconProps$1,
        body: "",
        hidden: false
      });
      function mergeIconTransformations$1(obj1, obj2) {
        const result2 = {};
        if (!obj1.hFlip !== !obj2.hFlip) {
          result2.hFlip = true;
        }
        if (!obj1.vFlip !== !obj2.vFlip) {
          result2.vFlip = true;
        }
        const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
        if (rotate) {
          result2.rotate = rotate;
        }
        return result2;
      }
      function mergeIconData$1(parent, child) {
        const result2 = mergeIconTransformations$1(parent, child);
        for (const key in defaultExtendedIconProps$1) {
          if (key in defaultIconTransformations$1) {
            if (key in parent && !(key in result2)) {
              result2[key] = defaultIconTransformations$1[key];
            }
          } else if (key in child) {
            result2[key] = child[key];
          } else if (key in parent) {
            result2[key] = parent[key];
          }
        }
        return result2;
      }
      function getIconsTree$1(data, names) {
        const icons = data.icons;
        const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
        const resolved = /* @__PURE__ */ Object.create(null);
        function resolve(name) {
          if (icons[name]) {
            return resolved[name] = [];
          }
          if (!(name in resolved)) {
            resolved[name] = null;
            const parent = aliases[name] && aliases[name].parent;
            const value = parent && resolve(parent);
            if (value) {
              resolved[name] = [parent].concat(value);
            }
          }
          return resolved[name];
        }
        Object.keys(icons).concat(Object.keys(aliases)).forEach(resolve);
        return resolved;
      }
      function internalGetIconData$1(data, name, tree) {
        const icons = data.icons;
        const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
        let currentProps = {};
        function parse(name2) {
          currentProps = mergeIconData$1(
            icons[name2] || aliases[name2],
            currentProps
          );
        }
        parse(name);
        tree.forEach(parse);
        return mergeIconData$1(data, currentProps);
      }
      function parseIconSet$1(data, callback) {
        const names = [];
        if (typeof data !== "object" || typeof data.icons !== "object") {
          return names;
        }
        if (data.not_found instanceof Array) {
          data.not_found.forEach((name) => {
            callback(name, null);
            names.push(name);
          });
        }
        const tree = getIconsTree$1(data);
        for (const name in tree) {
          const item = tree[name];
          if (item) {
            callback(name, internalGetIconData$1(data, name, item));
            names.push(name);
          }
        }
        return names;
      }
      const optionalPropertyDefaults$1 = {
        provider: "",
        aliases: {},
        not_found: {},
        ...defaultIconDimensions$1
      };
      function checkOptionalProps$1(item, defaults) {
        for (const prop in defaults) {
          if (prop in item && typeof item[prop] !== typeof defaults[prop]) {
            return false;
          }
        }
        return true;
      }
      function quicklyValidateIconSet$1(obj) {
        if (typeof obj !== "object" || obj === null) {
          return null;
        }
        const data = obj;
        if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
          return null;
        }
        if (!checkOptionalProps$1(obj, optionalPropertyDefaults$1)) {
          return null;
        }
        const icons = data.icons;
        for (const name in icons) {
          const icon = icons[name];
          if (
            // Name cannot be empty
            !name || // Must have body
            typeof icon.body !== "string" || // Check other props
            !checkOptionalProps$1(
              icon,
              defaultExtendedIconProps$1
            )
          ) {
            return null;
          }
        }
        const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
        for (const name in aliases) {
          const icon = aliases[name];
          const parent = icon.parent;
          if (
            // Name cannot be empty
            !name || // Parent must be set and point to existing icon
            typeof parent !== "string" || !icons[parent] && !aliases[parent] || // Check other props
            !checkOptionalProps$1(
              icon,
              defaultExtendedIconProps$1
            )
          ) {
            return null;
          }
        }
        return data;
      }
      const dataStorage$1 = /* @__PURE__ */ Object.create(null);
      function newStorage$1(provider, prefix2) {
        return {
          provider,
          prefix: prefix2,
          icons: /* @__PURE__ */ Object.create(null),
          missing: /* @__PURE__ */ new Set()
        };
      }
      function getStorage$1(provider, prefix2) {
        const providerStorage = dataStorage$1[provider] || (dataStorage$1[provider] = /* @__PURE__ */ Object.create(null));
        return providerStorage[prefix2] || (providerStorage[prefix2] = newStorage$1(provider, prefix2));
      }
      function addIconSet$1(storage2, data) {
        if (!quicklyValidateIconSet$1(data)) {
          return [];
        }
        return parseIconSet$1(data, (name, icon) => {
          if (icon) {
            storage2.icons[name] = icon;
          } else {
            storage2.missing.add(name);
          }
        });
      }
      function addIconToStorage$1(storage2, name, icon) {
        try {
          if (typeof icon.body === "string") {
            storage2.icons[name] = { ...icon };
            return true;
          }
        } catch (err) {
        }
        return false;
      }
      let simpleNames$1 = false;
      function allowSimpleNames$1(allow) {
        if (typeof allow === "boolean") {
          simpleNames$1 = allow;
        }
        return simpleNames$1;
      }
      function getIconData$1(name) {
        const icon = typeof name === "string" ? stringToIcon$1(name, true, simpleNames$1) : name;
        if (icon) {
          const storage2 = getStorage$1(icon.provider, icon.prefix);
          const iconName = icon.name;
          return storage2.icons[iconName] || (storage2.missing.has(iconName) ? null : void 0);
        }
      }
      function addIcon$2(name, data) {
        const icon = stringToIcon$1(name, true, simpleNames$1);
        if (!icon) {
          return false;
        }
        const storage2 = getStorage$1(icon.provider, icon.prefix);
        if (data) {
          return addIconToStorage$1(storage2, icon.name, data);
        } else {
          storage2.missing.add(icon.name);
          return true;
        }
      }
      function addCollection$2(data, provider) {
        if (typeof data !== "object") {
          return false;
        }
        if (typeof provider !== "string") {
          provider = data.provider || "";
        }
        if (simpleNames$1 && !provider && !data.prefix) {
          let added = false;
          if (quicklyValidateIconSet$1(data)) {
            data.prefix = "";
            parseIconSet$1(data, (name, icon) => {
              if (addIcon$2(name, icon)) {
                added = true;
              }
            });
          }
          return added;
        }
        const prefix2 = data.prefix;
        if (!validateIconName$1({
          prefix: prefix2,
          name: "a"
        })) {
          return false;
        }
        const storage2 = getStorage$1(provider, prefix2);
        return !!addIconSet$1(storage2, data);
      }
      const defaultIconSizeCustomisations$1 = Object.freeze({
        width: null,
        height: null
      });
      const defaultIconCustomisations$1 = Object.freeze({
        // Dimensions
        ...defaultIconSizeCustomisations$1,
        // Transformations
        ...defaultIconTransformations$1
      });
      const unitsSplit$1 = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
      const unitsTest$1 = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
      function calculateSize$2(size, ratio, precision) {
        if (ratio === 1) {
          return size;
        }
        precision = precision || 100;
        if (typeof size === "number") {
          return Math.ceil(size * ratio * precision) / precision;
        }
        if (typeof size !== "string") {
          return size;
        }
        const oldParts = size.split(unitsSplit$1);
        if (oldParts === null || !oldParts.length) {
          return size;
        }
        const newParts = [];
        let code = oldParts.shift();
        let isNumber2 = unitsTest$1.test(code);
        while (true) {
          if (isNumber2) {
            const num = parseFloat(code);
            if (isNaN(num)) {
              newParts.push(code);
            } else {
              newParts.push(Math.ceil(num * ratio * precision) / precision);
            }
          } else {
            newParts.push(code);
          }
          code = oldParts.shift();
          if (code === void 0) {
            return newParts.join("");
          }
          isNumber2 = !isNumber2;
        }
      }
      function splitSVGDefs$1(content, tag = "defs") {
        let defs = "";
        const index = content.indexOf("<" + tag);
        while (index >= 0) {
          const start = content.indexOf(">", index);
          const end = content.indexOf("</" + tag);
          if (start === -1 || end === -1) {
            break;
          }
          const endEnd = content.indexOf(">", end);
          if (endEnd === -1) {
            break;
          }
          defs += content.slice(start + 1, end).trim();
          content = content.slice(0, index).trim() + content.slice(endEnd + 1);
        }
        return {
          defs,
          content
        };
      }
      function mergeDefsAndContent$1(defs, content) {
        return defs ? "<defs>" + defs + "</defs>" + content : content;
      }
      function wrapSVGContent$1(body, start, end) {
        const split = splitSVGDefs$1(body);
        return mergeDefsAndContent$1(split.defs, start + split.content + end);
      }
      const isUnsetKeyword$1 = (value) => value === "unset" || value === "undefined" || value === "none";
      function iconToSVG$1(icon, customisations) {
        const fullIcon = {
          ...defaultIconProps$1,
          ...icon
        };
        const fullCustomisations = {
          ...defaultIconCustomisations$1,
          ...customisations
        };
        const box = {
          left: fullIcon.left,
          top: fullIcon.top,
          width: fullIcon.width,
          height: fullIcon.height
        };
        let body = fullIcon.body;
        [fullIcon, fullCustomisations].forEach((props) => {
          const transformations = [];
          const hFlip = props.hFlip;
          const vFlip = props.vFlip;
          let rotation = props.rotate;
          if (hFlip) {
            if (vFlip) {
              rotation += 2;
            } else {
              transformations.push(
                "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
              );
              transformations.push("scale(-1 1)");
              box.top = box.left = 0;
            }
          } else if (vFlip) {
            transformations.push(
              "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
            );
            transformations.push("scale(1 -1)");
            box.top = box.left = 0;
          }
          let tempValue;
          if (rotation < 0) {
            rotation -= Math.floor(rotation / 4) * 4;
          }
          rotation = rotation % 4;
          switch (rotation) {
            case 1:
              tempValue = box.height / 2 + box.top;
              transformations.unshift(
                "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
              );
              break;
            case 2:
              transformations.unshift(
                "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
              );
              break;
            case 3:
              tempValue = box.width / 2 + box.left;
              transformations.unshift(
                "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
              );
              break;
          }
          if (rotation % 2 === 1) {
            if (box.left !== box.top) {
              tempValue = box.left;
              box.left = box.top;
              box.top = tempValue;
            }
            if (box.width !== box.height) {
              tempValue = box.width;
              box.width = box.height;
              box.height = tempValue;
            }
          }
          if (transformations.length) {
            body = wrapSVGContent$1(
              body,
              '<g transform="' + transformations.join(" ") + '">',
              "</g>"
            );
          }
        });
        const customisationsWidth = fullCustomisations.width;
        const customisationsHeight = fullCustomisations.height;
        const boxWidth = box.width;
        const boxHeight = box.height;
        let width;
        let height;
        if (customisationsWidth === null) {
          height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
          width = calculateSize$2(height, boxWidth / boxHeight);
        } else {
          width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
          height = customisationsHeight === null ? calculateSize$2(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
        }
        const attributes = {};
        const setAttr = (prop, value) => {
          if (!isUnsetKeyword$1(value)) {
            attributes[prop] = value.toString();
          }
        };
        setAttr("width", width);
        setAttr("height", height);
        const viewBox = [box.left, box.top, boxWidth, boxHeight];
        attributes.viewBox = viewBox.join(" ");
        return {
          attributes,
          viewBox,
          body
        };
      }
      const regex = /\sid="(\S+)"/g;
      const randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
      let counter = 0;
      function replaceIDs(body, prefix2 = randomPrefix) {
        const ids = [];
        let match2;
        while (match2 = regex.exec(body)) {
          ids.push(match2[1]);
        }
        if (!ids.length) {
          return body;
        }
        const suffix = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
        ids.forEach((id) => {
          const newID = typeof prefix2 === "function" ? prefix2(id) : prefix2 + (counter++).toString();
          const escapedID = id.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          body = body.replace(
            // Allowed characters before id: [#;"]
            // Allowed characters after id: [)"], .[a-z]
            new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"),
            "$1" + newID + suffix + "$3"
          );
        });
        body = body.replace(new RegExp(suffix, "g"), "");
        return body;
      }
      const storage$1 = /* @__PURE__ */ Object.create(null);
      function setAPIModule$1(provider, item) {
        storage$1[provider] = item;
      }
      function getAPIModule$1(provider) {
        return storage$1[provider] || storage$1[""];
      }
      function createAPIConfig$1(source) {
        let resources;
        if (typeof source.resources === "string") {
          resources = [source.resources];
        } else {
          resources = source.resources;
          if (!(resources instanceof Array) || !resources.length) {
            return null;
          }
        }
        const result2 = {
          // API hosts
          resources,
          // Root path
          path: source.path || "/",
          // URL length limit
          maxURL: source.maxURL || 500,
          // Timeout before next host is used.
          rotate: source.rotate || 750,
          // Timeout before failing query.
          timeout: source.timeout || 5e3,
          // Randomise default API end point.
          random: source.random === true,
          // Start index
          index: source.index || 0,
          // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
          dataAfterTimeout: source.dataAfterTimeout !== false
        };
        return result2;
      }
      const configStorage$1 = /* @__PURE__ */ Object.create(null);
      const fallBackAPISources$1 = [
        "https://api.simplesvg.com",
        "https://api.unisvg.com"
      ];
      const fallBackAPI$1 = [];
      while (fallBackAPISources$1.length > 0) {
        if (fallBackAPISources$1.length === 1) {
          fallBackAPI$1.push(fallBackAPISources$1.shift());
        } else {
          if (Math.random() > 0.5) {
            fallBackAPI$1.push(fallBackAPISources$1.shift());
          } else {
            fallBackAPI$1.push(fallBackAPISources$1.pop());
          }
        }
      }
      configStorage$1[""] = createAPIConfig$1({
        resources: ["https://api.iconify.design"].concat(fallBackAPI$1)
      });
      function addAPIProvider$2(provider, customConfig) {
        const config = createAPIConfig$1(customConfig);
        if (config === null) {
          return false;
        }
        configStorage$1[provider] = config;
        return true;
      }
      function getAPIConfig$1(provider) {
        return configStorage$1[provider];
      }
      const detectFetch$1 = () => {
        let callback;
        try {
          callback = fetch;
          if (typeof callback === "function") {
            return callback;
          }
        } catch (err) {
        }
      };
      let fetchModule$1 = detectFetch$1();
      function calculateMaxLength$1(provider, prefix2) {
        const config = getAPIConfig$1(provider);
        if (!config) {
          return 0;
        }
        let result2;
        if (!config.maxURL) {
          result2 = 0;
        } else {
          let maxHostLength = 0;
          config.resources.forEach((item) => {
            const host = item;
            maxHostLength = Math.max(maxHostLength, host.length);
          });
          const url = prefix2 + ".json?icons=";
          result2 = config.maxURL - maxHostLength - config.path.length - url.length;
        }
        return result2;
      }
      function shouldAbort$1(status) {
        return status === 404;
      }
      const prepare$1 = (provider, prefix2, icons) => {
        const results = [];
        const maxLength = calculateMaxLength$1(provider, prefix2);
        const type = "icons";
        let item = {
          type,
          provider,
          prefix: prefix2,
          icons: []
        };
        let length = 0;
        icons.forEach((name, index) => {
          length += name.length + 1;
          if (length >= maxLength && index > 0) {
            results.push(item);
            item = {
              type,
              provider,
              prefix: prefix2,
              icons: []
            };
            length = name.length;
          }
          item.icons.push(name);
        });
        results.push(item);
        return results;
      };
      function getPath$1(provider) {
        if (typeof provider === "string") {
          const config = getAPIConfig$1(provider);
          if (config) {
            return config.path;
          }
        }
        return "/";
      }
      const send$1 = (host, params, callback) => {
        if (!fetchModule$1) {
          callback("abort", 424);
          return;
        }
        let path = getPath$1(params.provider);
        switch (params.type) {
          case "icons": {
            const prefix2 = params.prefix;
            const icons = params.icons;
            const iconsList = icons.join(",");
            const urlParams = new URLSearchParams({
              icons: iconsList
            });
            path += prefix2 + ".json?" + urlParams.toString();
            break;
          }
          case "custom": {
            const uri = params.uri;
            path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
            break;
          }
          default:
            callback("abort", 400);
            return;
        }
        let defaultError = 503;
        fetchModule$1(host + path).then((response) => {
          const status = response.status;
          if (status !== 200) {
            setTimeout(() => {
              callback(shouldAbort$1(status) ? "abort" : "next", status);
            });
            return;
          }
          defaultError = 501;
          return response.json();
        }).then((data) => {
          if (typeof data !== "object" || data === null) {
            setTimeout(() => {
              if (data === 404) {
                callback("abort", data);
              } else {
                callback("next", defaultError);
              }
            });
            return;
          }
          setTimeout(() => {
            callback("success", data);
          });
        }).catch(() => {
          callback("next", defaultError);
        });
      };
      const fetchAPIModule$1 = {
        prepare: prepare$1,
        send: send$1
      };
      function sortIcons$1(icons) {
        const result2 = {
          loaded: [],
          missing: [],
          pending: []
        };
        const storage2 = /* @__PURE__ */ Object.create(null);
        icons.sort((a, b) => {
          if (a.provider !== b.provider) {
            return a.provider.localeCompare(b.provider);
          }
          if (a.prefix !== b.prefix) {
            return a.prefix.localeCompare(b.prefix);
          }
          return a.name.localeCompare(b.name);
        });
        let lastIcon = {
          provider: "",
          prefix: "",
          name: ""
        };
        icons.forEach((icon) => {
          if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
            return;
          }
          lastIcon = icon;
          const provider = icon.provider;
          const prefix2 = icon.prefix;
          const name = icon.name;
          const providerStorage = storage2[provider] || (storage2[provider] = /* @__PURE__ */ Object.create(null));
          const localStorage = providerStorage[prefix2] || (providerStorage[prefix2] = getStorage$1(provider, prefix2));
          let list;
          if (name in localStorage.icons) {
            list = result2.loaded;
          } else if (prefix2 === "" || localStorage.missing.has(name)) {
            list = result2.missing;
          } else {
            list = result2.pending;
          }
          const item = {
            provider,
            prefix: prefix2,
            name
          };
          list.push(item);
        });
        return result2;
      }
      function removeCallback$1(storages, id) {
        storages.forEach((storage2) => {
          const items = storage2.loaderCallbacks;
          if (items) {
            storage2.loaderCallbacks = items.filter((row) => row.id !== id);
          }
        });
      }
      function updateCallbacks$1(storage2) {
        if (!storage2.pendingCallbacksFlag) {
          storage2.pendingCallbacksFlag = true;
          setTimeout(() => {
            storage2.pendingCallbacksFlag = false;
            const items = storage2.loaderCallbacks ? storage2.loaderCallbacks.slice(0) : [];
            if (!items.length) {
              return;
            }
            let hasPending = false;
            const provider = storage2.provider;
            const prefix2 = storage2.prefix;
            items.forEach((item) => {
              const icons = item.icons;
              const oldLength = icons.pending.length;
              icons.pending = icons.pending.filter((icon) => {
                if (icon.prefix !== prefix2) {
                  return true;
                }
                const name = icon.name;
                if (storage2.icons[name]) {
                  icons.loaded.push({
                    provider,
                    prefix: prefix2,
                    name
                  });
                } else if (storage2.missing.has(name)) {
                  icons.missing.push({
                    provider,
                    prefix: prefix2,
                    name
                  });
                } else {
                  hasPending = true;
                  return true;
                }
                return false;
              });
              if (icons.pending.length !== oldLength) {
                if (!hasPending) {
                  removeCallback$1([storage2], item.id);
                }
                item.callback(
                  icons.loaded.slice(0),
                  icons.missing.slice(0),
                  icons.pending.slice(0),
                  item.abort
                );
              }
            });
          });
        }
      }
      let idCounter$1 = 0;
      function storeCallback$1(callback, icons, pendingSources) {
        const id = idCounter$1++;
        const abort = removeCallback$1.bind(null, pendingSources, id);
        if (!icons.pending.length) {
          return abort;
        }
        const item = {
          id,
          icons,
          callback,
          abort
        };
        pendingSources.forEach((storage2) => {
          (storage2.loaderCallbacks || (storage2.loaderCallbacks = [])).push(item);
        });
        return abort;
      }
      function listToIcons$1(list, validate = true, simpleNames2 = false) {
        const result2 = [];
        list.forEach((item) => {
          const icon = typeof item === "string" ? stringToIcon$1(item, validate, simpleNames2) : item;
          if (icon) {
            result2.push(icon);
          }
        });
        return result2;
      }
      var defaultConfig$1 = {
        resources: [],
        index: 0,
        timeout: 2e3,
        rotate: 750,
        random: false,
        dataAfterTimeout: false
      };
      function sendQuery$1(config, payload, query, done) {
        const resourcesCount = config.resources.length;
        const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;
        let resources;
        if (config.random) {
          let list = config.resources.slice(0);
          resources = [];
          while (list.length > 1) {
            const nextIndex = Math.floor(Math.random() * list.length);
            resources.push(list[nextIndex]);
            list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
          }
          resources = resources.concat(list);
        } else {
          resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));
        }
        const startTime = Date.now();
        let status = "pending";
        let queriesSent = 0;
        let lastError;
        let timer = null;
        let queue = [];
        let doneCallbacks = [];
        if (typeof done === "function") {
          doneCallbacks.push(done);
        }
        function resetTimer() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function abort() {
          if (status === "pending") {
            status = "aborted";
          }
          resetTimer();
          queue.forEach((item) => {
            if (item.status === "pending") {
              item.status = "aborted";
            }
          });
          queue = [];
        }
        function subscribe(callback, overwrite) {
          if (overwrite) {
            doneCallbacks = [];
          }
          if (typeof callback === "function") {
            doneCallbacks.push(callback);
          }
        }
        function getQueryStatus() {
          return {
            startTime,
            payload,
            status,
            queriesSent,
            queriesPending: queue.length,
            subscribe,
            abort
          };
        }
        function failQuery() {
          status = "failed";
          doneCallbacks.forEach((callback) => {
            callback(void 0, lastError);
          });
        }
        function clearQueue() {
          queue.forEach((item) => {
            if (item.status === "pending") {
              item.status = "aborted";
            }
          });
          queue = [];
        }
        function moduleResponse(item, response, data) {
          const isError = response !== "success";
          queue = queue.filter((queued) => queued !== item);
          switch (status) {
            case "pending":
              break;
            case "failed":
              if (isError || !config.dataAfterTimeout) {
                return;
              }
              break;
            default:
              return;
          }
          if (response === "abort") {
            lastError = data;
            failQuery();
            return;
          }
          if (isError) {
            lastError = data;
            if (!queue.length) {
              if (!resources.length) {
                failQuery();
              } else {
                execNext();
              }
            }
            return;
          }
          resetTimer();
          clearQueue();
          if (!config.random) {
            const index = config.resources.indexOf(item.resource);
            if (index !== -1 && index !== config.index) {
              config.index = index;
            }
          }
          status = "completed";
          doneCallbacks.forEach((callback) => {
            callback(data);
          });
        }
        function execNext() {
          if (status !== "pending") {
            return;
          }
          resetTimer();
          const resource = resources.shift();
          if (resource === void 0) {
            if (queue.length) {
              timer = setTimeout(() => {
                resetTimer();
                if (status === "pending") {
                  clearQueue();
                  failQuery();
                }
              }, config.timeout);
              return;
            }
            failQuery();
            return;
          }
          const item = {
            status: "pending",
            resource,
            callback: (status2, data) => {
              moduleResponse(item, status2, data);
            }
          };
          queue.push(item);
          queriesSent++;
          timer = setTimeout(execNext, config.rotate);
          query(resource, payload, item.callback);
        }
        setTimeout(execNext);
        return getQueryStatus;
      }
      function initRedundancy$1(cfg) {
        const config = {
          ...defaultConfig$1,
          ...cfg
        };
        let queries = [];
        function cleanup() {
          queries = queries.filter((item) => item().status === "pending");
        }
        function query(payload, queryCallback, doneCallback) {
          const query2 = sendQuery$1(
            config,
            payload,
            queryCallback,
            (data, error) => {
              cleanup();
              if (doneCallback) {
                doneCallback(data, error);
              }
            }
          );
          queries.push(query2);
          return query2;
        }
        function find(callback) {
          return queries.find((value) => {
            return callback(value);
          }) || null;
        }
        const instance = {
          query,
          find,
          setIndex: (index) => {
            config.index = index;
          },
          getIndex: () => config.index,
          cleanup
        };
        return instance;
      }
      function emptyCallback$1$1() {
      }
      const redundancyCache$1 = /* @__PURE__ */ Object.create(null);
      function getRedundancyCache$1(provider) {
        if (!redundancyCache$1[provider]) {
          const config = getAPIConfig$1(provider);
          if (!config) {
            return;
          }
          const redundancy = initRedundancy$1(config);
          const cachedReundancy = {
            config,
            redundancy
          };
          redundancyCache$1[provider] = cachedReundancy;
        }
        return redundancyCache$1[provider];
      }
      function sendAPIQuery$1(target, query, callback) {
        let redundancy;
        let send2;
        if (typeof target === "string") {
          const api = getAPIModule$1(target);
          if (!api) {
            callback(void 0, 424);
            return emptyCallback$1$1;
          }
          send2 = api.send;
          const cached = getRedundancyCache$1(target);
          if (cached) {
            redundancy = cached.redundancy;
          }
        } else {
          const config = createAPIConfig$1(target);
          if (config) {
            redundancy = initRedundancy$1(config);
            const moduleKey = target.resources ? target.resources[0] : "";
            const api = getAPIModule$1(moduleKey);
            if (api) {
              send2 = api.send;
            }
          }
        }
        if (!redundancy || !send2) {
          callback(void 0, 424);
          return emptyCallback$1$1;
        }
        return redundancy.query(query, send2, callback)().abort;
      }
      function emptyCallback$2() {
      }
      function loadedNewIcons$1(storage2) {
        if (!storage2.iconsLoaderFlag) {
          storage2.iconsLoaderFlag = true;
          setTimeout(() => {
            storage2.iconsLoaderFlag = false;
            updateCallbacks$1(storage2);
          });
        }
      }
      function checkIconNamesForAPI$1(icons) {
        const valid = [];
        const invalid = [];
        icons.forEach((name) => {
          (name.match(matchIconName$1) ? valid : invalid).push(name);
        });
        return {
          valid,
          invalid
        };
      }
      function parseLoaderResponse$1(storage2, icons, data) {
        function checkMissing() {
          const pending = storage2.pendingIcons;
          icons.forEach((name) => {
            if (pending) {
              pending.delete(name);
            }
            if (!storage2.icons[name]) {
              storage2.missing.add(name);
            }
          });
        }
        if (data && typeof data === "object") {
          try {
            const parsed = addIconSet$1(storage2, data);
            if (!parsed.length) {
              checkMissing();
              return;
            }
          } catch (err) {
            console.error(err);
          }
        }
        checkMissing();
        loadedNewIcons$1(storage2);
      }
      function parsePossiblyAsyncResponse$1(response, callback) {
        if (response instanceof Promise) {
          response.then((data) => {
            callback(data);
          }).catch(() => {
            callback(null);
          });
        } else {
          callback(response);
        }
      }
      function loadNewIcons$1(storage2, icons) {
        if (!storage2.iconsToLoad) {
          storage2.iconsToLoad = icons;
        } else {
          storage2.iconsToLoad = storage2.iconsToLoad.concat(icons).sort();
        }
        if (!storage2.iconsQueueFlag) {
          storage2.iconsQueueFlag = true;
          setTimeout(() => {
            storage2.iconsQueueFlag = false;
            const { provider, prefix: prefix2 } = storage2;
            const icons2 = storage2.iconsToLoad;
            delete storage2.iconsToLoad;
            if (!icons2 || !icons2.length) {
              return;
            }
            const customIconLoader = storage2.loadIcon;
            if (storage2.loadIcons && (icons2.length > 1 || !customIconLoader)) {
              parsePossiblyAsyncResponse$1(
                storage2.loadIcons(icons2, prefix2, provider),
                (data) => {
                  parseLoaderResponse$1(storage2, icons2, data);
                }
              );
              return;
            }
            if (customIconLoader) {
              icons2.forEach((name) => {
                const response = customIconLoader(name, prefix2, provider);
                parsePossiblyAsyncResponse$1(response, (data) => {
                  const iconSet = data ? {
                    prefix: prefix2,
                    icons: {
                      [name]: data
                    }
                  } : null;
                  parseLoaderResponse$1(storage2, [name], iconSet);
                });
              });
              return;
            }
            const { valid, invalid } = checkIconNamesForAPI$1(icons2);
            if (invalid.length) {
              parseLoaderResponse$1(storage2, invalid, null);
            }
            if (!valid.length) {
              return;
            }
            const api = prefix2.match(matchIconName$1) ? getAPIModule$1(provider) : null;
            if (!api) {
              parseLoaderResponse$1(storage2, valid, null);
              return;
            }
            const params = api.prepare(provider, prefix2, valid);
            params.forEach((item) => {
              sendAPIQuery$1(provider, item, (data) => {
                parseLoaderResponse$1(storage2, item.icons, data);
              });
            });
          });
        }
      }
      const loadIcons$2 = (icons, callback) => {
        const cleanedIcons = listToIcons$1(icons, true, allowSimpleNames$1());
        const sortedIcons = sortIcons$1(cleanedIcons);
        if (!sortedIcons.pending.length) {
          let callCallback = true;
          if (callback) {
            setTimeout(() => {
              if (callCallback) {
                callback(
                  sortedIcons.loaded,
                  sortedIcons.missing,
                  sortedIcons.pending,
                  emptyCallback$2
                );
              }
            });
          }
          return () => {
            callCallback = false;
          };
        }
        const newIcons = /* @__PURE__ */ Object.create(null);
        const sources = [];
        let lastProvider, lastPrefix;
        sortedIcons.pending.forEach((icon) => {
          const { provider, prefix: prefix2 } = icon;
          if (prefix2 === lastPrefix && provider === lastProvider) {
            return;
          }
          lastProvider = provider;
          lastPrefix = prefix2;
          sources.push(getStorage$1(provider, prefix2));
          const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));
          if (!providerNewIcons[prefix2]) {
            providerNewIcons[prefix2] = [];
          }
        });
        sortedIcons.pending.forEach((icon) => {
          const { provider, prefix: prefix2, name } = icon;
          const storage2 = getStorage$1(provider, prefix2);
          const pendingQueue = storage2.pendingIcons || (storage2.pendingIcons = /* @__PURE__ */ new Set());
          if (!pendingQueue.has(name)) {
            pendingQueue.add(name);
            newIcons[provider][prefix2].push(name);
          }
        });
        sources.forEach((storage2) => {
          const list = newIcons[storage2.provider][storage2.prefix];
          if (list.length) {
            loadNewIcons$1(storage2, list);
          }
        });
        return callback ? storeCallback$1(callback, sortedIcons, sources) : emptyCallback$2;
      };
      function mergeCustomisations(defaults, item) {
        const result2 = {
          ...defaults
        };
        for (const key in item) {
          const value = item[key];
          const valueType = typeof value;
          if (key in defaultIconSizeCustomisations$1) {
            if (value === null || value && (valueType === "string" || valueType === "number")) {
              result2[key] = value;
            }
          } else if (valueType === typeof result2[key]) {
            result2[key] = key === "rotate" ? value % 4 : value;
          }
        }
        return result2;
      }
      const separator$1 = /[\s,]+/;
      function flipFromString$1(custom, flip) {
        flip.split(separator$1).forEach((str) => {
          const value = str.trim();
          switch (value) {
            case "horizontal":
              custom.hFlip = true;
              break;
            case "vertical":
              custom.vFlip = true;
              break;
          }
        });
      }
      function rotateFromString$1(value, defaultValue = 0) {
        const units = value.replace(/^-?[0-9.]*/, "");
        function cleanup(value2) {
          while (value2 < 0) {
            value2 += 4;
          }
          return value2 % 4;
        }
        if (units === "") {
          const num = parseInt(value);
          return isNaN(num) ? 0 : cleanup(num);
        } else if (units !== value) {
          let split = 0;
          switch (units) {
            case "%":
              split = 25;
              break;
            case "deg":
              split = 90;
          }
          if (split) {
            let num = parseFloat(value.slice(0, value.length - units.length));
            if (isNaN(num)) {
              return 0;
            }
            num = num / split;
            return num % 1 === 0 ? cleanup(num) : 0;
          }
        }
        return defaultValue;
      }
      function iconToHTML$2(body, attributes) {
        let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
        for (const attr in attributes) {
          renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
        }
        return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
      }
      function encodeSVGforURL$1(svg) {
        return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
      }
      function svgToData$1(svg) {
        return "data:image/svg+xml," + encodeSVGforURL$1(svg);
      }
      function svgToURL$2(svg) {
        return 'url("' + svgToData$1(svg) + '")';
      }
      const defaultExtendedIconCustomisations = {
        ...defaultIconCustomisations$1,
        inline: false
      };
      const svgDefaults = {
        "xmlns": "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        "aria-hidden": true,
        "role": "img"
      };
      const commonProps = {
        display: "inline-block"
      };
      const monotoneProps$1 = {
        backgroundColor: "currentColor"
      };
      const coloredProps$1 = {
        backgroundColor: "transparent"
      };
      const propsToAdd$1 = {
        Image: "var(--svg)",
        Repeat: "no-repeat",
        Size: "100% 100%"
      };
      const propsToAddTo$1 = {
        webkitMask: monotoneProps$1,
        mask: monotoneProps$1,
        background: coloredProps$1
      };
      for (const prefix2 in propsToAddTo$1) {
        const list = propsToAddTo$1[prefix2];
        for (const prop in propsToAdd$1) {
          list[prefix2 + prop] = propsToAdd$1[prop];
        }
      }
      const customisationAliases = {};
      ["horizontal", "vertical"].forEach((prefix2) => {
        const attr = prefix2.slice(0, 1) + "Flip";
        customisationAliases[prefix2 + "-flip"] = attr;
        customisationAliases[prefix2.slice(0, 1) + "-flip"] = attr;
        customisationAliases[prefix2 + "Flip"] = attr;
      });
      function fixSize$1(value) {
        return value + (value.match(/^[-0-9.]+$/) ? "px" : "");
      }
      const render = (icon, props) => {
        const customisations = mergeCustomisations(defaultExtendedIconCustomisations, props);
        const componentProps = { ...svgDefaults };
        const mode = props.mode || "svg";
        const style = {};
        const propsStyle = props.style;
        const customStyle2 = typeof propsStyle === "object" && !(propsStyle instanceof Array) ? propsStyle : {};
        for (let key in props) {
          const value = props[key];
          if (value === void 0) {
            continue;
          }
          switch (key) {
            // Properties to ignore
            case "icon":
            case "style":
            case "onLoad":
            case "mode":
            case "ssr":
              break;
            // Boolean attributes
            case "inline":
            case "hFlip":
            case "vFlip":
              customisations[key] = value === true || value === "true" || value === 1;
              break;
            // Flip as string: 'horizontal,vertical'
            case "flip":
              if (typeof value === "string") {
                flipFromString$1(customisations, value);
              }
              break;
            // Color: override style
            case "color":
              style.color = value;
              break;
            // Rotation as string
            case "rotate":
              if (typeof value === "string") {
                customisations[key] = rotateFromString$1(value);
              } else if (typeof value === "number") {
                customisations[key] = value;
              }
              break;
            // Remove aria-hidden
            case "ariaHidden":
            case "aria-hidden":
              if (value !== true && value !== "true") {
                delete componentProps["aria-hidden"];
              }
              break;
            default: {
              const alias = customisationAliases[key];
              if (alias) {
                if (value === true || value === "true" || value === 1) {
                  customisations[alias] = true;
                }
              } else if (defaultExtendedIconCustomisations[key] === void 0) {
                componentProps[key] = value;
              }
            }
          }
        }
        const item = iconToSVG$1(icon, customisations);
        const renderAttribs = item.attributes;
        if (customisations.inline) {
          style.verticalAlign = "-0.125em";
        }
        if (mode === "svg") {
          componentProps.style = {
            ...style,
            ...customStyle2
          };
          Object.assign(componentProps, renderAttribs);
          let localCounter = 0;
          let id = props.id;
          if (typeof id === "string") {
            id = id.replace(/-/g, "_");
          }
          componentProps["innerHTML"] = replaceIDs(item.body, id ? () => id + "ID" + localCounter++ : "iconifyVue");
          return h("svg", componentProps);
        }
        const { body, width, height } = icon;
        const useMask = mode === "mask" || (mode === "bg" ? false : body.indexOf("currentColor") !== -1);
        const html = iconToHTML$2(body, {
          ...renderAttribs,
          width: width + "",
          height: height + ""
        });
        componentProps.style = {
          ...style,
          "--svg": svgToURL$2(html),
          "width": fixSize$1(renderAttribs.width),
          "height": fixSize$1(renderAttribs.height),
          ...commonProps,
          ...useMask ? monotoneProps$1 : coloredProps$1,
          ...customStyle2
        };
        return h("span", componentProps);
      };
      allowSimpleNames$1(true);
      setAPIModule$1("", fetchAPIModule$1);
      if (typeof document !== "undefined" && typeof window !== "undefined") {
        const _window = window;
        if (_window.IconifyPreload !== void 0) {
          const preload2 = _window.IconifyPreload;
          const err = "Invalid IconifyPreload syntax.";
          if (typeof preload2 === "object" && preload2 !== null) {
            (preload2 instanceof Array ? preload2 : [preload2]).forEach((item) => {
              try {
                if (
                  // Check if item is an object and not null/array
                  typeof item !== "object" || item === null || item instanceof Array || // Check for 'icons' and 'prefix'
                  typeof item.icons !== "object" || typeof item.prefix !== "string" || // Add icon set
                  !addCollection$2(item)
                ) {
                  console.error(err);
                }
              } catch (e) {
                console.error(err);
              }
            });
          }
        }
        if (_window.IconifyProviders !== void 0) {
          const providers = _window.IconifyProviders;
          if (typeof providers === "object" && providers !== null) {
            for (let key in providers) {
              const err = "IconifyProviders[" + key + "] is invalid.";
              try {
                const value = providers[key];
                if (typeof value !== "object" || !value || value.resources === void 0) {
                  continue;
                }
                if (!addAPIProvider$2(key, value)) {
                  console.error(err);
                }
              } catch (e) {
                console.error(err);
              }
            }
          }
        }
      }
      const emptyIcon = {
        ...defaultIconProps$1,
        body: ""
      };
      const Icon = exports("I", defineComponent((props, { emit }) => {
        const loader = ref(null);
        function abortLoading() {
          var _a, _b;
          if (loader.value) {
            (_b = (_a = loader.value).abort) == null ? void 0 : _b.call(_a);
            loader.value = null;
          }
        }
        const rendering = ref(!!props.ssr);
        const lastRenderedIconName = ref("");
        const iconData = shallowRef(null);
        function getIcon2() {
          const icon = props.icon;
          if (typeof icon === "object" && icon !== null && typeof icon.body === "string") {
            lastRenderedIconName.value = "";
            return {
              data: icon
            };
          }
          let iconName;
          if (typeof icon !== "string" || (iconName = stringToIcon$1(icon, false, true)) === null) {
            return null;
          }
          let data = getIconData$1(iconName);
          if (!data) {
            const oldState = loader.value;
            if (!oldState || oldState.name !== icon) {
              if (data === null) {
                loader.value = {
                  name: icon
                };
              } else {
                loader.value = {
                  name: icon,
                  abort: loadIcons$2([iconName], updateIconData)
                };
              }
            }
            return null;
          }
          abortLoading();
          if (lastRenderedIconName.value !== icon) {
            lastRenderedIconName.value = icon;
            nextTick(() => {
              emit("load", icon);
            });
          }
          const customise = props.customise;
          if (customise) {
            data = Object.assign({}, data);
            const customised = customise(data.body, iconName.name, iconName.prefix, iconName.provider);
            if (typeof customised === "string") {
              data.body = customised;
            }
          }
          const classes = ["iconify"];
          if (iconName.prefix !== "") {
            classes.push("iconify--" + iconName.prefix);
          }
          if (iconName.provider !== "") {
            classes.push("iconify--" + iconName.provider);
          }
          return { data, classes };
        }
        function updateIconData() {
          var _a;
          const icon = getIcon2();
          if (!icon) {
            iconData.value = null;
          } else if (icon.data !== ((_a = iconData.value) == null ? void 0 : _a.data)) {
            iconData.value = icon;
          }
        }
        if (rendering.value) {
          updateIconData();
        } else {
          onMounted(() => {
            rendering.value = true;
            updateIconData();
          });
        }
        watch(() => props.icon, updateIconData);
        onUnmounted(abortLoading);
        return () => {
          const icon = iconData.value;
          if (!icon) {
            return render(emptyIcon, props);
          }
          let newProps = props;
          if (icon.classes) {
            newProps = {
              ...props,
              class: icon.classes.join(" ")
            };
          }
          return render({
            ...defaultIconProps$1,
            ...icon.data
          }, newProps);
        };
      }, {
        props: [
          // Icon and render mode
          "icon",
          "mode",
          "ssr",
          // Layout and style
          "width",
          "height",
          "style",
          "color",
          "inline",
          // Transformations
          "rotate",
          "hFlip",
          "horizontalFlip",
          "vFlip",
          "verticalFlip",
          "flip",
          // Misc
          "id",
          "ariaHidden",
          "customise",
          "title"
        ],
        emits: ["load"]
      }));
      function tryOnScopeDispose(fn) {
        if (getCurrentScope()) {
          onScopeDispose(fn);
          return true;
        }
        return false;
      }
      function toReactive(objectRef) {
        if (!isRef(objectRef))
          return reactive(objectRef);
        const proxy = new Proxy({}, {
          get(_, p, receiver) {
            return unref(Reflect.get(objectRef.value, p, receiver));
          },
          set(_, p, value) {
            if (isRef(objectRef.value[p]) && !isRef(value))
              objectRef.value[p].value = value;
            else
              objectRef.value[p] = value;
            return true;
          },
          deleteProperty(_, p) {
            return Reflect.deleteProperty(objectRef.value, p);
          },
          has(_, p) {
            return Reflect.has(objectRef.value, p);
          },
          ownKeys() {
            return Object.keys(objectRef.value);
          },
          getOwnPropertyDescriptor() {
            return {
              enumerable: true,
              configurable: true
            };
          }
        });
        return reactive(proxy);
      }
      const isClient = typeof window !== "undefined" && typeof document !== "undefined";
      typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
      const isDef = (val) => typeof val !== "undefined";
      const notNullish = (val) => val != null;
      const toString = Object.prototype.toString;
      const isObject = (val) => toString.call(val) === "[object Object]";
      const noop = () => {
      };
      const isIOS = /* @__PURE__ */ getIsIOS();
      function getIsIOS() {
        var _a, _b;
        return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
      }
      function createFilterWrapper(filter, fn) {
        function wrapper(...args) {
          return new Promise((resolve, reject) => {
            Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
          });
        }
        return wrapper;
      }
      const bypassFilter = (invoke) => {
        return invoke();
      };
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop;
        };
        let lastInvoker;
        const filter = (invoke) => {
          const duration = toValue(ms);
          const maxDuration = toValue(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke());
          }
          return new Promise((resolve, reject) => {
            lastRejector = options.rejectOnCancel ? reject : resolve;
            lastInvoker = invoke;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve(lastInvoker());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve(invoke());
            }, duration);
          });
        };
        return filter;
      }
      function throttleFilter(...args) {
        let lastExec = 0;
        let timer;
        let isLeading = true;
        let lastRejector = noop;
        let lastValue;
        let ms;
        let trailing;
        let leading;
        let rejectOnCancel;
        if (!isRef(args[0]) && typeof args[0] === "object")
          ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);
        else
          [ms, trailing = true, leading = true, rejectOnCancel = false] = args;
        const clear = () => {
          if (timer) {
            clearTimeout(timer);
            timer = void 0;
            lastRejector();
            lastRejector = noop;
          }
        };
        const filter = (_invoke) => {
          const duration = toValue(ms);
          const elapsed = Date.now() - lastExec;
          const invoke = () => {
            return lastValue = _invoke();
          };
          clear();
          if (duration <= 0) {
            lastExec = Date.now();
            return invoke();
          }
          if (elapsed > duration && (leading || !isLeading)) {
            lastExec = Date.now();
            invoke();
          } else if (trailing) {
            lastValue = new Promise((resolve, reject) => {
              lastRejector = rejectOnCancel ? reject : resolve;
              timer = setTimeout(() => {
                lastExec = Date.now();
                isLeading = true;
                resolve(invoke());
                clear();
              }, Math.max(0, duration - elapsed));
            });
          }
          if (!leading && !timer)
            timer = setTimeout(() => isLeading = true, duration);
          isLeading = false;
          return lastValue;
        };
        return filter;
      }
      function pausableFilter(extendFilter = bypassFilter, options = {}) {
        const {
          initialState = "active"
        } = options;
        const isActive = toRef(initialState === "active");
        function pause() {
          isActive.value = false;
        }
        function resume() {
          isActive.value = true;
        }
        const eventFilter = (...args) => {
          if (isActive.value)
            extendFilter(...args);
        };
        return { isActive: readonly(isActive), pause, resume, eventFilter };
      }
      function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
        return new Promise((resolve, reject) => {
          if (throwOnTimeout)
            setTimeout(() => reject(reason), ms);
          else
            setTimeout(resolve, ms);
        });
      }
      function createSingletonPromise(fn) {
        let _promise;
        function wrapper() {
          if (!_promise)
            _promise = fn();
          return _promise;
        }
        wrapper.reset = async () => {
          const _prev = _promise;
          _promise = void 0;
          if (_prev)
            await _prev;
        };
        return wrapper;
      }
      function getLifeCycleTarget(target) {
        return getCurrentInstance();
      }
      function toArray(value) {
        return Array.isArray(value) ? value : [value];
      }
      function toRef(...args) {
        if (args.length !== 1)
          return toRef$1(...args);
        const r = args[0];
        return typeof r === "function" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);
      }
      function useDebounceFn(fn, ms = 200, options = {}) {
        return createFilterWrapper(
          debounceFilter(ms, options),
          fn
        );
      }
      function useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
        return createFilterWrapper(
          throttleFilter(ms, trailing, leading, rejectOnCancel),
          fn
        );
      }
      function watchWithFilter(source, cb, options = {}) {
        const {
          eventFilter = bypassFilter,
          ...watchOptions
        } = options;
        return watch(
          source,
          createFilterWrapper(
            eventFilter,
            cb
          ),
          watchOptions
        );
      }
      function watchPausable(source, cb, options = {}) {
        const {
          eventFilter: filter,
          initialState = "active",
          ...watchOptions
        } = options;
        const { eventFilter, pause, resume, isActive } = pausableFilter(filter, { initialState });
        const stop = watchWithFilter(
          source,
          cb,
          {
            ...watchOptions,
            eventFilter
          }
        );
        return { stop, pause, resume, isActive };
      }
      function syncRef(left, right, ...[options]) {
        const {
          flush = "sync",
          deep = false,
          immediate = true,
          direction = "both",
          transform = {}
        } = options || {};
        const watchers = [];
        const transformLTR = "ltr" in transform && transform.ltr || ((v) => v);
        const transformRTL = "rtl" in transform && transform.rtl || ((v) => v);
        if (direction === "both" || direction === "ltr") {
          watchers.push(watchPausable(
            left,
            (newValue) => {
              watchers.forEach((w) => w.pause());
              right.value = transformLTR(newValue);
              watchers.forEach((w) => w.resume());
            },
            { flush, deep, immediate }
          ));
        }
        if (direction === "both" || direction === "rtl") {
          watchers.push(watchPausable(
            right,
            (newValue) => {
              watchers.forEach((w) => w.pause());
              left.value = transformRTL(newValue);
              watchers.forEach((w) => w.resume());
            },
            { flush, deep, immediate }
          ));
        }
        const stop = () => {
          watchers.forEach((w) => w.stop());
        };
        return stop;
      }
      function tryOnMounted(fn, sync = true, target) {
        const instance = getLifeCycleTarget();
        if (instance)
          onMounted(fn, target);
        else if (sync)
          fn();
        else
          nextTick(fn);
      }
      function tryOnUnmounted(fn, target) {
        const instance = getLifeCycleTarget();
        if (instance)
          onUnmounted(fn, target);
      }
      function createUntil(r, isNot = false) {
        function toMatch(condition, { flush = "sync", deep = false, timeout, throwOnTimeout } = {}) {
          let stop = null;
          const watcher = new Promise((resolve) => {
            stop = watch(
              r,
              (v) => {
                if (condition(v) !== isNot) {
                  if (stop)
                    stop();
                  else
                    nextTick(() => stop == null ? void 0 : stop());
                  resolve(v);
                }
              },
              {
                flush,
                deep,
                immediate: true
              }
            );
          });
          const promises = [watcher];
          if (timeout != null) {
            promises.push(
              promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop == null ? void 0 : stop())
            );
          }
          return Promise.race(promises);
        }
        function toBe(value, options) {
          if (!isRef(value))
            return toMatch((v) => v === value, options);
          const { flush = "sync", deep = false, timeout, throwOnTimeout } = options != null ? options : {};
          let stop = null;
          const watcher = new Promise((resolve) => {
            stop = watch(
              [r, value],
              ([v1, v2]) => {
                if (isNot !== (v1 === v2)) {
                  if (stop)
                    stop();
                  else
                    nextTick(() => stop == null ? void 0 : stop());
                  resolve(v1);
                }
              },
              {
                flush,
                deep,
                immediate: true
              }
            );
          });
          const promises = [watcher];
          if (timeout != null) {
            promises.push(
              promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {
                stop == null ? void 0 : stop();
                return toValue(r);
              })
            );
          }
          return Promise.race(promises);
        }
        function toBeTruthy(options) {
          return toMatch((v) => Boolean(v), options);
        }
        function toBeNull(options) {
          return toBe(null, options);
        }
        function toBeUndefined(options) {
          return toBe(void 0, options);
        }
        function toBeNaN(options) {
          return toMatch(Number.isNaN, options);
        }
        function toContains(value, options) {
          return toMatch((v) => {
            const array = Array.from(v);
            return array.includes(value) || array.includes(toValue(value));
          }, options);
        }
        function changed(options) {
          return changedTimes(1, options);
        }
        function changedTimes(n = 1, options) {
          let count = -1;
          return toMatch(() => {
            count += 1;
            return count >= n;
          }, options);
        }
        if (Array.isArray(toValue(r))) {
          const instance = {
            toMatch,
            toContains,
            changed,
            changedTimes,
            get not() {
              return createUntil(r, !isNot);
            }
          };
          return instance;
        } else {
          const instance = {
            toMatch,
            toBe,
            toBeTruthy,
            toBeNull,
            toBeNaN,
            toBeUndefined,
            changed,
            changedTimes,
            get not() {
              return createUntil(r, !isNot);
            }
          };
          return instance;
        }
      }
      function until(r) {
        return createUntil(r);
      }
      function useIntervalFn(cb, interval = 1e3, options = {}) {
        const {
          immediate = true,
          immediateCallback = false
        } = options;
        let timer = null;
        const isActive = shallowRef(false);
        function clean() {
          if (timer) {
            clearInterval(timer);
            timer = null;
          }
        }
        function pause() {
          isActive.value = false;
          clean();
        }
        function resume() {
          const intervalValue = toValue(interval);
          if (intervalValue <= 0)
            return;
          isActive.value = true;
          if (immediateCallback)
            cb();
          clean();
          if (isActive.value)
            timer = setInterval(cb, intervalValue);
        }
        if (immediate && isClient)
          resume();
        if (isRef(interval) || typeof interval === "function") {
          const stopWatch = watch(interval, () => {
            if (isActive.value && isClient)
              resume();
          });
          tryOnScopeDispose(stopWatch);
        }
        tryOnScopeDispose(pause);
        return {
          isActive,
          pause,
          resume
        };
      }
      function useTimeoutFn(cb, interval, options = {}) {
        const {
          immediate = true,
          immediateCallback = false
        } = options;
        const isPending = shallowRef(false);
        let timer = null;
        function clear() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear();
        }
        function start(...args) {
          if (immediateCallback)
            cb();
          clear();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, toValue(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient)
            start();
        }
        tryOnScopeDispose(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      function watchImmediate(source, cb, options) {
        return watch(
          source,
          cb,
          {
            ...options,
            immediate: true
          }
        );
      }
      function watchOnce(source, cb, options) {
        const stop = watch(source, (...args) => {
          nextTick(() => stop());
          return cb(...args);
        }, options);
        return stop;
      }
      const defaultWindow = isClient ? window : void 0;
      const defaultDocument = isClient ? window.document : void 0;
      const defaultNavigator = isClient ? window.navigator : void 0;
      function unrefElement(elRef) {
        var _a;
        const plain = toValue(elRef);
        return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
      }
      function useEventListener(...args) {
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn) => fn());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options) => {
          el.addEventListener(event, listener, options);
          return () => el.removeEventListener(event, listener, options);
        };
        const firstParamTargets = computed(() => {
          const test = toArray(toValue(args[0])).filter((e) => e != null);
          return test.every((e) => typeof e !== "string") ? test : void 0;
        });
        const stopWatch = watchImmediate(
          () => {
            var _a, _b;
            return [
              (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),
              toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
              toArray(unref(firstParamTargets.value ? args[2] : args[1])),
              // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
              toValue(firstParamTargets.value ? args[3] : args[2])
            ];
          },
          ([raw_targets, raw_events, raw_listeners, raw_options]) => {
            cleanup();
            if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
              return;
            const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
            cleanups.push(
              ...raw_targets.flatMap(
                (el) => raw_events.flatMap(
                  (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))
                )
              )
            );
          },
          { flush: "post" }
        );
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(cleanup);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false, controls = false } = options;
        if (!window2) {
          return controls ? { stop: noop, cancel: noop, trigger: noop } : noop;
        }
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          const listenerOptions = { passive: true };
          Array.from(window2.document.body.children).forEach((el) => useEventListener(el, "click", noop, listenerOptions));
          useEventListener(window2.document.documentElement, "click", noop, listenerOptions);
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return toValue(ignore).some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        function hasMultipleRoots(target2) {
          const vm = toValue(target2);
          return vm && vm.$.subTree.shapeFlag === 16;
        }
        function checkMultipleRoots(target2, event) {
          const vm = toValue(target2);
          const children = vm.$.subTree && vm.$.subTree.children;
          if (children == null || !Array.isArray(children))
            return false;
          return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));
        }
        const listener = (event) => {
          const el = unrefElement(target);
          if (event.target == null)
            return;
          if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event))
            return;
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if ("detail" in event && event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        let isProcessingClick = false;
        const cleanup = [
          useEventListener(window2, "click", (event) => {
            if (!isProcessingClick) {
              isProcessingClick = true;
              setTimeout(() => {
                isProcessingClick = false;
              }, 0);
              listener(event);
            }
          }, { passive: true, capture }),
          useEventListener(window2, "pointerdown", (e) => {
            const el = unrefElement(target);
            shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
          }, { passive: true }),
          detectIframe && useEventListener(window2, "blur", (event) => {
            setTimeout(() => {
              var _a;
              const el = unrefElement(target);
              if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement))) {
                handler(event);
              }
            }, 0);
          }, { passive: true })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn) => fn());
        if (controls) {
          return {
            stop,
            cancel: () => {
              shouldListen = false;
            },
            trigger: (event) => {
              shouldListen = true;
              listener(event);
              shouldListen = false;
            }
          };
        }
        return stop;
      }
      function useMounted() {
        const isMounted = shallowRef(false);
        const instance = getCurrentInstance();
        if (instance) {
          onMounted(() => {
            isMounted.value = true;
          }, instance);
        }
        return isMounted;
      }
      function useSupported(callback) {
        const isMounted = useMounted();
        return computed(() => {
          isMounted.value;
          return Boolean(callback());
        });
      }
      function useMutationObserver(target, callback, options = {}) {
        const { window: window2 = defaultWindow, ...mutationOptions } = options;
        let observer;
        const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const targets = computed(() => {
          const value = toValue(target);
          const items = toArray(value).map(unrefElement).filter(notNullish);
          return new Set(items);
        });
        const stopWatch = watch(
          () => targets.value,
          (targets2) => {
            cleanup();
            if (isSupported.value && targets2.size) {
              observer = new MutationObserver(callback);
              targets2.forEach((el) => observer.observe(el, mutationOptions));
            }
          },
          { immediate: true, flush: "post" }
        );
        const takeRecords = () => {
          return observer == null ? void 0 : observer.takeRecords();
        };
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop,
          takeRecords
        };
      }
      function useAsyncState(promise, initialState, options) {
        const {
          immediate = true,
          delay = 0,
          onError = noop,
          onSuccess = noop,
          resetOnExecute = true,
          shallow = true,
          throwError
        } = options != null ? options : {};
        const state = shallow ? shallowRef(initialState) : ref(initialState);
        const isReady = shallowRef(false);
        const isLoading = shallowRef(false);
        const error = shallowRef(void 0);
        async function execute(delay2 = 0, ...args) {
          if (resetOnExecute)
            state.value = initialState;
          error.value = void 0;
          isReady.value = false;
          isLoading.value = true;
          if (delay2 > 0)
            await promiseTimeout(delay2);
          const _promise = typeof promise === "function" ? promise(...args) : promise;
          try {
            const data = await _promise;
            state.value = data;
            isReady.value = true;
            onSuccess(data);
          } catch (e) {
            error.value = e;
            onError(e);
            if (throwError)
              throw e;
          } finally {
            isLoading.value = false;
          }
          return state.value;
        }
        if (immediate) {
          execute(delay);
        }
        const shell = {
          state,
          isReady,
          isLoading,
          error,
          execute
        };
        function waitUntilIsLoaded() {
          return new Promise((resolve, reject) => {
            until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);
          });
        }
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilIsLoaded().then(onFulfilled, onRejected);
          }
        };
      }
      function usePermission(permissionDesc, options = {}) {
        const {
          controls = false,
          navigator: navigator2 = defaultNavigator
        } = options;
        const isSupported = useSupported(() => navigator2 && "permissions" in navigator2);
        const permissionStatus = shallowRef();
        const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
        const state = shallowRef();
        const update = () => {
          var _a, _b;
          state.value = (_b = (_a = permissionStatus.value) == null ? void 0 : _a.state) != null ? _b : "prompt";
        };
        useEventListener(permissionStatus, "change", update, { passive: true });
        const query = createSingletonPromise(async () => {
          if (!isSupported.value)
            return;
          if (!permissionStatus.value) {
            try {
              permissionStatus.value = await navigator2.permissions.query(desc);
            } catch (e) {
              permissionStatus.value = void 0;
            } finally {
              update();
            }
          }
          if (controls)
            return toRaw(permissionStatus.value);
        });
        query();
        if (controls) {
          return {
            state,
            isSupported,
            query
          };
        } else {
          return state;
        }
      }
      function useClipboard(options = {}) {
        const {
          navigator: navigator2 = defaultNavigator,
          read: read2 = false,
          source,
          copiedDuring = 1500,
          legacy = false
        } = options;
        const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
        const permissionRead = usePermission("clipboard-read");
        const permissionWrite = usePermission("clipboard-write");
        const isSupported = computed(() => isClipboardApiSupported.value || legacy);
        const text = shallowRef("");
        const copied = shallowRef(false);
        const timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });
        async function updateText() {
          let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionRead.value));
          if (!useLegacy) {
            try {
              text.value = await navigator2.clipboard.readText();
            } catch (e) {
              useLegacy = true;
            }
          }
          if (useLegacy) {
            text.value = legacyRead();
          }
        }
        if (isSupported.value && read2)
          useEventListener(["copy", "cut"], updateText, { passive: true });
        async function copy(value = toValue(source)) {
          if (isSupported.value && value != null) {
            let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionWrite.value));
            if (!useLegacy) {
              try {
                await navigator2.clipboard.writeText(value);
              } catch (e) {
                useLegacy = true;
              }
            }
            if (useLegacy)
              legacyCopy(value);
            text.value = value;
            copied.value = true;
            timeout.start();
          }
        }
        function legacyCopy(value) {
          const ta = document.createElement("textarea");
          ta.value = value != null ? value : "";
          ta.style.position = "absolute";
          ta.style.opacity = "0";
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
        }
        function legacyRead() {
          var _a, _b, _c;
          return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
        }
        function isAllowed(status) {
          return status === "granted" || status === "prompt";
        }
        return {
          isSupported,
          text,
          copied,
          copy
        };
      }
      function cloneFnJSON(source) {
        return JSON.parse(JSON.stringify(source));
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      const handlers = /* @__PURE__ */ getHandlers();
      function getHandlers() {
        if (!(globalKey in _global))
          _global[globalKey] = _global[globalKey] || {};
        return _global[globalKey];
      }
      function getSSRHandler(key, fallback) {
        return handlers[key] || fallback;
      }
      function guessSerializerType(rawInit) {
        return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
      }
      const StorageSerializers = {
        boolean: {
          read: (v) => v === "true",
          write: (v) => String(v)
        },
        object: {
          read: (v) => JSON.parse(v),
          write: (v) => JSON.stringify(v)
        },
        number: {
          read: (v) => Number.parseFloat(v),
          write: (v) => String(v)
        },
        any: {
          read: (v) => v,
          write: (v) => String(v)
        },
        string: {
          read: (v) => v,
          write: (v) => String(v)
        },
        map: {
          read: (v) => new Map(JSON.parse(v)),
          write: (v) => JSON.stringify(Array.from(v.entries()))
        },
        set: {
          read: (v) => new Set(JSON.parse(v)),
          write: (v) => JSON.stringify(Array.from(v))
        },
        date: {
          read: (v) => new Date(v),
          write: (v) => v.toISOString()
        }
      };
      const customStorageEventName = "vueuse-storage";
      function useStorage(key, defaults2, storage2, options = {}) {
        var _a;
        const {
          flush = "pre",
          deep = true,
          listenToStorageChanges = true,
          writeDefaults = true,
          mergeDefaults = false,
          shallow,
          window: window2 = defaultWindow,
          eventFilter,
          onError = (e) => {
            console.error(e);
          },
          initOnMounted
        } = options;
        const data = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
        const keyComputed = computed(() => toValue(key));
        if (!storage2) {
          try {
            storage2 = getSSRHandler("getDefaultStorage", () => {
              var _a2;
              return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
            })();
          } catch (e) {
            onError(e);
          }
        }
        if (!storage2)
          return data;
        const rawInit = toValue(defaults2);
        const type = guessSerializerType(rawInit);
        const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
        const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
          data,
          () => write(data.value),
          { flush, deep, eventFilter }
        );
        watch(keyComputed, () => update(), { flush });
        if (window2 && listenToStorageChanges) {
          tryOnMounted(() => {
            if (storage2 instanceof Storage)
              useEventListener(window2, "storage", update, { passive: true });
            else
              useEventListener(window2, customStorageEventName, updateFromCustomEvent);
            if (initOnMounted)
              update();
          });
        }
        if (!initOnMounted)
          update();
        function dispatchWriteEvent(oldValue, newValue) {
          if (window2) {
            const payload = {
              key: keyComputed.value,
              oldValue,
              newValue,
              storageArea: storage2
            };
            window2.dispatchEvent(storage2 instanceof Storage ? new StorageEvent("storage", payload) : new CustomEvent(customStorageEventName, {
              detail: payload
            }));
          }
        }
        function write(v) {
          try {
            const oldValue = storage2.getItem(keyComputed.value);
            if (v == null) {
              dispatchWriteEvent(oldValue, null);
              storage2.removeItem(keyComputed.value);
            } else {
              const serialized = serializer.write(v);
              if (oldValue !== serialized) {
                storage2.setItem(keyComputed.value, serialized);
                dispatchWriteEvent(oldValue, serialized);
              }
            }
          } catch (e) {
            onError(e);
          }
        }
        function read2(event) {
          const rawValue = event ? event.newValue : storage2.getItem(keyComputed.value);
          if (rawValue == null) {
            if (writeDefaults && rawInit != null)
              storage2.setItem(keyComputed.value, serializer.write(rawInit));
            return rawInit;
          } else if (!event && mergeDefaults) {
            const value = serializer.read(rawValue);
            if (typeof mergeDefaults === "function")
              return mergeDefaults(value, rawInit);
            else if (type === "object" && !Array.isArray(value))
              return { ...rawInit, ...value };
            return value;
          } else if (typeof rawValue !== "string") {
            return rawValue;
          } else {
            return serializer.read(rawValue);
          }
        }
        function update(event) {
          if (event && event.storageArea !== storage2)
            return;
          if (event && event.key == null) {
            data.value = rawInit;
            return;
          }
          if (event && event.key !== keyComputed.value)
            return;
          pauseWatch();
          try {
            if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))
              data.value = read2(event);
          } catch (e) {
            onError(e);
          } finally {
            if (event)
              nextTick(resumeWatch);
            else
              resumeWatch();
          }
        }
        function updateFromCustomEvent(event) {
          update(event.detail);
        }
        return data;
      }
      function useCssVar(prop, target, options = {}) {
        const { window: window2 = defaultWindow, initialValue, observe = false } = options;
        const variable = shallowRef(initialValue);
        const elRef = computed(() => {
          var _a;
          return unrefElement(target) || ((_a = window2 == null ? void 0 : window2.document) == null ? void 0 : _a.documentElement);
        });
        function updateCssVar() {
          var _a;
          const key = toValue(prop);
          const el = toValue(elRef);
          if (el && window2 && key) {
            const value = (_a = window2.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();
            variable.value = value || variable.value || initialValue;
          }
        }
        if (observe) {
          useMutationObserver(elRef, updateCssVar, {
            attributeFilter: ["style", "class"],
            window: window2
          });
        }
        watch(
          [elRef, () => toValue(prop)],
          (_, old) => {
            if (old[0] && old[1])
              old[0].style.removeProperty(old[1]);
            updateCssVar();
          },
          { immediate: true }
        );
        watch(
          [variable, elRef],
          ([val, el]) => {
            const raw_prop = toValue(prop);
            if ((el == null ? void 0 : el.style) && raw_prop) {
              if (val == null)
                el.style.removeProperty(raw_prop);
              else
                el.style.setProperty(raw_prop, val);
            }
          },
          { immediate: true }
        );
        return variable;
      }
      function useResizeObserver(target, callback, options = {}) {
        const { window: window2 = defaultWindow, ...observerOptions } = options;
        let observer;
        const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const targets = computed(() => {
          const _targets = toValue(target);
          return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];
        });
        const stopWatch = watch(
          targets,
          (els) => {
            cleanup();
            if (isSupported.value && window2) {
              observer = new ResizeObserver(callback);
              for (const _el of els) {
                if (_el)
                  observer.observe(_el, observerOptions);
              }
            }
          },
          { immediate: true, flush: "post" }
        );
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      function useElementBounding(target, options = {}) {
        const {
          reset = true,
          windowResize = true,
          windowScroll = true,
          immediate = true,
          updateTiming = "sync"
        } = options;
        const height = shallowRef(0);
        const bottom = shallowRef(0);
        const left = shallowRef(0);
        const right = shallowRef(0);
        const top2 = shallowRef(0);
        const width = shallowRef(0);
        const x = shallowRef(0);
        const y = shallowRef(0);
        function recalculate() {
          const el = unrefElement(target);
          if (!el) {
            if (reset) {
              height.value = 0;
              bottom.value = 0;
              left.value = 0;
              right.value = 0;
              top2.value = 0;
              width.value = 0;
              x.value = 0;
              y.value = 0;
            }
            return;
          }
          const rect = el.getBoundingClientRect();
          height.value = rect.height;
          bottom.value = rect.bottom;
          left.value = rect.left;
          right.value = rect.right;
          top2.value = rect.top;
          width.value = rect.width;
          x.value = rect.x;
          y.value = rect.y;
        }
        function update() {
          if (updateTiming === "sync")
            recalculate();
          else if (updateTiming === "next-frame")
            requestAnimationFrame(() => recalculate());
        }
        useResizeObserver(target, update);
        watch(() => unrefElement(target), (ele) => !ele && update());
        useMutationObserver(target, update, {
          attributeFilter: ["style", "class"]
        });
        if (windowScroll)
          useEventListener("scroll", update, { capture: true, passive: true });
        if (windowResize)
          useEventListener("resize", update, { passive: true });
        tryOnMounted(() => {
          if (immediate)
            update();
        });
        return {
          height,
          bottom,
          left,
          right,
          top: top2,
          width,
          x,
          y,
          update
        };
      }
      function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
        const { window: window2 = defaultWindow, box = "content-box" } = options;
        const isSVG = computed(() => {
          var _a, _b;
          return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
        });
        const width = shallowRef(initialSize.width);
        const height = shallowRef(initialSize.height);
        const { stop: stop1 } = useResizeObserver(
          target,
          ([entry]) => {
            const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
            if (window2 && isSVG.value) {
              const $elem = unrefElement(target);
              if ($elem) {
                const rect = $elem.getBoundingClientRect();
                width.value = rect.width;
                height.value = rect.height;
              }
            } else {
              if (boxSize) {
                const formatBoxSize = toArray(boxSize);
                width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
                height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
              } else {
                width.value = entry.contentRect.width;
                height.value = entry.contentRect.height;
              }
            }
          },
          options
        );
        tryOnMounted(() => {
          const ele = unrefElement(target);
          if (ele) {
            width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
            height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
          }
        });
        const stop2 = watch(
          () => unrefElement(target),
          (ele) => {
            width.value = ele ? initialSize.width : 0;
            height.value = ele ? initialSize.height : 0;
          }
        );
        function stop() {
          stop1();
          stop2();
        }
        return {
          width,
          height,
          stop
        };
      }
      function useIntersectionObserver(target, callback, options = {}) {
        const {
          root,
          rootMargin = "0px",
          threshold = 0,
          window: window2 = defaultWindow,
          immediate = true
        } = options;
        const isSupported = useSupported(() => window2 && "IntersectionObserver" in window2);
        const targets = computed(() => {
          const _target = toValue(target);
          return toArray(_target).map(unrefElement).filter(notNullish);
        });
        let cleanup = noop;
        const isActive = shallowRef(immediate);
        const stopWatch = isSupported.value ? watch(
          () => [targets.value, unrefElement(root), isActive.value],
          ([targets2, root2]) => {
            cleanup();
            if (!isActive.value)
              return;
            if (!targets2.length)
              return;
            const observer = new IntersectionObserver(
              callback,
              {
                root: unrefElement(root2),
                rootMargin,
                threshold
              }
            );
            targets2.forEach((el) => el && observer.observe(el));
            cleanup = () => {
              observer.disconnect();
              cleanup = noop;
            };
          },
          { immediate, flush: "post" }
        ) : noop;
        const stop = () => {
          cleanup();
          stopWatch();
          isActive.value = false;
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          isActive,
          pause() {
            cleanup();
            isActive.value = false;
          },
          resume() {
            isActive.value = true;
          },
          stop
        };
      }
      function useElementVisibility(element, options = {}) {
        const {
          window: window2 = defaultWindow,
          scrollTarget,
          threshold = 0,
          rootMargin,
          once = false
        } = options;
        const elementIsVisible = shallowRef(false);
        const { stop } = useIntersectionObserver(
          element,
          (intersectionObserverEntries) => {
            let isIntersecting = elementIsVisible.value;
            let latestTime = 0;
            for (const entry of intersectionObserverEntries) {
              if (entry.time >= latestTime) {
                latestTime = entry.time;
                isIntersecting = entry.isIntersecting;
              }
            }
            elementIsVisible.value = isIntersecting;
            if (once) {
              watchOnce(elementIsVisible, () => {
                stop();
              });
            }
          },
          {
            root: scrollTarget,
            window: window2,
            threshold,
            rootMargin: toValue(rootMargin)
          }
        );
        return elementIsVisible;
      }
      const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
      function useScroll(element, options = {}) {
        const {
          throttle: throttle2 = 0,
          idle = 200,
          onStop = noop,
          onScroll = noop,
          offset = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          },
          eventListenerOptions = {
            capture: false,
            passive: true
          },
          behavior = "auto",
          window: window2 = defaultWindow,
          onError = (e) => {
            console.error(e);
          }
        } = options;
        const internalX = shallowRef(0);
        const internalY = shallowRef(0);
        const x = computed({
          get() {
            return internalX.value;
          },
          set(x2) {
            scrollTo(x2, void 0);
          }
        });
        const y = computed({
          get() {
            return internalY.value;
          },
          set(y2) {
            scrollTo(void 0, y2);
          }
        });
        function scrollTo(_x, _y) {
          var _a, _b, _c, _d;
          if (!window2)
            return;
          const _element = toValue(element);
          if (!_element)
            return;
          (_c = _element instanceof Document ? window2.document.body : _element) == null ? void 0 : _c.scrollTo({
            top: (_a = toValue(_y)) != null ? _a : y.value,
            left: (_b = toValue(_x)) != null ? _b : x.value,
            behavior: toValue(behavior)
          });
          const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;
          if (x != null)
            internalX.value = scrollContainer.scrollLeft;
          if (y != null)
            internalY.value = scrollContainer.scrollTop;
        }
        const isScrolling = shallowRef(false);
        const arrivedState = reactive({
          left: true,
          right: false,
          top: true,
          bottom: false
        });
        const directions = reactive({
          left: false,
          right: false,
          top: false,
          bottom: false
        });
        const onScrollEnd = (e) => {
          if (!isScrolling.value)
            return;
          isScrolling.value = false;
          directions.left = false;
          directions.right = false;
          directions.top = false;
          directions.bottom = false;
          onStop(e);
        };
        const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle2 + idle);
        const setArrivedState = (target) => {
          var _a;
          if (!window2)
            return;
          const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);
          const { display, flexDirection, direction } = getComputedStyle(el);
          const directionMultipler = direction === "rtl" ? -1 : 1;
          const scrollLeft = el.scrollLeft;
          directions.left = scrollLeft < internalX.value;
          directions.right = scrollLeft > internalX.value;
          const left = Math.abs(scrollLeft * directionMultipler) <= (offset.left || 0);
          const right = Math.abs(scrollLeft * directionMultipler) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
          if (display === "flex" && flexDirection === "row-reverse") {
            arrivedState.left = right;
            arrivedState.right = left;
          } else {
            arrivedState.left = left;
            arrivedState.right = right;
          }
          internalX.value = scrollLeft;
          let scrollTop = el.scrollTop;
          if (target === window2.document && !scrollTop)
            scrollTop = window2.document.body.scrollTop;
          directions.top = scrollTop < internalY.value;
          directions.bottom = scrollTop > internalY.value;
          const top2 = Math.abs(scrollTop) <= (offset.top || 0);
          const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
          if (display === "flex" && flexDirection === "column-reverse") {
            arrivedState.top = bottom;
            arrivedState.bottom = top2;
          } else {
            arrivedState.top = top2;
            arrivedState.bottom = bottom;
          }
          internalY.value = scrollTop;
        };
        const onScrollHandler = (e) => {
          var _a;
          if (!window2)
            return;
          const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;
          setArrivedState(eventTarget);
          isScrolling.value = true;
          onScrollEndDebounced(e);
          onScroll(e);
        };
        useEventListener(
          element,
          "scroll",
          throttle2 ? useThrottleFn(onScrollHandler, throttle2, true, false) : onScrollHandler,
          eventListenerOptions
        );
        tryOnMounted(() => {
          try {
            const _element = toValue(element);
            if (!_element)
              return;
            setArrivedState(_element);
          } catch (e) {
            onError(e);
          }
        });
        useEventListener(
          element,
          "scrollend",
          onScrollEnd,
          eventListenerOptions
        );
        return {
          x,
          y,
          isScrolling,
          arrivedState,
          directions,
          measure() {
            const _element = toValue(element);
            if (window2 && _element)
              setArrivedState(_element);
          }
        };
      }
      const UseMouseBuiltinExtractors = {
        page: (event) => [event.pageX, event.pageY],
        client: (event) => [event.clientX, event.clientY],
        screen: (event) => [event.screenX, event.screenY],
        movement: (event) => event instanceof MouseEvent ? [event.movementX, event.movementY] : null
      };
      function useMouse(options = {}) {
        const {
          type = "page",
          touch = true,
          resetOnTouchEnds = false,
          initialValue = { x: 0, y: 0 },
          window: window2 = defaultWindow,
          target = window2,
          scroll = true,
          eventFilter
        } = options;
        let _prevMouseEvent = null;
        let _prevScrollX = 0;
        let _prevScrollY = 0;
        const x = shallowRef(initialValue.x);
        const y = shallowRef(initialValue.y);
        const sourceType = shallowRef(null);
        const extractor = typeof type === "function" ? type : UseMouseBuiltinExtractors[type];
        const mouseHandler = (event) => {
          const result2 = extractor(event);
          _prevMouseEvent = event;
          if (result2) {
            [x.value, y.value] = result2;
            sourceType.value = "mouse";
          }
          if (window2) {
            _prevScrollX = window2.scrollX;
            _prevScrollY = window2.scrollY;
          }
        };
        const touchHandler = (event) => {
          if (event.touches.length > 0) {
            const result2 = extractor(event.touches[0]);
            if (result2) {
              [x.value, y.value] = result2;
              sourceType.value = "touch";
            }
          }
        };
        const scrollHandler = () => {
          if (!_prevMouseEvent || !window2)
            return;
          const pos = extractor(_prevMouseEvent);
          if (_prevMouseEvent instanceof MouseEvent && pos) {
            x.value = pos[0] + window2.scrollX - _prevScrollX;
            y.value = pos[1] + window2.scrollY - _prevScrollY;
          }
        };
        const reset = () => {
          x.value = initialValue.x;
          y.value = initialValue.y;
        };
        const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);
        const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);
        const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();
        if (target) {
          const listenerOptions = { passive: true };
          useEventListener(target, ["mousemove", "dragover"], mouseHandlerWrapper, listenerOptions);
          if (touch && type !== "movement") {
            useEventListener(target, ["touchstart", "touchmove"], touchHandlerWrapper, listenerOptions);
            if (resetOnTouchEnds)
              useEventListener(target, "touchend", reset, listenerOptions);
          }
          if (scroll && type === "page")
            useEventListener(window2, "scroll", scrollHandlerWrapper, listenerOptions);
        }
        return {
          x,
          y,
          sourceType
        };
      }
      function useMouseInElement(target, options = {}) {
        const {
          handleOutside = true,
          window: window2 = defaultWindow
        } = options;
        const type = options.type || "page";
        const { x, y, sourceType } = useMouse(options);
        const targetRef = shallowRef(target != null ? target : window2 == null ? void 0 : window2.document.body);
        const elementX = shallowRef(0);
        const elementY = shallowRef(0);
        const elementPositionX = shallowRef(0);
        const elementPositionY = shallowRef(0);
        const elementHeight = shallowRef(0);
        const elementWidth = shallowRef(0);
        const isOutside = shallowRef(true);
        let stop = () => {
        };
        if (window2) {
          stop = watch(
            [targetRef, x, y],
            () => {
              const el = unrefElement(targetRef);
              if (!el || !(el instanceof Element))
                return;
              const {
                left,
                top: top2,
                width,
                height
              } = el.getBoundingClientRect();
              elementPositionX.value = left + (type === "page" ? window2.pageXOffset : 0);
              elementPositionY.value = top2 + (type === "page" ? window2.pageYOffset : 0);
              elementHeight.value = height;
              elementWidth.value = width;
              const elX = x.value - elementPositionX.value;
              const elY = y.value - elementPositionY.value;
              isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;
              if (handleOutside || !isOutside.value) {
                elementX.value = elX;
                elementY.value = elY;
              }
            },
            { immediate: true }
          );
          useEventListener(
            document,
            "mouseleave",
            () => isOutside.value = true,
            { passive: true }
          );
        }
        return {
          x,
          y,
          sourceType,
          elementX,
          elementY,
          elementPositionX,
          elementPositionY,
          elementHeight,
          elementWidth,
          isOutside,
          stop
        };
      }
      function useTitle(newTitle = null, options = {}) {
        var _a, _b, _c;
        const {
          document: document2 = defaultDocument,
          restoreOnUnmount = (t) => t
        } = options;
        const originalTitle = (_a = document2 == null ? void 0 : document2.title) != null ? _a : "";
        const title = toRef((_b = newTitle != null ? newTitle : document2 == null ? void 0 : document2.title) != null ? _b : null);
        const isReadonly2 = !!(newTitle && typeof newTitle === "function");
        function format(t) {
          if (!("titleTemplate" in options))
            return t;
          const template = options.titleTemplate || "%s";
          return typeof template === "function" ? template(t) : toValue(template).replace(/%s/g, t);
        }
        watch(
          title,
          (newValue, oldValue) => {
            if (newValue !== oldValue && document2)
              document2.title = format(newValue != null ? newValue : "");
          },
          { immediate: true }
        );
        if (options.observe && !options.titleTemplate && document2 && !isReadonly2) {
          useMutationObserver(
            (_c = document2.head) == null ? void 0 : _c.querySelector("title"),
            () => {
              if (document2 && document2.title !== title.value)
                title.value = format(document2.title);
            },
            { childList: true }
          );
        }
        tryOnScopeDispose(() => {
          if (restoreOnUnmount) {
            const restoredTitle = restoreOnUnmount(originalTitle, title.value || "");
            if (restoredTitle != null && document2)
              document2.title = restoredTitle;
          }
        });
        return title;
      }
      function useVModel(props, key, emit, options = {}) {
        var _a, _b, _c;
        const {
          clone = false,
          passive = false,
          eventName,
          deep = false,
          defaultValue,
          shouldEmit
        } = options;
        const vm = getCurrentInstance();
        const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
        let event = eventName;
        if (!key) {
          key = "modelValue";
        }
        event = event || `update:${key.toString()}`;
        const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
        const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
        const triggerEmit = (value) => {
          if (shouldEmit) {
            if (shouldEmit(value))
              _emit(event, value);
          } else {
            _emit(event, value);
          }
        };
        if (passive) {
          const initialValue = getValue2();
          const proxy = ref(initialValue);
          let isUpdating = false;
          watch(
            () => props[key],
            (v) => {
              if (!isUpdating) {
                isUpdating = true;
                proxy.value = cloneFn(v);
                nextTick(() => isUpdating = false);
              }
            }
          );
          watch(
            proxy,
            (v) => {
              if (!isUpdating && (v !== props[key] || deep))
                triggerEmit(v);
            },
            { deep }
          );
          return proxy;
        } else {
          return computed({
            get() {
              return getValue2();
            },
            set(value) {
              triggerEmit(value);
            }
          });
        }
      }
      function useVModels(props, emit, options = {}) {
        const ret = {};
        for (const key in props) {
          ret[key] = useVModel(
            props,
            key,
            emit,
            options
          );
        }
        return ret;
      }
      const ICON_STAR_FILL = exports("h", "material-symbols:star");
      const ICON_STAR = exports("i", "material-symbols:star-outline");
      const ICON_ERROR = "line-md:alert-circle-twotone-loop";
      const ICON_PLAYLIST = exports("a", "material-symbols:order-play-rounded");
      const ICON_CLOSE = exports("j", "material-symbols:close-rounded");
      const ICON_SKIP_PREVIOUS = exports("b", "material-symbols:skip-previous-rounded");
      const ICON_SKIP_NEXT = exports("c", "material-symbols:skip-next-rounded");
      const _sfc_main$1 = exports("_", /* @__PURE__ */ defineComponent({
        __name: "index",
        props: {
          type: { default: "error" },
          retryable: { type: Boolean, default: false },
          message: { default: void 0 },
          retryText: { default: "重试" },
          noPadding: { type: Boolean, default: false },
          size: { default: "medium" },
          icon: { default: ICON_ERROR },
          fold: { type: Boolean }
        },
        emits: ["retry"],
        setup(__props) {
          const props = __props;
          const iconName = computed(() => props.icon);
          const styles = computed(() => ({
            // 容器样式
            container: [
              "flex flex-col items-center justify-center text-base-content/70",
              // 间距和内边距
              props.size === "mini" ? "gap-1" : "gap-2",
              !props.noPadding && props.size !== "mini" && "p-2",
              // 动画效果
              "animate-in fade-in duration-300"
            ],
            // 图标样式
            icon: [
              `text-${props.type}`,
              // 根据尺寸调整图标大小
              {
                mini: "text-2xl",
                small: "text-3xl",
                medium: "text-5xl",
                large: "text-6xl"
              }[props.size]
            ],
            // 文本样式
            text: [
              "text-center m-0 select-text font-medium",
              // 根据尺寸调整字体大小
              {
                mini: "text-xs",
                small: "text-sm",
                medium: "text-base",
                large: "text-lg"
              }[props.size]
            ],
            // 详情按钮样式
            detailButton: ["btn btn-error btn-xs"],
            // 重试按钮样式
            retryButton: [
              "btn btn-error btn-sm transition-all duration-200",
              "hover:btn-error hover:scale-105 active:scale-95"
            ]
          }));
          function handleDetail(detail) {
            if (detail instanceof Error) {
              return `[Error name]: ${detail.name}
[Error message]: ${detail.message}
[Error stack]: ${detail.stack}`;
            }
            return detail;
          }
          function handleShowDetail() {
            const detail = handleDetail(props.message);
            const { copy } = useClipboard();
            copy(detail);
            alert(detail);
            alert("已将错误信息复制到剪贴板");
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(styles.value.container)
            }, [
              createVNode(unref(Icon), {
                icon: iconName.value,
                class: normalizeClass(styles.value.icon)
              }, null, 8, ["icon", "class"]),
              createElementVNode("p", {
                class: normalizeClass(styles.value.text)
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.message || unref(FRIENDLY_ERROR_MESSAGE).UNKNOWN_ERROR), 1)
                ])
              ], 2),
              props.message instanceof Error ? (openBlock(), createElementBlock("button", {
                key: 0,
                class: normalizeClass(styles.value.detailButton),
                onClick: handleShowDetail
              }, " 查看错误 ", 2)) : createCommentVNode("", true),
              props.retryable ? (openBlock(), createElementBlock("button", {
                key: 1,
                class: normalizeClass(styles.value.retryButton),
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("retry"))
              }, toDisplayString(props.retryText), 3)) : createCommentVNode("", true)
            ], 2);
          };
        }
      }));
      const IMAGE_CACHE_KEY = "image_cache";
      class ImageCache extends CacheCore {
        constructor() {
          super({
            storeName: IMAGE_CACHE_KEY
          });
        }
      }
      new ImageCache();
      let Logger$1 = class Logger {
        /**
         * 构造函数
         * @param appName 应用名称
         * @param moduleName 模块名称
         */
        constructor(appName, moduleName) {
          Object.defineProperty(this, "appName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "moduleName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.appName = appName;
          this.moduleName = moduleName;
        }
        /**
         * 日志
         * @param logName 日志名称
         * @param args 日志参数
         */
        log(logName, ...args) {
          if (args.length === 0 || typeof args[0] === "string" || typeof args[0] === "number") {
            console.log(...this.formatMessage(logName, ...args));
          } else {
            console.log(...this.formatMessage(logName));
            console.log(...args);
          }
        }
        /**
         * 错误日志
         * @param logName 日志名称
         * @param msg 日志消息
         */
        error(logName, msg) {
          console.log(...this.formatMessage(logName));
          console.error(msg);
        }
        /**
         * 格式化日志消息
         * @param logName 日志名称
         * @param args 日志参数
         * @returns 格式化后的日志消息
         */
        formatMessage(logName, ...args) {
          return [
            `%c${this.appName}%c ${this.moduleName}%c ${logName}%c ${args}`,
            "color: #409EFF; font-weight: bold",
            // appName 样式：蓝色
            "color: #67C23A; font-weight: bold",
            // moduleName 样式：绿色
            "color: #E6A23C; font-weight: bold",
            // logName 样式：黄色
            "color: inherit; margin-top: 4px"
            // 恢复默认样式
          ];
        }
      };
      class AppLogger extends Logger$1 {
        constructor(moduleName) {
          super("115Master", moduleName);
        }
      }
      class QualityPreferenceCache extends CacheCore {
        constructor() {
          super({
            storeName: "quality_preference_cache"
          });
          Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new AppLogger("Utils QualityPreferenceCache")
          });
          Object.defineProperty(this, "CACHE_PREFIX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "115master_quality_preference_"
          });
          Object.defineProperty(this, "DEFAULT_EXPIRES_IN", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Number.POSITIVE_INFINITY
          });
        }
        /**
         * 获取画质偏好
         * @param videoId 视频标识符（pickCode 或 sha1）
         * @returns 画质偏好配置
         */
        async getPreference(videoId) {
          try {
            const cacheKey = this.CACHE_PREFIX + videoId;
            const cached = await this.get(cacheKey);
            if (!cached) {
              this.logger.log("getPreference", `画质偏好缓存未找到: ${videoId}`);
              return null;
            }
            const now = Date.now();
            if (now - cached.createdAt > this.DEFAULT_EXPIRES_IN) {
              this.logger.log("getPreference", `画质偏好缓存已过期: ${videoId}`);
              await this.remove(cacheKey);
              return null;
            }
            this.logger.log("getPreference", `画质偏好缓存命中: ${videoId}，画质: ${cached.value.quality}`);
            return cached.value;
          } catch (error) {
            this.logger.error("获取画质偏好失败:", error);
            return null;
          }
        }
        /**
         * 保存画质偏好
         * @param videoId 视频标识符（pickCode 或 sha1）
         * @param quality 画质值
         * @param displayQuality 显示画质
         */
        async setPreference(videoId, quality, displayQuality) {
          try {
            const cacheKey = this.CACHE_PREFIX + videoId;
            const preference = {
              quality,
              displayQuality,
              updatedAt: Date.now()
            };
            await this.set(cacheKey, preference);
            this.logger.log("setPreference", `画质偏好已保存: ${videoId}，画质: ${quality}`);
          } catch (error) {
            this.logger.error("保存画质偏好失败:", error);
          }
        }
        /**
         * 删除画质偏好
         * @param videoId 视频标识符（pickCode 或 sha1）
         */
        async removePreference(videoId) {
          try {
            const cacheKey = this.CACHE_PREFIX + videoId;
            await this.remove(cacheKey);
            this.logger.log("removePreference", `画质偏好已删除: ${videoId}`);
          } catch (error) {
            this.logger.error("删除画质偏好失败:", error);
          }
        }
        /**
         * 清理过期的画质偏好
         */
        async cleanExpired() {
          try {
            const now = Date.now();
            const allKeys = await this.storage.keys();
            for (const key of allKeys) {
              if (key.startsWith(this.CACHE_PREFIX)) {
                const cached = await this.storage.getItem(key);
                if (cached && cached.createdAt && now - cached.createdAt > this.DEFAULT_EXPIRES_IN) {
                  await this.remove(key);
                  this.logger.log("cleanExpired", `已清理过期画质偏好: ${key}`);
                }
              }
            }
          } catch (error) {
            this.logger.error("清理过期画质偏好失败:", error);
          }
        }
      }
      const qualityPreferenceCache = exports("z", new QualityPreferenceCache());
      class TransformPreferenceCache extends CacheCore {
        constructor() {
          super({
            storeName: "transform_preference_cache",
            enableQuotaManagement: true
          });
          Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new AppLogger("Utils TransformPreferenceCache")
          });
          Object.defineProperty(this, "CACHE_PREFIX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "115master_transform_preference_"
          });
          Object.defineProperty(this, "DEFAULT_EXPIRES_IN", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Number.POSITIVE_INFINITY
          });
        }
        /**
         * 获取旋转翻转偏好
         * @param videoId 视频标识符（pickCode 或 sha1）
         * @returns 旋转翻转偏好配置
         */
        async getPreference(videoId) {
          try {
            const cacheKey = this.CACHE_PREFIX + videoId;
            const cached = await this.get(cacheKey);
            if (!cached) {
              this.logger.log("getPreference", `旋转翻转偏好缓存未找到: ${videoId}`);
              return null;
            }
            const now = Date.now();
            if (now - cached.createdAt > this.DEFAULT_EXPIRES_IN) {
              this.logger.log("getPreference", `旋转翻转偏好缓存已过期: ${videoId}`);
              await this.remove(cacheKey);
              return null;
            }
            this.logger.log("getPreference", `旋转翻转偏好缓存命中: ${videoId}，旋转: ${cached.value.rotate}°，水平翻转: ${cached.value.flipX}，垂直翻转: ${cached.value.flipY}`);
            return cached.value;
          } catch (error) {
            this.logger.error("获取旋转翻转偏好失败:", error);
            return null;
          }
        }
        /**
         * 保存旋转翻转偏好
         * @param videoId 视频标识符（pickCode 或 sha1）
         * @param rotate 旋转角度
         * @param flipX 水平翻转状态
         * @param flipY 垂直翻转状态
         */
        async setPreference(videoId, rotate, flipX, flipY) {
          try {
            const cacheKey = this.CACHE_PREFIX + videoId;
            const now = Date.now();
            const preference = {
              rotate,
              flipX,
              flipY,
              createdAt: now
            };
            await this.set(cacheKey, preference);
            this.logger.log("setPreference", `旋转翻转偏好已保存: ${videoId}，旋转: ${rotate}°，水平翻转: ${flipX}，垂直翻转: ${flipY}`);
          } catch (error) {
            this.logger.error("保存旋转翻转偏好失败:", error);
          }
        }
        /**
         * 删除旋转翻转偏好
         * @param videoId 视频标识符
         */
        async removePreference(videoId) {
          try {
            const cacheKey = this.CACHE_PREFIX + videoId;
            await this.remove(cacheKey);
            this.logger.log("removePreference", `旋转翻转偏好已删除: ${videoId}`);
          } catch (error) {
            this.logger.error("删除旋转翻转偏好失败:", error);
          }
        }
        /**
         * 清理过期的旋转翻转偏好
         */
        async cleanExpired() {
          try {
            const now = Date.now();
            const allKeys = await this.storage.keys();
            for (const key of allKeys) {
              if (key.startsWith(this.CACHE_PREFIX)) {
                const cached = await this.storage.getItem(key);
                if (cached && cached.createdAt && now - cached.createdAt > this.DEFAULT_EXPIRES_IN) {
                  await this.remove(key);
                  this.logger.log("cleanExpired", `已清理过期旋转翻转偏好: ${key}`);
                }
              }
            }
          } catch (error) {
            this.logger.error("清理过期旋转翻转偏好失败:", error);
          }
        }
      }
      const transformPreferenceCache = exports("A", new TransformPreferenceCache());
      const VIDEO_COVER_CACHE_KEY = "video_cover_cache_v1";
      class VideoCoverCache extends CacheCore {
        constructor() {
          super({
            storeName: VIDEO_COVER_CACHE_KEY
          });
        }
      }
      const videoCoverCache = new VideoCoverCache();
      function promiseDelay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      class FetchIO {
        /**
         * 从URL获取指定范围的ArrayBuffer
         * @param url 目标URL
         * @param start 起始字节
         * @param end 结束字节
         * @returns 获取到的ArrayBuffer
         */
        async fetchBufferRange(url, start, end) {
          const response = fetch(url, {
            method: "GET",
            headers: {
              Range: `bytes=${start}-${end}`
            },
            priority: "low"
          });
          return response;
        }
        /**
         * 流式读取视频块
         */
        async streamChunks(url, callback, options = {}) {
          const stepChunkSize = options.stepChunkSize || 385024;
          let currentPosition = 0;
          let shouldContinue = true;
          try {
            while (shouldContinue) {
              const response = await this.fetchBufferRange(url, currentPosition, currentPosition + stepChunkSize - 1);
              if (response.status !== 206) {
                shouldContinue = false;
                break;
              }
              shouldContinue = await callback(await response.arrayBuffer(), currentPosition);
              currentPosition += stepChunkSize;
            }
          } catch (error) {
            console.error("流式读取数据出错:", error);
            throw error;
          }
        }
      }
      class HlsIO {
        constructor() {
          Object.defineProperty(this, "info", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "segmentIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
          });
          Object.defineProperty(this, "segments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
          });
          Object.defineProperty(this, "duration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
          });
        }
        /** 当前分片 */
        get segment() {
          return this.segments[this.segmentIndex];
        }
        /** 当前分片URL */
        get segmentUrl() {
          if (!this.info) {
            throw new Error("info is undefined");
          }
          return new URL(this.segment.uri, this.info.url).href;
        }
        /**
         * 打开
         * @param info 请求信息
         */
        async open(info) {
          this.info = info;
          await this.fetchMasterPlaylist();
        }
        /**
         * 读取
         * @param range 范围
         * @returns 获取到的ArrayBuffer
         */
        async read(range) {
          var _a;
          const response = await fetch(this.segments[this.segmentIndex].uri, {
            headers: {
              Range: `bytes=${range.start}-${range.end}`
            },
            ...((_a = this.info) == null ? void 0 : _a.fetchOptions) ?? {}
          });
          return await response.arrayBuffer();
        }
        /**
         * 跳转
         * @param time 时间
         * @returns 跳转到的分片
         */
        async seek(time) {
          this.segmentIndex = this.segments.findIndex((i) => i.timestamp <= time && time <= i.timestamp + i.duration);
          if (this.segmentIndex === -1) {
            throw new Error("时间超出范围");
          }
          return this.segment;
        }
        /**
         * 销毁
         */
        destroy() {
          this.segments = [];
          this.segmentIndex = 0;
          this.duration = 0;
          this.info = void 0;
        }
        /**
         * 获取主播放列表
         */
        async fetchMasterPlaylist() {
          if (!this.info) {
            throw new Error("info is undefined");
          }
          const response = await fetch(this.info.url, {
            headers: this.info.headers
          });
          const m3u8Text = await response.text();
          const parser = new Parser();
          parser.push(m3u8Text);
          parser.end();
          let start = 0;
          this.segments = parser.manifest.segments.map((segment) => {
            var _a;
            const timestamp = start;
            start += segment.duration;
            return {
              ...segment,
              duration: segment.duration,
              timestamp,
              url: new URL(segment.uri, (_a = this.info) == null ? void 0 : _a.url).href
            };
          });
          this.duration = start;
        }
      }
      var Events;
      (function(Events2) {
        Events2["ERROR"] = "ERROR";
        Events2["INFO"] = "INFO";
        Events2["DATA"] = "DATA";
        Events2["DEMUX_DATA"] = "DEMUX_DATA";
        Events2["DONE"] = "DONE";
      })(Events || (Events = {}));
      var objectCreate = Object.create || objectCreatePolyfill;
      var objectKeys = Object.keys || objectKeysPolyfill;
      var bind = Function.prototype.bind || functionBindPolyfill;
      let defaultMaxListeners = 10;
      const _EventEmitter = class _EventEmitter {
        constructor() {
          __publicField(this, "_maxListeners");
          __publicField(this, "_eventsCount");
          __publicField(this, "_events");
          if (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) {
            this._events = objectCreate(null);
            this._eventsCount = 0;
          }
          this._maxListeners = this._maxListeners || void 0;
        }
        static listenerCount(emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type);
          } else {
            return listenerCount.call(emitter, type);
          }
        }
        // // Obviously not all Emitters should be limited to 10. This function allows
        // // that to be increased. Set to zero for unlimited.
        // setMaxListeners(n) {
        //     if (typeof n !== 'number' || n < 0 || isNaN(n))
        //         throw new TypeError('"n" argument must be a positive number');
        //     this._maxListeners = n;
        //     return this;
        // }
        //
        // getMaxListeners() {
        //     return $getMaxListeners(this);
        // }
        emit(type, ...rest) {
          var er, handler, len, args, i, events;
          var doError = type === "error";
          events = this._events;
          if (events)
            doError = doError && events.error == null;
          else if (!doError)
            return false;
          if (doError) {
            if (arguments.length > 1)
              er = arguments[1];
            if (er instanceof Error) {
              throw er;
            } else {
              var err = new Error('Unhandled "error" event. (' + er + ")");
              err["context"] = er;
              throw err;
            }
          }
          handler = events[type];
          if (!handler)
            return false;
          var isFn = typeof handler === "function";
          len = arguments.length;
          switch (len) {
            // fast cases
            case 1:
              emitNone(handler, isFn, this);
              break;
            case 2:
              emitOne(handler, isFn, this, arguments[1]);
              break;
            case 3:
              emitTwo(handler, isFn, this, arguments[1], arguments[2]);
              break;
            case 4:
              emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
              break;
            // slower
            default:
              args = new Array(len - 1);
              for (i = 1; i < len; i++)
                args[i - 1] = arguments[i];
              emitMany(handler, isFn, this, args);
          }
          return true;
        }
        on(type, listener) {
          return _addListener(this, type, listener);
        }
        once(type, listener) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');
          this.on(type, _onceWrap(this, type, listener));
          return this;
        }
        off(type, listener) {
          return _removeListener.call(this, type, listener);
        }
        removeAllListeners(type) {
          var listeners, events, i;
          events = this._events;
          if (!events)
            return this;
          if (!events.off) {
            if (arguments.length === 0) {
              this._events = objectCreate(null);
              this._eventsCount = 0;
            } else if (events[type]) {
              if (--this._eventsCount === 0)
                this._events = objectCreate(null);
              else
                delete events[type];
            }
            return this;
          }
          if (arguments.length === 0) {
            var keys = objectKeys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === "off")
                continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("off");
            this._events = objectCreate(null);
            this._eventsCount = 0;
            return this;
          }
          listeners = events[type];
          if (typeof listeners === "function") {
            this.off(type, listeners);
          } else if (listeners) {
            for (i = listeners.length - 1; i >= 0; i--) {
              this.off(type, listeners[i]);
            }
          }
          return this;
        }
        listeners(type) {
          return _listeners(this, type, true);
        }
        rawListeners(type) {
          return _listeners(this, type, false);
        }
        listenerCount() {
          return _EventEmitter.listenerCount.apply(this, arguments);
        }
      };
      __publicField(_EventEmitter, "defaultMaxListeners");
      let EventEmitter = _EventEmitter;
      let hasDefineProperty;
      try {
        var o = {};
        if (Object.defineProperty)
          Object.defineProperty(o, "x", { value: 0 });
        hasDefineProperty = o["x"] === 0;
      } catch (err) {
        hasDefineProperty = false;
      }
      if (hasDefineProperty) {
        Object.defineProperty(EventEmitter, "defaultMaxListeners", {
          enumerable: true,
          get: function() {
            return defaultMaxListeners;
          },
          set: function(arg) {
            if (typeof arg !== "number" || arg < 0 || arg !== arg)
              throw new TypeError('"defaultMaxListeners" must be a positive number');
            defaultMaxListeners = arg;
          }
        });
      } else {
        EventEmitter.defaultMaxListeners = defaultMaxListeners;
      }
      function $getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      function emitNone(handler, isFn, self2) {
        if (isFn)
          handler.call(self2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            try {
              listeners[i].call(self2);
            } catch (e) {
              console.error(e);
            }
          }
        }
      }
      function emitOne(handler, isFn, self2, arg1) {
        if (isFn)
          handler.call(self2, arg1);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            try {
              listeners[i].call(self2, arg1);
            } catch (e) {
              console.error(e);
            }
          }
        }
      }
      function emitTwo(handler, isFn, self2, arg1, arg2) {
        if (isFn)
          handler.call(self2, arg1, arg2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            try {
              listeners[i].call(self2, arg1, arg2);
            } catch (e) {
              console.error(e);
            }
          }
        }
      }
      function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
        if (isFn)
          handler.call(self2, arg1, arg2, arg3);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            try {
              listeners[i].call(self2, arg1, arg2, arg3);
            } catch (e) {
              console.error(e);
            }
          }
        }
      }
      function emitMany(handler, isFn, self2, args) {
        if (isFn)
          handler.apply(self2, args);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            try {
              listeners[i].apply(self2, args);
            } catch (e) {
              console.error(e);
            }
          }
        }
      }
      function _addListener(target, type, listener) {
        var m;
        var events;
        var existing;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = target._events;
        if (!events) {
          events = target._events = objectCreate(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener) {
            target.emit("newListener", type, listener["listener"] ? listener["listener"] : listener);
            events = target._events;
          }
          existing = events[type];
        }
        if (!existing) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = [existing, listener];
          } else {
            existing.push(listener);
          }
          if (!existing.warned) {
            m = $getMaxListeners(target);
            if (m && m > 0 && existing.length > m) {
              existing.warned = true;
              class CustomError extends Error {
                constructor() {
                  super(...arguments);
                  __publicField(this, "emitter");
                  __publicField(this, "type");
                  __publicField(this, "count");
                }
              }
              let w = new CustomError("Possible Dispatcher memory leak detected. " + existing.length + ' "' + String(type) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type;
              w.count = existing.length;
              if (typeof console === "object" && console.warn) {
                console.warn("%s: %s", w.name, w.message);
              }
            }
          }
        }
        return target;
      }
      function _removeListener(type, listener) {
        var list, events, position, i, originalListener;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list = events[type];
        if (!list)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else {
            delete events[type];
            if (events.off)
              this.emit("off", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else
            spliceOne(list, position);
          if (list.length === 1)
            events[type] = list[0];
          if (events.off)
            this.emit("off", type, originalListener || listener);
        }
        return this;
      }
      function onceWrapper() {
        if (!this.fired) {
          this.target.off(this.type, this.wrapFn);
          this.fired = true;
          switch (arguments.length) {
            case 0:
              return this.listener.call(this.target);
            case 1:
              return this.listener.call(this.target, arguments[0]);
            case 2:
              return this.listener.call(this.target, arguments[0], arguments[1]);
            case 3:
              return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
            default:
              var args = new Array(arguments.length);
              for (var i = 0; i < args.length; ++i)
                args[i] = arguments[i];
              this.listener.apply(this.target, args);
          }
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = bind.call(onceWrapper, state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (!events)
          return [];
        var evlistener = events[type];
        if (!evlistener)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      function listenerCount(type) {
        var events = this._events;
        if (events) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener) {
            return evlistener.length;
          }
        }
        return 0;
      }
      function spliceOne(list, index) {
        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
          list[i] = list[k];
        list.pop();
      }
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function objectCreatePolyfill(proto) {
        var F = function() {
        };
        F.prototype = proto;
        return new F();
      }
      function objectKeysPolyfill(obj) {
        for (var k in obj)
          if (Object.prototype.hasOwnProperty.call(obj, k)) ;
        return k;
      }
      function functionBindPolyfill(context) {
        var fn = this;
        return function() {
          return fn.apply(context, arguments);
        };
      }
      class Context extends EventEmitter {
      }
      var objectToString = Object.prototype.toString;
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isNumber(num) {
        return typeof num === "number" && !isNaN(num);
      }
      function isArrayBuffer(value) {
        return isObjectLike(value) && objectToString.call(value).toLowerCase() === "[object arraybuffer]";
      }
      function isUint8Array(value) {
        return isObjectLike(value) && objectToString.call(value).toLowerCase() === "[object uint8array]";
      }
      class CacheBuffer {
        constructor() {
          /**
           * Used to cache calculations, reduce the number of CPU calculations.
           * When internal data changes, the value needs to be cleared and recalculated.
           */
          __publicField(this, "byteLength_");
          __publicField(this, "list_", []);
        }
        get byteLength() {
          if (!isNumber(this.byteLength_)) {
            let len = 0;
            for (let i = 0, item; i < this.list_.length; i++) {
              item = this.list_[i];
              len += item.byteLength;
            }
            this.byteLength_ = len;
          }
          return this.byteLength_;
        }
        /**
         * maybe return new allocated memory or original memory
         */
        get bytes() {
          const { bufferList } = this;
          let bytes = null;
          if (bufferList.length > 0) {
            if (bufferList.length === 0) {
              bytes = bufferList[0];
            } else {
              bytes = this.toNewBytes();
            }
          }
          return bytes;
        }
        get empty() {
          return this.list_.length === 0;
        }
        get bufferList() {
          return this.list_;
        }
        clear() {
          let len = this.list_.length;
          if (len > 0) {
            this.list_.splice(0, len);
          }
          this.byteLength_ = null;
        }
        toNewBytes() {
          let bytes = null;
          let tryCount = 0;
          let maxTryCount = 50;
          while (bytes === null) {
            try {
              tryCount++;
              bytes = new Uint8Array(this.byteLength);
            } catch (e) {
              if (tryCount > maxTryCount) {
                throw e;
              }
            }
          }
          for (let i = 0, offset = 0; i < this.list_.length; i++) {
            let payload = this.list_[i];
            bytes.set(payload, offset);
            offset += payload.byteLength;
          }
          return bytes;
        }
        append(newBuffer) {
          if (newBuffer instanceof CacheBuffer) {
            this.list_ = this.list_.concat(newBuffer.bufferList);
          } else {
            this.list_.push(newBuffer);
          }
          this.byteLength_ = null;
        }
        /**
         * This function cuts a complete TypedArray from CacheBuffer and retains the remainder of CacheBuffer.
         * The following points should be noted when using this function:
         * 1. If the cut needs to return the cut-out part, the cut length should be as small as possible to reduce the errors in memory application.
         * 2. If the cutting is only to preserve the remaining parts, the cutting size is within the total number of bytes, without considering memory applications.
         * @param {number} fixedLength
         * @param {boolean} [needCutResult] - If not, just retain the remaining parts after cutting.
         */
        cut(fixedLength, needCutResult = true) {
          let chunk = null;
          if (fixedLength > 0 && !this.empty) {
            let list = this.list_;
            let offset = 0;
            let loopIndex = 0;
            while (list.length > 0) {
              let cur = list.shift();
              if (loopIndex === 0) {
                if (cur.byteLength >= fixedLength) {
                  if (needCutResult) {
                    chunk = cur.subarray(0, fixedLength);
                  }
                  if (cur.byteLength > fixedLength) {
                    cur = cur.subarray(fixedLength);
                    list.unshift(cur);
                  }
                  break;
                } else {
                  if (needCutResult) {
                    try {
                      chunk = new Uint8Array(fixedLength);
                    } catch (e) {
                      throw `alloc_memory_error@ cache buffer: ${fixedLength} ${e.message}`;
                    }
                    chunk.set(cur, 0);
                  }
                  offset += cur.byteLength;
                }
              } else {
                let subLen = fixedLength - offset;
                if (cur.byteLength >= subLen) {
                  if (needCutResult) {
                    chunk.set(cur.subarray(0, subLen), offset);
                  }
                  cur = cur.subarray(subLen);
                  if (cur.byteLength > 0) {
                    list.unshift(cur);
                  }
                  break;
                } else {
                  if (needCutResult) {
                    chunk.set(cur, offset);
                  }
                  offset += cur.byteLength;
                  break;
                }
              }
              loopIndex++;
            }
            this.byteLength_ = null;
          }
          return chunk;
        }
      }
      class MultiMap {
        constructor() {
          __publicField(this, "map_");
          this.map_ = {};
        }
        /**
         * Add a key, value pair to the map.
         * @param key
         * @param value
         */
        push(key, value) {
          if (Object.prototype.hasOwnProperty.call(this.map_, key)) {
            this.map_[key].push(value);
          } else {
            this.map_[key] = [value];
          }
        }
        /**
         * Get a list of values by key.
         * @param key
         */
        get(key) {
          let list = this.map_[key];
          return list ? list.slice() : null;
        }
        /**
         * Get a list of all values.
         */
        getAll() {
          let list = [];
          for (let key in this.map_) {
            list.push.apply(list, this.map_[key]);
          }
          return list;
        }
        /**
         * Remove a specific value, if it exists.
         * @param key
         * @param value
         */
        remove(key, value) {
          let list = this.map_[key];
          if (list) {
            for (let i = 0; i < list.length; ++i) {
              if (list[i] == value) {
                list.splice(i, 1);
                --i;
              }
            }
          }
        }
        /**
         * Clear all keys and values from the multimap.
         */
        clear() {
          this.map_ = {};
        }
        /**
         * @param callback
         */
        forEach(callback) {
          for (let key in this.map_) {
            callback(key, this.map_[key]);
          }
        }
      }
      class Binding_ {
        /**
         * @param target - The event target.
         * @param type - The event type.
         * @param listener - The event listener.
         */
        constructor(target, type, listener) {
          __publicField(this, "target");
          __publicField(this, "type");
          __publicField(this, "listener");
          this.target = target;
          this.type = type;
          this.listener = listener;
          if (this.target.addEventListener) {
            this.target.addEventListener(type, listener, false);
          } else if (this.target.on) {
            this.target.on(type, listener, false);
          }
        }
        /**
         * Detaches the event listener from the event target.
         * This does nothing if the event listener is already detached.
         */
        off() {
          if (this.target.removeEventListener) {
            this.target.removeEventListener(this.type, this.listener, false);
          } else if (this.target.off) {
            this.target.off(this.type, this.listener, false);
          }
          this.target = null;
          this.listener = null;
        }
      }
      class EventManager {
        // static Binding_: Binding;
        constructor() {
          __publicField(this, "bindingMap_");
          this.bindingMap_ = new MultiMap();
        }
        /**
         * Detaches all event listeners.
         * @override
         */
        destroy() {
          this.removeAll();
          this.bindingMap_ = null;
        }
        /**
         * Attaches an event listener to an event target.
         * @param target - The event target.
         * @param type  - The event type.
         * @param listener  - The event listener.
         */
        on(target, type, listener) {
          if (!this.bindingMap_)
            return;
          let binding = new Binding_(target, type, listener);
          this.bindingMap_.push(type, binding);
          return this;
        }
        /**
         * Attaches an event listener to an event target.
         * The listener will be removed when the first instance of the event is fired.
         * @param {EventTarget} target The event target.
         * @param {string} type The event type.
         * @param {function} listener The event listener.
         */
        once(target, type, listener) {
          this.on(target, type, (function(event) {
            this.off(target, type);
            listener(event);
          }).bind(this));
        }
        /**
         * Detaches an event listener from an event target.
         * @param {EventTarget} target The event target.
         * @param {string} type The event type.
         */
        off(target, type) {
          if (!this.bindingMap_)
            return;
          let list = this.bindingMap_.get(type) || [];
          for (let i = 0; i < list.length; ++i) {
            let binding = list[i];
            if (binding.target == target) {
              binding.off();
              this.bindingMap_.remove(type, binding);
            }
          }
        }
        /**
         * Detaches all event listeners from all targets.
         */
        removeAll() {
          if (!this.bindingMap_)
            return;
          let list = this.bindingMap_.getAll();
          for (let i = 0; i < list.length; ++i) {
            list[i].off();
          }
          this.bindingMap_.clear();
        }
      }
      let global$1;
      if (typeof window === "undefined") {
        global$1 = self;
      } else {
        global$1 = window;
      }
      var global$1$1 = global$1;
      let console$1 = global$1$1.console;
      const isWorker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof importScripts != "undefined";
      const prefix = ">>>";
      class Logger2 extends EventEmitter {
        constructor() {
          super();
          __publicField(this, "MSG_NAME");
          __publicField(this, "_enable");
          this._enable = false;
        }
        get enable() {
          return this._enable;
        }
        set enable(value) {
          this._enable = value;
          this.MSG_NAME = "__log__";
        }
        log(...restArgs) {
          if (isWorker) {
            logger.emit(this.MSG_NAME, "log", [...restArgs].join(""));
          } else {
            if (this._enable) {
              console$1.log.call(console$1, prefix, ...restArgs);
            }
          }
        }
        debug(...restArgs) {
          if (isWorker) {
            logger.emit(this.MSG_NAME, "debug", [...restArgs].join(""));
          } else {
            if (this._enable && console$1.debug) {
              console$1.debug.call(console$1, prefix, ...restArgs);
            }
          }
        }
        assert(...restArgs) {
          if (this._enable && console$1.assert) {
            let condition = restArgs[0];
            let sliceArgs = Array.prototype.slice.call(restArgs, 1);
            sliceArgs.unshift(prefix);
            console$1.assert.call(console$1, condition, ...sliceArgs);
          }
        }
        warn(...restArgs) {
          if (isWorker) {
            logger.emit(this.MSG_NAME, "warn", [...restArgs].join(""));
          } else {
            if (this._enable) {
              console$1.warn.call(console$1, prefix, ...restArgs);
            }
          }
        }
        error(...restArgs) {
          if (isWorker) {
            logger.emit(this.MSG_NAME, "error", [...restArgs].join(""));
          } else {
            if (this._enable) {
              console$1.error.call(console$1, prefix, ...restArgs);
            }
          }
        }
      }
      let logger = new Logger2();
      class Stream extends EventEmitter {
        constructor() {
          super();
        }
        /**
         * connect to the next pipeline stream.
         * @param destination
         */
        pipe(destination) {
          this.on("reset", function() {
            destination.reset();
          });
          this.on("data", function(data) {
            destination.push(data);
          });
          this.on("done", function(flushSource) {
            destination.flush(flushSource);
          });
          return destination;
        }
        /**
         * detaches the next pipeline stream previously attached.
         */
        unpipe() {
          this.removeAllListeners("reset");
          this.removeAllListeners("data");
          this.removeAllListeners("done");
          return this;
        }
        /**
         * push data to current pipeline.
         * @param data
         */
        push(data, conf) {
          this.emit("data", data);
        }
        /**
         * flush current pipeline.
         * @param flushSource
         */
        flush(flushSource) {
          this.emit("done", flushSource);
        }
        reset() {
          this.emit("reset");
        }
      }
      class DemuxFacade extends Stream {
        constructor(options = {}) {
          super();
          __publicField(this, "eventManager_");
          __publicField(this, "ctx_");
          __publicField(this, "options_");
          __publicField(this, "cache_buffer_");
          if (options.debug) {
            logger.enable = true;
          }
          this.ctx_ = new Context();
          this.options_ = options;
          this.cache_buffer_ = new CacheBuffer();
        }
        listenEndStream_() {
          this.eventManager_ = new EventManager();
          this.eventManager_.on(this.endStream, "data", (data) => {
            this.emit(Events.DEMUX_DATA, data);
          }).on(this.endStream, "done", (data) => {
            this.emit(Events.DONE, data);
          }).on(this.ctx_, "error", (data) => {
            this.emit(Events.ERROR, data);
          });
        }
        /**
         * transfer data to Uint8Array
         * @param buf
         */
        constraintPushData_(buf) {
          let newBuf = null;
          if (!isArrayBuffer(buf) && !isUint8Array(buf)) {
            logger.error(`Data pushed is not an ArrayBuffer or Uint8Array: ${buf}`);
            return newBuf;
          }
          if (isArrayBuffer(buf)) {
            newBuf = new Uint8Array(buf);
          } else {
            newBuf = buf;
          }
          return newBuf;
        }
        reset() {
        }
        destroy() {
          this.unpipe();
          this.endStream.unpipe();
          this.eventManager_.removeAll();
        }
      }
      var codes;
      (function(codes2) {
        codes2[codes2["WORKER_EXCEPTION"] = 0] = "WORKER_EXCEPTION";
        codes2[codes2["WORKER_MSG_EXCEPTION"] = 1] = "WORKER_MSG_EXCEPTION";
        codes2[codes2["TS_SYNC_BYTE"] = 2] = "TS_SYNC_BYTE";
        codes2[codes2["FLV_HEAD_SIGNATURE"] = 3] = "FLV_HEAD_SIGNATURE";
        codes2[codes2["FLV_NOT_EXPECTED_ADJACENT_DATA"] = 4] = "FLV_NOT_EXPECTED_ADJACENT_DATA";
      })(codes || (codes = {}));
      var muxErrorCode = codes;
      class PATSection {
        // CRC_32: number;
        constructor(buffer) {
          // table_id: number;
          // section_syntax_indicator: number;
          // section_length: number;
          // transport_stream_id: number;
          // version_number: number;
          // current_next_indicator: number;
          // section_number: number;
          // last_section_number: number;
          // network_PID: number;
          __publicField(this, "pmtTable");
          let section_length = (buffer[1] & 15) << 8 | buffer[2];
          var n = 0, program_num;
          var len = section_length - 4 - 5;
          this.pmtTable = [];
          for (; n < len; n += 4) {
            program_num = buffer[n + 8] << 8 | buffer[n + 9];
            if (program_num == 0) {
              let network_PID = (buffer[10 + n] & 31) << 8 | buffer[11 + n];
              logger.log("packet->network_PID %0x /n/n", network_PID);
            } else {
              this.pmtTable.push({
                programNum: program_num,
                program_map_PID: (buffer[10 + n] & 31) << 8 | buffer[11 + n]
              });
            }
          }
        }
      }
      class PMTSection {
        // CRC_32: number;
        constructor(buffer) {
          // table_id: number;
          // section_syntax_indicator: number;
          // section_length: number;
          // program_number: number;
          // version_number: number;
          // current_next_indicator: number;
          // section_number: number;
          // last_section_number: number;
          // PCR_PID: number;
          __publicField(this, "pes_table");
          let section_length = (buffer[1] & 15) << 8 | buffer[2];
          const program_info_length = (buffer[10] & 15) << 8 | buffer[11];
          if (program_info_length < 0) {
            return;
          } else if (program_info_length > 2) {
            let i = 0;
            while (i < program_info_length) {
              let descriptor_length = buffer[13 + i];
              i += descriptor_length;
            }
          }
          var es_section_pos = 12 + program_info_length;
          var es_section_len = section_length - program_info_length - 9 - 4;
          var es_section_end = es_section_pos + es_section_len;
          if (es_section_pos >= es_section_end) {
            logger.warn(`es_section_pos < es_section_end ${es_section_pos}, ${es_section_end}`);
            return;
          }
          this.pes_table = [];
          let j = 0;
          while (j < es_section_len) {
            let basePos = es_section_pos + j;
            let stream_type = buffer[basePos];
            let elementary_PID = (buffer[basePos + 1] << 8 | buffer[basePos + 2]) & 8191;
            let ES_info_length = (buffer[basePos + 3] << 8 | buffer[basePos + 4]) & 4095;
            this.pes_table.push({
              streamType: stream_type,
              PID: elementary_PID
            });
            j += ES_info_length + 5;
          }
        }
      }
      const PAT_PID = 0;
      const CAT_PID = 1;
      const TSDT_PID = 2;
      const SDT_PID = 17;
      class PSI {
        constructor() {
          // private context: AVFormatContext;
          // private metadata: Metadata; // Specify by SDT Packet
          __publicField(this, "pat_table");
          // Specify by PMT Packet
          __publicField(this, "pes_streams");
          this.pat_table = [];
          this.pes_streams = [];
        }
        // Specify by PES stream
        /**
         * program PID
         */
        get currentProgramPID() {
          let _pmtIds = [];
          for (let i = 0; i < this.pat_table.length; i++) {
            _pmtIds.push(this.pat_table[i].pid);
          }
          return _pmtIds.length > 0 ? _pmtIds[0] : -1;
        }
        get tracks() {
          return this.pes_streams;
        }
        // get pmtTable() {
        //     return this.pat_table;
        // }
        /**
         * 目前对于PSI的信息，持久化保留在内存中
         * 对于同一个片子，HLS规范会规定只能有一个 PMT/PAT 表
         * 所以一部片子的PSI信息应该是保持不变的，换片子后PSI信息的销毁通过 mux 重新实例化产生新的信息，不需要调用reset
         * 有些 TS 文件在HLS切片器切割的时候，没有带上PAT/PMT等表，需要相邻 TS 给定的表信息
         */
        reset() {
          this.pat_table.splice(0, this.pat_table.length);
          this.pes_streams.splice(0, this.pes_streams.length);
        }
        /**
         * @param packet
         */
        parse(packet) {
          const self2 = this;
          if (PAT_PID === packet.PID) {
            this._parsePat(packet);
          } else if (CAT_PID === packet.PID) ;
          else if (TSDT_PID === packet.PID) ;
          else if (3 <= packet.PID && packet.PID <= 15) ;
          else if (SDT_PID === packet.PID) ;
          else if (packet.PID === self2.currentProgramPID) {
            this._parsePmt(packet);
          }
        }
        // findPmtProgram(PID) {
        // 	let program = null;
        //
        // 	for (let i = 0; i < this.pat_table.length; i++) {
        // 		if (this.pat_table[i].pid === PID) {
        // 			program = this.pat_table[i].id;
        // 			break;
        // 		}
        // 	}
        //
        // 	return program;
        // }
        /**
         * @param PID
         */
        findTrack(PID) {
          let program = null;
          let streams = this.pes_streams;
          for (let i = 0; i < streams.length; i++) {
            if (streams[i].id === PID) {
              program = streams[i];
              break;
            }
          }
          return program;
        }
        /**
         * Parse PAT Packet
         * @param pack
         */
        _parsePat(pack) {
          let data;
          if (pack.payload_unit_start_indicator) {
            let pointer = pack.payload[0];
            data = pack.payload.subarray(pointer + 1);
          } else {
            data = pack.payload;
          }
          let pat = new PATSection(data);
          for (var i = 0; i < pat.pmtTable.length; i++) {
            this._add_pid_to_pmt(pat.pmtTable[i].programNum, pat.pmtTable[i].program_map_PID);
          }
          return pat;
        }
        /**
         * Associates Program Number and Program Map Table(PMT) PID
         * @param programId
         * @param pid
         */
        _add_pid_to_pmt(programId, pid) {
          let table = this.pat_table;
          function get_pmt(id) {
            for (let i = 0, item; i < table.length; i++) {
              item = table[i];
              if (item.id === id) {
                return {
                  idx: i,
                  item
                };
              }
            }
            return null;
          }
          let p = get_pmt(programId);
          if (!p) {
            table.push({
              id: programId,
              pid
            });
          }
        }
        /**
         * Parse PMT Packet
         * @param pack
         */
        _parsePmt(pack) {
          let data;
          if (pack.payload_unit_start_indicator) {
            let pointer = pack.payload[0];
            data = pack.payload.subarray(pointer + 1);
          } else {
            data = pack.payload;
          }
          let pmt = new PMTSection(data);
          for (var i = 0; i < pmt.pes_table.length; i++) {
            this._add_pes_stream(pmt.pes_table[i]);
          }
          return pmt;
        }
        /**
         * @param stream
         * @param pmt
         */
        _add_pes_stream(stream) {
          let streams = this.pes_streams;
          function get_program(id) {
            for (let i = 0, item; i < streams.length; i++) {
              item = streams[i];
              if (item.id === id) {
                return {
                  idx: i,
                  item
                };
              }
            }
            return null;
          }
          let p = get_program(stream.PID);
          if (!p) {
            streams.push({
              id: stream.PID,
              stream_type: stream.streamType,
              duration: 0,
              sps: [],
              pps: [],
              pixelRatio: [1, 1],
              timescale: 9e4,
              width: 0,
              height: 0
            });
          }
        }
      }
      class M2TSComplexStream extends Stream {
        constructor(ctx, psi) {
          super();
          this.context = ctx;
          this.PSI = psi;
          this.videoTrack = null;
          this.audioTrack = null;
          this.captionTrack = null;
        }
        push(data) {
          let tracks = data;
          for (let i = 0, track; i < tracks.length; i++) {
            track = tracks[i];
            switch (track.type) {
              case "video":
                this._complexVideo(track);
                break;
              case "audio":
                this._complexAudio(track);
                break;
              case "caption":
                this._complexCaption(track);
                break;
            }
          }
        }
        flush() {
          this.emit("done");
          this._clearStream();
        }
        reset() {
          this._clearStream();
        }
        _clearStream() {
          this.videoTrack = null;
          this.audioTrack = null;
          this.captionTrack = null;
        }
        _complexVideo(gops) {
          let track = this.PSI.findTrack(gops.trackId);
          if (track) {
            track.type = "video";
            track.gops = gops;
            track.firstDTS = gops[0][0].dts;
            track.firstPTS = gops[0][0].pts;
            track.duration = Number.POSITIVE_INFINITY;
            this.videoTrack = track;
            this.emit("data", {
              videoTrack: this.videoTrack
            });
          }
        }
        _complexAudio(frames) {
          let track = this.PSI.findTrack(frames.trackId);
          if (track) {
            track.type = "audio";
            track.frames = frames;
            track.firstPTS = track.firstDTS = frames[0].dts;
            track.duration = Number.POSITIVE_INFINITY;
            this.audioTrack = track;
            this.emit("data", {
              audioTrack: this.audioTrack
            });
          }
        }
        _complexCaption() {
        }
      }
      const os = {
        mac: false,
        iphone: false,
        android: false
      };
      const browser = {
        version: false,
        CHROME: false,
        SAFARI: false,
        FIREFOX: false,
        IE11: false,
        IE: false,
        EDGE: false,
        WECHAT: false
      };
      let nav = navigator;
      let ua = nav.userAgent.toLowerCase();
      var match = /(edge)\/([\w.]+)/.exec(ua) || /(opr)[/]([\w.]+)/.exec(ua) || /(chrome)[ /]([\w.]+)/.exec(ua) || /(firefox)[ /]([\w.]+)/.exec(ua) || /(iemobile)[/]([\w.]+)/.exec(ua) || /(version)(applewebkit)[ /]([\w.]+).*(safari)[ /]([\w.]+)/.exec(ua) || /(webkit)[ /]([\w.]+).*(version)[ /]([\w.]+).*(safari)[ /]([\w.]+)/.exec(ua) || /(webkit)[ /]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ /]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
      var platform_match = /(ipad)/.exec(ua) || /(ipod)/.exec(ua) || /(windows phone)/.exec(ua) || /(iphone)/.exec(ua) || /(kindle)/.exec(ua) || /(silk)/.exec(ua) || /(android)/.exec(ua) || /(win)/.exec(ua) || /(mac)/.exec(ua) || /(linux)/.exec(ua) || /(cros)/.exec(ua) || /(playbook)/.exec(ua) || /(bb)/.exec(ua) || /(blackberry)/.exec(ua) || [];
      var result = {
        version: void 0
      };
      var matched = {
        browser: match[5] || match[3] || match[1] || "",
        version: match[2] || match[4] || "0",
        versionNumber: match[4] || match[2] || "0",
        platform: platform_match[0] || ""
      };
      if (matched.browser) {
        result[matched.browser] = true;
        let versionArray = matched.versionNumber.split(".");
        result.version = {
          major: parseInt(matched.versionNumber, 10),
          string: matched.version
        };
        if (versionArray.length > 1) {
          result.version.minor = parseInt(versionArray[1], 10);
        }
        if (versionArray.length > 2) {
          result.version.build = parseInt(versionArray[2], 10);
        }
      }
      browser.version = result.version;
      browser.CHROME = !!result["chrome"];
      browser.SAFARI = !!result["safari"] && !browser.CHROME;
      browser.FIREFOX = !!result["firefox"];
      browser.IE11 = /rv:11/.test(ua);
      browser.IE = !!result["msie"] || browser.IE11;
      browser.EDGE = !!result["edge"];
      browser.WECHAT = /(wechat)|(micromessenger)/.test(ua);
      os.mac = !!matched.platform["mac"];
      os.iphone = !!matched.platform["iphone"];
      os.android = !!matched.platform["android"];
      var platform = {
        browser,
        os
      };
      const samplingRates = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
      var getAudioConfig = (audioObjectType, samplingFrequencyIndex, channelCount) => {
        let adtsExtensionSamplingIndex;
        let realAudioObjectType = audioObjectType;
        let config;
        if (samplingFrequencyIndex > samplingRates.length - 1) {
          logger.error(`invalid sampling index:${samplingFrequencyIndex}`);
          return;
        }
        if (platform.browser.FIREFOX) {
          if (samplingFrequencyIndex >= 6) {
            audioObjectType = 5;
            config = new Array(4);
            adtsExtensionSamplingIndex = samplingFrequencyIndex - 3;
          } else {
            audioObjectType = 2;
            config = new Array(2);
            adtsExtensionSamplingIndex = samplingFrequencyIndex;
          }
        } else if (platform.os.android) {
          audioObjectType = 2;
          config = new Array(2);
          adtsExtensionSamplingIndex = samplingFrequencyIndex;
        } else {
          audioObjectType = 5;
          config = new Array(4);
          if (samplingFrequencyIndex >= 6) {
            adtsExtensionSamplingIndex = samplingFrequencyIndex - 3;
          } else {
            if (channelCount === 1) {
              audioObjectType = 2;
              config = new Array(2);
            }
            adtsExtensionSamplingIndex = samplingFrequencyIndex;
          }
        }
        config[0] = audioObjectType << 3;
        config[0] |= (samplingFrequencyIndex & 14) >> 1;
        config[1] |= (samplingFrequencyIndex & 1) << 7;
        config[1] |= channelCount << 3;
        if (audioObjectType === 5) {
          config[1] |= (adtsExtensionSamplingIndex & 14) >> 1;
          config[2] = (adtsExtensionSamplingIndex & 1) << 7;
          config[2] |= 2 << 2;
          config[3] = 0;
        }
        return {
          config,
          sampleRate: samplingRates[samplingFrequencyIndex],
          channelCount,
          codec: "mp4a.40." + audioObjectType,
          realCodec: "mp4a.40." + realAudioObjectType
        };
      };
      const AAC_SAMPLING_FREQUENCIES = [
        96e3,
        88200,
        64e3,
        48e3,
        44100,
        32e3,
        24e3,
        22050,
        16e3,
        12e3,
        11025,
        8e3,
        7350
      ];
      class ADTSCodec extends EventEmitter {
        constructor() {
          super();
        }
        push(data) {
          let { pts, dts, payload } = data;
          let data_byte = payload;
          let i = 0, frameNum = 0, frameLength, protectionSkipBytes, frameEnd, sampleCount, adtsFrameDuration;
          while (i + 5 < data_byte.length) {
            if (data_byte[i] !== 255 || (data_byte[i + 1] & 246) !== 240) {
              i++;
              continue;
            }
            protectionSkipBytes = (~data_byte[i + 1] & 1) * 2;
            frameLength = (data_byte[i + 3] & 3) << 11 | data_byte[i + 4] << 3 | (data_byte[i + 5] & 224) >> 5;
            sampleCount = ((data_byte[i + 6] & 3) + 1) * 1024;
            adtsFrameDuration = sampleCount * 9e4 / AAC_SAMPLING_FREQUENCIES[(data_byte[i + 2] & 60) >>> 2];
            frameEnd = i + frameLength;
            if (data_byte.byteLength < frameEnd) {
              return;
            }
            let aacFrame = {
              pts: pts + frameNum * adtsFrameDuration,
              dts: dts + frameNum * adtsFrameDuration,
              sampleCount,
              audioObjectType: (data_byte[i + 2] >>> 6 & 3) + 1,
              channelCount: (data_byte[i + 2] & 1) << 2 | (data_byte[i + 3] & 192) >>> 6,
              sampleRate: AAC_SAMPLING_FREQUENCIES[(data_byte[i + 2] & 60) >>> 2],
              samplingFrequencyIndex: (data_byte[i + 2] & 60) >>> 2,
              // assume ISO/IEC 14496-12 AudioSampleEntry default of 16
              sampleSize: 16,
              data: data_byte.subarray(i + 7 + protectionSkipBytes, frameEnd)
            };
            this.emit("frame", aacFrame);
            if (data_byte.byteLength === frameEnd) {
              data_byte = void 0;
              this.emit("done");
              return;
            }
            frameNum++;
            data_byte = data_byte.subarray(frameEnd);
          }
        }
      }
      class ADTSStream extends Stream {
        constructor(psi) {
          super();
          __publicField(this, "PSI");
          __publicField(this, "trackId");
          __publicField(this, "codec");
          __publicField(this, "frames");
          this.PSI = psi;
          this.trackId = null;
          this.codec = new ADTSCodec();
          this.codec.on("frame", (frame) => {
            this.frames.push(frame);
            this.frames.byteLength += frame.data.byteLength;
            this.frames.trackId = this.trackId;
          });
          this._newFrames();
        }
        push(data) {
          if (data.stream_type === 15) {
            this.trackId = data.pid;
            this.codec.push({
              dts: data.pes.DTS,
              pts: data.pes.PTS,
              payload: data.pes.data_byte
            });
          }
        }
        flush() {
          if (this.frames.length > 0) {
            let count = this.frames.length;
            let firstFrame = this.frames[0];
            let lastFrame = this.frames[count - 1];
            let lastDuration = lastFrame.sampleRate * lastFrame.sampleCount / 9e4;
            this.frames.firstDTS = firstFrame.dts;
            this.frames.firstPTS = firstFrame.pts;
            if (count === 1) {
              this.frames.duration = lastDuration;
            } else {
              this.frames.duration = lastDuration + (lastFrame.pts - firstFrame.pts);
            }
            this._updateTrackMeta(firstFrame);
            this.emit("data", this.frames);
            this.reset();
            this.emit("done");
          }
        }
        reset() {
          this.trackId = null;
          this._newFrames();
        }
        _newFrames() {
          this.frames = [];
          this.frames.type = "audio";
          this.frames.byteLength = 0;
          this.frames.duration = 0;
          this.frames.firstDTS = 0;
          this.frames.firstPTS = 0;
        }
        /**
         * @param {Object} frame
         */
        _updateTrackMeta(frame) {
          let track = this.PSI.findTrack(this.trackId);
          let config = getAudioConfig(frame.audioObjectType, frame.samplingFrequencyIndex, frame.channelCount);
          track.config = config.config;
          track.sampleRate = config.sampleRate;
          track.inputTimeScale = track.inputTimeScale || track.timescale;
          track.timescale = config.sampleRate;
          track.channelCount = config.channelCount;
          track.codec = config.codec;
          track.realCodec = config.realCodec;
          track.isAAC = true;
        }
      }
      function read(buf) {
        let byteOffset = 0;
        if (ArrayBuffer.isView(buf)) {
          byteOffset = buf.byteOffset;
          buf = buf.buffer;
        }
        return new DataView(buf, byteOffset);
      }
      class DataViewReader {
        constructor() {
        }
        /**
         * Gets an unsigned 8-bit integer (unsigned byte).
         * @param buffer
         * @param byteOffset    The offset, in byte, from the start of the view where to read the data.
         * @returns {number}    An unsigned 8-bit integer number.
         */
        readUint8(buffer, byteOffset) {
          return read(buffer).getUint8(byteOffset);
        }
        /**
         * Gets an unsigned 16-bit integer (unsigned long).
         * @param buffer
         * @param byteOffset     The offset, in byte, from the start of the view where to read the data.
         * @param littleEndian   Indicates whether the 16-bit int is stored in little- or big-endian format.
         * @returns {number}     An unsigned 16-bit integer number.
         */
        readUint16(buffer, byteOffset, littleEndian = false) {
          return read(buffer).getUint16(byteOffset, littleEndian);
        }
        /**
         * Gets an unsigned 32-bit integer (unsigned long).
         * @param buffer
         * @param byteOffset        The offset, in byte, from the start of the view where to read the data.
         * @param littleEndian      Indicates whether the 32-bit int is stored in little- or big-endian format.
         * @returns {number}        An unsigned 32-bit integer number.
         */
        readUint32(buffer, byteOffset, littleEndian = false) {
          return read(buffer).getUint32(byteOffset, littleEndian);
        }
      }
      function discardEP3B(data) {
        let length = data.byteLength, emulationPreventionBytesPositions = [], i = 1, newLength, newData = new Uint8Array(0);
        while (i < length - 2) {
          if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
            emulationPreventionBytesPositions.push(i + 2);
            i += 2;
          } else {
            i++;
          }
        }
        if (emulationPreventionBytesPositions.length === 0) {
          return data;
        }
        newLength = length - emulationPreventionBytesPositions.length;
        try {
          newData = new Uint8Array(newLength);
        } catch (e) {
          throw `epsb alloc mem error ${newLength}`;
        }
        let sourceIndex = 0;
        for (i = 0; i < newLength; sourceIndex++, i++) {
          if (sourceIndex === emulationPreventionBytesPositions[0]) {
            sourceIndex++;
            emulationPreventionBytesPositions.shift();
          }
          newData[i] = data[sourceIndex];
        }
        return newData;
      }
      function readBit(buffer, bitOffset2 = 0, length = 1) {
        let startByte = 0;
        let startByteBitPos = 0;
        let val = 0;
        let bitStr = "", bitVal = 0;
        for (let j = bitOffset2; j < bitOffset2 + length; j++) {
          startByte = Math.floor(j / 8);
          startByteBitPos = 7 - j % 8;
          bitVal = buffer[startByte] >> startByteBitPos & 1;
          bitStr += bitVal;
        }
        val = parseInt(bitStr, 2);
        return val;
      }
      function readByte(buffer, bitOffset2 = 0) {
        return readBit(buffer, bitOffset2, 8);
      }
      function readUEV(buffer, bitOffset2 = 0) {
        let leadingZeros = [];
        let bitLength = buffer.byteLength * 8;
        let readBit1 = false;
        let startByte = 0;
        let startByteBitPos = 0;
        let bitVal = 0;
        let value = "";
        for (let i = bitOffset2; i < bitLength; i++) {
          startByte = Math.floor(i / 8);
          startByteBitPos = 7 - i % 8;
          bitVal = buffer[startByte] >> startByteBitPos & 1;
          if (!readBit1) {
            if (bitVal === 0) {
              leadingZeros.push(0);
            } else {
              readBit1 = true;
              bitOffset2 = i;
              break;
            }
          }
        }
        let codeNumLength = leadingZeros.length + 1;
        for (let j = bitOffset2; j < bitOffset2 + codeNumLength; j++) {
          startByte = Math.floor(j / 8);
          startByteBitPos = 7 - j % 8;
          bitVal = buffer[startByte] >> startByteBitPos & 1;
          value += bitVal;
        }
        return {
          bitLength: leadingZeros.length + codeNumLength,
          value: parseInt(value, 2) - 1
        };
      }
      function readSEV(buffer, bitOffset2 = 0) {
        let uev = readUEV(buffer, bitOffset2);
        let codeNum = uev.value;
        let signedValue = Math.pow(-1, codeNum + 1) * Math.ceil(codeNum / 2);
        return {
          bitLength: uev.bitLength,
          value: signedValue
        };
      }
      var ExpGolomb = {
        readUEV,
        readSEV,
        readBit,
        readByte
      };
      let bitOffset = 0;
      function scaling_list(scalingList, size) {
        let lastScale = 8;
        let nextScale = 8;
        let delta_scale;
        for (var j = 0; j < size; j++) {
          if (nextScale != 0) {
            delta_scale = ExpGolomb.readUEV(scalingList, bitOffset);
            bitOffset += delta_scale.bitLength;
            nextScale = (lastScale + delta_scale.value + 256) % 256;
          }
          lastScale = scalingList[j];
        }
      }
      function decodeSPS(payload) {
        bitOffset = 0;
        let profile_idc = payload[0];
        let profile_compatibility = payload[1];
        let level_idc = payload[2];
        let golombBuffer = payload.subarray(3);
        let seq_scaling_matrix_present_flag = 0;
        let lmpoclmUEV;
        let ofnrpSEV, ofttbfSEV, nrfipoccUEV;
        let pixelRatio = [1, 1], pixelScale = 1;
        let video_format;
        let fps = 0, num_units_in_tick, time_scale, fixed_frame_rate_flag = true;
        let spsUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
        bitOffset += spsUEV.bitLength;
        if (profile_idc == 100 || profile_idc == 110 || profile_idc == 122 || profile_idc == 244 || profile_idc == 44 || profile_idc == 83 || profile_idc == 86 || profile_idc == 118 || profile_idc == 128) {
          let chromaFIUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
          bitOffset += chromaFIUEV.bitLength;
          if (chromaFIUEV.value == 3) {
            bitOffset += 1;
          }
          let bitdlmUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
          bitOffset += bitdlmUEV.bitLength;
          let bitdcmUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
          bitOffset += bitdcmUEV.bitLength;
          bitOffset += 1;
          seq_scaling_matrix_present_flag = ExpGolomb.readBit(golombBuffer, bitOffset);
          bitOffset += 1;
          if (seq_scaling_matrix_present_flag) {
            for (let i = 0; i < (chromaFIUEV.value != 3 ? 8 : 12); i++) {
              let seq_scaling_list_present_flag = ExpGolomb.readBit(golombBuffer, bitOffset);
              bitOffset += 1;
              if (seq_scaling_list_present_flag) {
                if (i < 6) {
                  scaling_list(golombBuffer, 16);
                } else {
                  scaling_list(golombBuffer, 64);
                }
              }
            }
          }
        }
        let lmfnmUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
        bitOffset += lmfnmUEV.bitLength;
        let poctUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
        let pic_order_cnt_type = poctUEV.value;
        bitOffset += poctUEV.bitLength;
        if (pic_order_cnt_type === 0) {
          lmpoclmUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
          bitOffset += lmpoclmUEV.bitLength;
        } else if (pic_order_cnt_type === 1) {
          bitOffset += 1;
          ofnrpSEV = ExpGolomb.readSEV(golombBuffer, bitOffset);
          bitOffset += ofnrpSEV.bitLength;
          ofttbfSEV = ExpGolomb.readSEV(golombBuffer, bitOffset);
          bitOffset += ofttbfSEV.bitLength;
          nrfipoccUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
          bitOffset += nrfipoccUEV.bitLength;
          for (let i = 0, item; i < nrfipoccUEV.value; i++) {
            item = ExpGolomb.readSEV(golombBuffer, bitOffset);
            bitOffset += item.bitLength;
          }
        }
        let mnrfUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
        bitOffset += mnrfUEV.bitLength;
        bitOffset += 1;
        let picWidthUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
        bitOffset += picWidthUEV.bitLength;
        let picHeightUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
        bitOffset += picHeightUEV.bitLength;
        let frame_mbs_only_flag = ExpGolomb.readBit(golombBuffer, bitOffset);
        bitOffset += 1;
        if (!frame_mbs_only_flag) {
          bitOffset += 1;
        }
        bitOffset += 1;
        let frame_cropping_flag = ExpGolomb.readBit(golombBuffer, bitOffset);
        bitOffset += 1;
        let cropLeft = 0, cropRight = 0, cropTop = 0, cropBottom = 0;
        if (frame_cropping_flag) {
          let fcloUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
          bitOffset += fcloUEV.bitLength;
          cropLeft = fcloUEV.value;
          let fcroUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
          bitOffset += fcroUEV.bitLength;
          cropRight = fcroUEV.value;
          let fctoUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
          bitOffset += fctoUEV.bitLength;
          cropTop = fctoUEV.value;
          let fcboUEV = ExpGolomb.readUEV(golombBuffer, bitOffset);
          bitOffset += fcboUEV.bitLength;
          cropBottom = fcboUEV.value;
        }
        let vui_parameters_present_flag = ExpGolomb.readBit(golombBuffer, bitOffset);
        bitOffset += 1;
        if (vui_parameters_present_flag) {
          let aspect_ratio_info_present_flag = ExpGolomb.readBit(golombBuffer, bitOffset);
          bitOffset += 1;
          if (aspect_ratio_info_present_flag) {
            const aspectRatioIdc = ExpGolomb.readByte(golombBuffer, bitOffset);
            bitOffset += 8;
            switch (aspectRatioIdc) {
              case 1:
                pixelRatio = [1, 1];
                break;
              case 2:
                pixelRatio = [12, 11];
                break;
              case 3:
                pixelRatio = [10, 11];
                break;
              case 4:
                pixelRatio = [16, 11];
                break;
              case 5:
                pixelRatio = [40, 33];
                break;
              case 6:
                pixelRatio = [24, 11];
                break;
              case 7:
                pixelRatio = [20, 11];
                break;
              case 8:
                pixelRatio = [32, 11];
                break;
              case 9:
                pixelRatio = [80, 33];
                break;
              case 10:
                pixelRatio = [18, 11];
                break;
              case 11:
                pixelRatio = [15, 11];
                break;
              case 12:
                pixelRatio = [64, 33];
                break;
              case 13:
                pixelRatio = [160, 99];
                break;
              case 14:
                pixelRatio = [4, 3];
                break;
              case 15:
                pixelRatio = [3, 2];
                break;
              case 16:
                pixelRatio = [2, 1];
                break;
              case 255: {
                let width0 = ExpGolomb.readByte(golombBuffer, bitOffset);
                bitOffset += 8;
                let width1 = ExpGolomb.readByte(golombBuffer, bitOffset);
                bitOffset += 8;
                let height0 = ExpGolomb.readByte(golombBuffer, bitOffset);
                bitOffset += 8;
                let height1 = ExpGolomb.readByte(golombBuffer, bitOffset);
                bitOffset += 8;
                pixelRatio = [width0 << 8 | width1, height0 << 8 | height1];
                break;
              }
            }
            if (pixelRatio) {
              pixelScale = pixelRatio[0] / pixelRatio[1];
            }
            if (aspectRatioIdc === 255) {
              bitOffset += 16;
              bitOffset += 16;
            }
          }
          let overscan_info_present_flag = ExpGolomb.readBit(golombBuffer, bitOffset);
          bitOffset += 1;
          if (overscan_info_present_flag) {
            bitOffset += 1;
          }
          let video_signal_type_present_flag = ExpGolomb.readBit(golombBuffer, bitOffset);
          bitOffset += 1;
          if (video_signal_type_present_flag) {
            video_format = ExpGolomb.readBit(golombBuffer, bitOffset, 3);
            bitOffset += 3;
            bitOffset += 1;
            let colour_description_present_flag = ExpGolomb.readBit(golombBuffer, bitOffset);
            bitOffset += 1;
            if (colour_description_present_flag) {
              bitOffset += 24;
            }
          }
          let chroma_loc_info_present_flag = ExpGolomb.readBit(golombBuffer, bitOffset);
          bitOffset += 1;
          if (chroma_loc_info_present_flag) {
            let chroma_sample_loc_type_top_field = ExpGolomb.readUEV(golombBuffer, bitOffset);
            bitOffset += chroma_sample_loc_type_top_field.bitLength;
            let chroma_sample_loc_type_bottom_field = ExpGolomb.readUEV(golombBuffer, bitOffset);
            bitOffset += chroma_sample_loc_type_bottom_field.bitLength;
          }
          let timing_info_present_flag = ExpGolomb.readBit(golombBuffer, bitOffset);
          bitOffset += 1;
          if (timing_info_present_flag) {
            num_units_in_tick = ExpGolomb.readBit(golombBuffer, bitOffset, 32);
            bitOffset += 32;
            time_scale = ExpGolomb.readBit(golombBuffer, bitOffset, 32);
            bitOffset += 32;
            fixed_frame_rate_flag = !!ExpGolomb.readBit(golombBuffer, bitOffset);
            bitOffset += 1;
            fps = time_scale / (num_units_in_tick * 2);
          }
        }
        return {
          payload: golombBuffer,
          profile_idc,
          profile_compatibility,
          level_idc,
          sps_id: spsUEV.value,
          log2_max_frame_num_minus4: poctUEV.value,
          pic_order_cnt_type,
          log2_max_pic_order_cnt_lsb_minus4: lmpoclmUEV ? lmpoclmUEV.value : 0,
          width: Math.ceil(((picWidthUEV.value + 1) * 16 - cropLeft * 2 - cropRight * 2) * pixelScale),
          height: (2 - frame_mbs_only_flag) * (picHeightUEV.value + 1) * 16 - cropTop * 2 - cropBottom * 2,
          pixelRatio,
          video_format,
          fps,
          fixedFPS: fixed_frame_rate_flag
        };
      }
      function decodePPS(payload) {
        let bitOffset2 = 0;
        let golombBuffer = payload;
        let sliceGroupIds = [];
        let sgcdfUEV, picSizeUEV;
        let i = 0;
        let ppsUEV = ExpGolomb.readUEV(golombBuffer, bitOffset2);
        bitOffset2 += ppsUEV.bitLength;
        let spsUEV = ExpGolomb.readUEV(golombBuffer, bitOffset2);
        bitOffset2 += spsUEV.bitLength;
        bitOffset2 += 1;
        bitOffset2 += 1;
        let sliceGroupUEV = ExpGolomb.readUEV(golombBuffer, bitOffset2);
        bitOffset2 += sliceGroupUEV.bitLength;
        if (sliceGroupUEV.value > 0) {
          let sgmtUEV = ExpGolomb.readUEV(golombBuffer, bitOffset2);
          bitOffset2 += sgmtUEV.bitLength;
          let iGroup = 0, itemUev;
          switch (sgmtUEV.value) {
            case 0:
              for (iGroup = 0; iGroup <= sgmtUEV.value; iGroup++) {
                itemUev = ExpGolomb.readUEV(golombBuffer, bitOffset2);
                bitOffset2 += itemUev.bitLength;
              }
              break;
            case 2:
              for (iGroup = 0; iGroup <= sgmtUEV.value; iGroup++) {
                itemUev = ExpGolomb.readUEV(golombBuffer, bitOffset2);
                bitOffset2 += itemUev.bitLength;
                itemUev = ExpGolomb.readUEV(golombBuffer, bitOffset2);
                bitOffset2 += itemUev.bitLength;
              }
              break;
            case 3:
            case 4:
            case 5:
              bitOffset2 += 1;
              sgcdfUEV = ExpGolomb.readUEV(golombBuffer, bitOffset2);
              bitOffset2 += sgcdfUEV.bitLength;
              break;
            case 6:
              {
                picSizeUEV = ExpGolomb.readUEV(golombBuffer, bitOffset2);
                bitOffset2 += picSizeUEV.bitLength;
                let length = Math.ceil(Math.log2(sliceGroupUEV.value + 1));
                for (i = 0; i <= picSizeUEV.value; i++) {
                  sliceGroupIds.push(ExpGolomb.readBit(golombBuffer, bitOffset2, length));
                  bitOffset2 += length;
                }
              }
              break;
          }
        }
        let nril0dcmUEV = ExpGolomb.readUEV(golombBuffer, bitOffset2);
        bitOffset2 += nril0dcmUEV.bitLength;
        let nril1dcmUEV = ExpGolomb.readUEV(golombBuffer, bitOffset2);
        bitOffset2 += nril1dcmUEV.bitLength;
        bitOffset2 += 1;
        bitOffset2 += 1;
        let piqpSEV = ExpGolomb.readSEV(golombBuffer, bitOffset2);
        bitOffset2 += piqpSEV.bitLength;
        let piqsSEV = ExpGolomb.readSEV(golombBuffer, bitOffset2);
        bitOffset2 += piqsSEV.bitLength;
        let cqioSEV = ExpGolomb.readSEV(golombBuffer, bitOffset2);
        bitOffset2 += cqioSEV.bitLength;
        bitOffset2 += 1;
        bitOffset2 += 1;
        bitOffset2 += 1;
        return {
          sliceGroupNum: sliceGroupUEV.value + 1
        };
      }
      function decodeSEI(payload) {
        return {};
      }
      function _decodeAUD(payload) {
        return payload[0] >> 5;
      }
      class NALU extends DataViewReader {
        constructor(buffer) {
          super();
          __publicField(this, "forbidden_zero_bit");
          __publicField(this, "ref_idc");
          __publicField(this, "unit_type");
          __publicField(this, "data");
          __publicField(this, "rawData");
          __publicField(this, "sps");
          __publicField(this, "pps");
          __publicField(this, "sei");
          __publicField(this, "primary_pic_type");
          __publicField(this, "pts");
          __publicField(this, "dts");
          this.forbidden_zero_bit = buffer[0] >> 7;
          this.ref_idc = buffer[0] >> 5 & 3;
          this.unit_type = buffer[0] & 31;
          this.data = discardEP3B(buffer.subarray(1));
          this.rawData = buffer;
          switch (this.unit_type) {
            case 1:
              break;
            case 2:
            case 3:
            case 4:
              break;
            case 5:
              break;
            case 7:
              this.sps = decodeSPS(this.data);
              break;
            case 8:
              this.pps = decodePPS(this.data);
              break;
            case 6:
              this.sei = decodeSEI(this.data);
              break;
            case 9:
              this.primary_pic_type = _decodeAUD(this.data);
              break;
          }
        }
      }
      class AVCCodec extends EventEmitter {
        constructor() {
          super(...arguments);
          __publicField(this, "lastState", null);
          __publicField(this, "lastNALu", null);
          __publicField(this, "lastNALuState", null);
        }
        spitNalu_(bytes, pts, dts) {
          let nalu = new NALU(bytes);
          nalu.pts = pts;
          nalu.dts = dts;
          this.lastNALu = nalu;
          this.emit("nalu", nalu);
        }
        push(data) {
          const { lastState, lastNALuState } = this;
          let i = 0, lastNALuOffset = -1, { pts, dts, payload, naluSizeLength } = data;
          if (!naluSizeLength) {
            let j = payload.byteLength - 1;
            let dropZerosLength = 0;
            do {
              if (payload[j] === 0) {
                dropZerosLength++;
              } else {
                break;
              }
              j--;
            } while (j > 0);
            if (dropZerosLength >= 3) {
              payload = payload.subarray(0, j + 1);
            }
            const len = payload.length;
            let state = 0;
            do {
              let value = payload[i++];
              if (state === 0) {
                state = value ? 0 : 1;
                continue;
              } else if (state === 1) {
                state = value ? 0 : 2;
                continue;
              }
              if (!value) {
                state = 3;
              } else if (value === 1) {
                if (lastNALuOffset >= 0) {
                  this.lastNALuState = state;
                  this.spitNalu_(payload.subarray(lastNALuOffset, i - 1 - state), pts, dts);
                } else {
                  const lastUnit = this.lastNALu;
                  if (lastUnit) {
                    if (lastState && i <= 4 - lastState) {
                      if (lastNALuState) {
                        lastUnit.rawData = lastUnit.rawData.subarray(0, lastUnit.rawData.byteLength - lastState);
                      }
                    }
                    let overflow = i - state - 1;
                    if (overflow > 0) {
                      logger.log(`overflow NALU found: ${overflow}/${pts}/${dts}`);
                      let cb = new CacheBuffer();
                      cb.append(lastUnit.rawData);
                      cb.append(payload.subarray(0, overflow));
                      let bytes = cb.toNewBytes();
                      cb.clear();
                      lastUnit.rawData = bytes;
                    }
                  }
                }
                if (i < len) {
                  lastNALuOffset = i;
                  state = 0;
                }
              } else {
                state = 0;
              }
            } while (i < len);
            if (lastNALuOffset >= 0 && state >= 0) {
              this.lastNALuState = state;
              this.spitNalu_(payload.subarray(lastNALuOffset, len), pts, dts);
            }
            this.lastState = state;
          } else {
            let startPos = 0, size = 0, endPos = 0, byteLength = payload.length;
            do {
              size = 0;
              for (let k = 0; k < naluSizeLength; k++) {
                size = size | payload[startPos + k] << (naluSizeLength - k - 1) * 8;
              }
              startPos += naluSizeLength;
              endPos = startPos + size;
              if (endPos > byteLength) {
                endPos = byteLength;
              }
              this.spitNalu_(payload.subarray(startPos, endPos), pts, dts);
              startPos = endPos;
            } while (startPos < byteLength);
          }
          this.emit("done");
        }
        reset() {
          this.lastState = null;
          this.lastNALu = null;
          this.lastNALuState = null;
        }
      }
      function getAVCConfig(sps) {
        let profile_idc = sps.profile_idc;
        let profile_compatibility = sps.profile_compatibility;
        let level_idc = sps.level_idc;
        let codecString = "avc1.";
        let arr = [profile_idc, profile_compatibility, level_idc];
        for (let j = 0; j < arr.length; j++) {
          let h2 = arr[j].toString(16);
          if (h2.length < 2) {
            h2 = "0" + h2;
          }
          codecString += h2;
        }
        return {
          codec: codecString
        };
      }
      class H264Stream extends Stream {
        constructor(psi) {
          super();
          __publicField(this, "PSI");
          __publicField(this, "trackId");
          __publicField(this, "currentFrame");
          __publicField(this, "prevFrame");
          __publicField(this, "codec");
          __publicField(this, "gop");
          __publicField(this, "gops");
          this.PSI = psi;
          this.trackId = null;
          this.currentFrame = [];
          this.codec = new AVCCodec();
          this._newGop();
          this._newGops();
          this.codec.on("nalu", (nalu) => {
            if (nalu.unit_type === 7) {
              let track = this.PSI.findTrack(this.trackId);
              let config = getAVCConfig(nalu.sps);
              track.codec = config.codec;
              track.width = nalu.sps.width;
              track.height = nalu.sps.height;
              track.profileIdc = nalu.sps.profile_idc;
              track.profileCompatibility = nalu.sps.profile_compatibility;
              track.levelIdc = nalu.sps.level_idc;
              track.pixelRatio = nalu.sps.pixelRatio;
              track.sps = [nalu.rawData];
            } else if (nalu.unit_type === 8) {
              let track = this.PSI.findTrack(this.trackId);
              track.pps = [nalu.rawData];
            }
            this.emit("nalu", nalu);
            this._grouping(nalu);
          });
        }
        /**
         * Push a complete pes
         * @param data
         */
        push(data) {
          const { stream_type, pes, pid } = data;
          if (stream_type === 27 || stream_type === 36) {
            this.trackId = pid;
            let rawData = {
              pts: pes.PTS,
              dts: pes.DTS,
              payload: pes.data_byte
            };
            this.codec.push(rawData);
          }
        }
        flush() {
          if (this.currentFrame.length > 0) {
            if (this.prevFrame && (!this.currentFrame.duration || this.currentFrame.duration <= 0)) {
              this.currentFrame.duration = this.prevFrame.duration || 0;
            }
            this._pushFrameIntoGop();
            this.currentFrame = [];
          }
          if (this.gop.length > 0) {
            this._pushGopIntoGroup();
          }
        }
        reset() {
          this.codec.reset();
          this.currentFrame = [];
          this._newGop();
          this._newGops();
        }
        /**
         * Group nalu into frame & gop.
         * @param currentNal
         * @private
         */
        _grouping(currentNal) {
          if (currentNal.unit_type === 9) {
            if (this.currentFrame.length > 0) {
              this.currentFrame.duration = currentNal.dts - this.currentFrame.dts;
              if (this.gop.length > 0 && this.currentFrame.keyframe) {
                this.gop.trackId = this.trackId;
                this._pushGopIntoGroup();
              }
              if (this.currentFrame.keyframe || this.gop.length > 0) {
                this._pushFrameIntoGop();
              } else {
                logger.warn(`h264 codec drop frame`);
              }
            }
            this.emit("frame", this.currentFrame);
            this.prevFrame = this.currentFrame;
            this.currentFrame = [];
            this.currentFrame.keyframe = false;
            this.currentFrame.byteLength = 0;
            this.currentFrame.naluCount = 0;
            this.currentFrame.pts = currentNal.pts / 9e4;
            this.currentFrame.dts = currentNal.dts / 9e4;
          } else {
            if (currentNal.unit_type === 5) {
              this.currentFrame.keyframe = true;
            }
            this.currentFrame.byteLength += currentNal.rawData.byteLength;
            this.currentFrame.naluCount++;
            this.currentFrame.push(currentNal);
          }
          this.currentFrame.duration = currentNal.dts - this.currentFrame.dts;
        }
        _newGop() {
          this.gop = [];
          this.gop.duration = 0;
          this.gop.naluCount = 0;
          this.gop.byteLength = 0;
        }
        _pushFrameIntoGop() {
          this.gop.push(this.currentFrame);
          this.gop.duration += this.currentFrame.duration;
          this.gop.byteLength += this.currentFrame.byteLength;
          this.gop.naluCount += this.currentFrame.naluCount;
        }
        _newGops() {
          this.gops = [];
          this.gops.type = "video";
          this.gops.duration = 0;
          this.gops.naluCount = 0;
          this.gops.byteLength = 0;
          this.gops.frameLength = 0;
          this.gops.firstDTS = 0;
        }
        _pushGopIntoGroup() {
          let firstFrame = this.gop[0];
          this.gops.trackId = this.trackId;
          this.gops.duration += this.gop.duration;
          this.gops.byteLength += this.gop.byteLength;
          this.gops.naluCount += this.gop.naluCount;
          this.gops.frameLength += this.gop.length;
          this.gops.firstDTS = firstFrame.dts;
          this.gops.firstPTS = firstFrame.pts;
          this.gops.push(this.gop);
          this.emit("data", this.gops);
          this._newGop();
          this._newGops();
          this.emit("done");
        }
      }
      class ElementaryStream extends Stream {
        constructor(ctx, psi, options = {}) {
          super();
          __publicField(this, "context");
          __publicField(this, "PSI");
          __publicField(this, "options");
          __publicField(this, "tracks");
          __publicField(this, "adtsStream");
          __publicField(this, "avcStream");
          __publicField(this, "streams");
          this.context = ctx;
          this.PSI = psi;
          this.options = options;
          this.tracks = [];
          this.adtsStream = new ADTSStream(psi);
          this.avcStream = new H264Stream(psi);
          this.streams = [this.adtsStream, this.avcStream];
          if (options.decodeCodec) {
            this.avcStream.on("data", (data) => {
              let stubTime = options.config.stubTime;
              if (isNumber(stubTime)) {
                let end = (data.firstPTS + data.duration) / 9e4;
                if (end < stubTime) {
                  logger.warn(`drop avc gop, start/end/stubTime(${data.firstPTS}/${end}/${stubTime})`);
                  return;
                }
              }
              this.tracks.push(data);
              this.emit("data", this.tracks);
              this.tracks = [];
              this.adtsStream.flush();
            });
            this.adtsStream.on("data", (data) => {
              let stubTime = options.config.stubTime;
              if (isNumber(stubTime)) {
                let end = (data.firstPTS + data.duration) / 9e4;
                if (end < stubTime) {
                  logger.warn(`drop adts, start/end/stubTime(${data.firstPTS}/${end}/${stubTime})`);
                  return;
                }
              }
              this.tracks.push(data);
              this.emit("data", this.tracks);
              this.tracks = [];
            });
          }
        }
        /**
         * Push a complete pes
         * @param data
         */
        push(data) {
          const { options, adtsStream, avcStream } = this;
          let { stream_type } = data;
          if (options.decodeCodec) {
            switch (stream_type) {
              case 27:
              case 36:
                avcStream.push(data);
                break;
              case 15:
                adtsStream.push(data);
                break;
              default:
                logger.warn(`ts elementary encounter unknown stream type ${stream_type}`);
            }
          } else {
            this.emit("data", data);
          }
        }
        flush() {
          let { streams, tracks } = this;
          for (let i = 0; i < this.streams.length; i++) {
            let stream = streams[i];
            stream.flush();
          }
          if (tracks.length > 0) {
            this.emit("data", tracks);
          }
          this.emit("done");
          tracks.splice(0, tracks.length);
        }
        reset() {
          this.tracks = [];
          for (let i = 0; i < this.streams.length; i++) {
            let stream = this.streams[i];
            stream.reset();
          }
          this.emit("reset");
        }
      }
      class Pes {
        constructor(buffer) {
          // private start_code_prefix: number;
          // stream_id: number;
          // packet_length: number;
          // data_alignment_indicator: number;
          // copyright: number;
          // ESCR_flag: number;
          // ES_rate_flag: number;
          // trick_mode_flag: number;
          // additional_copy_info_flag: number;
          // CRC_flag: number;
          // extension_flag: number;
          __publicField(this, "PTS");
          __publicField(this, "DTS");
          __publicField(this, "data_byte");
          let PTS_DTS_flags = buffer[7] >> 6;
          let header_data_length = buffer[8];
          this.PTS = 0;
          if ((PTS_DTS_flags & 2) == 2) {
            this.PTS = this.calcTimestamp_(buffer, 9);
          }
          this.DTS = this.PTS;
          if ((PTS_DTS_flags & 1) == 1) {
            this.DTS = this.calcTimestamp_(buffer, 14);
          }
          this.data_byte = buffer.subarray(9 + header_data_length);
        }
        /**
         * @param buffer
         * @param start
         */
        calcTimestamp_(buffer, start) {
          return (
            // JS Bitwise operators treat their operands as a sequence of 32 bits,
            // We cannot use bitwise operator in JS beyond 32bits
            (buffer[start] & 14) * 536870912 + // Math.pow(2, 29) === 536870912
            (buffer[start + 1] << 22) + (buffer[start + 2] >> 1 << 15) + (buffer[start + 3] << 7) + (buffer[start + 4] >> 1)
          );
        }
      }
      class PesStream extends Stream {
        constructor(ctx, psi) {
          super();
          __publicField(this, "context");
          __publicField(this, "PSI");
          __publicField(this, "PID");
          __publicField(this, "cache_buffer");
          this.context = ctx;
          this.PSI = psi;
          this.PID = null;
          this.cache_buffer = new CacheBuffer();
        }
        /**
         * @param packet
         */
        push(packet) {
          const self2 = this;
          if (packet.PID > 31 && packet.PID < 8191) {
            if (this.PSI.currentProgramPID == -1) {
              self2._pushPacket(packet);
            } else if (this.PSI.currentProgramPID !== packet.PID) {
              if (packet.payload_unit_start_indicator === 1) {
                self2._assembleOnePES();
              }
              self2._pushPacket(packet);
            }
          }
        }
        flush() {
          const self2 = this;
          self2._assembleOnePES();
          self2.emit("done");
        }
        reset() {
          this._clearCached();
          this.emit("reset");
        }
        _clearCached() {
          this.PID = null;
          this.cache_buffer.clear();
        }
        _pushPacket(p) {
          let empty = this.cache_buffer.empty;
          if (empty && p.payload_unit_start_indicator === 0) {
            return;
          }
          if (empty) {
            this.PID = p.PID;
          }
          this.cache_buffer.append(p.payload);
        }
        _assembleOnePES() {
          const self2 = this;
          if (!this.cache_buffer.empty) {
            let bytes;
            try {
              bytes = this.cache_buffer.toNewBytes();
            } catch (e) {
              throw `pes alloc mem err ${this.cache_buffer.byteLength}`;
            }
            let pesData = new Pes(bytes);
            let track = this.PSI.findTrack(this.PID);
            if (track) {
              let data = {
                pid: track.id,
                stream_type: track.stream_type,
                // pcr_pid: track.pcr_pid,
                pes: pesData
              };
              self2.emit("data", data);
            }
            self2._clearCached();
          }
        }
      }
      const SYNC_BYTE = 71;
      class Packet {
        /**
         * @param buffer
         */
        constructor(buffer) {
          __publicField(this, "sync_byte");
          // transport_error_indicator: number;
          __publicField(this, "payload_unit_start_indicator");
          // transport_priority: number;
          __publicField(this, "PID");
          // tsc: number;
          __publicField(this, "afc");
          // continuity_counter: number;
          __publicField(this, "has_payload");
          __publicField(this, "has_adaptation");
          // is_discontinuity: boolean;
          __publicField(this, "payload");
          this.sync_byte = buffer[0];
          this.payload_unit_start_indicator = buffer[1] >> 6 & 1;
          this.PID = (buffer[1] << 8 | buffer[2]) & 8191;
          this.afc = buffer[3] >> 4 & 3;
          this.has_payload = this.afc & 1;
          this.has_adaptation = this.afc & 2;
          if (this.has_payload) {
            if (this.has_adaptation) {
              let adaptation_field_length = buffer[4];
              this.payload = buffer.subarray(5 + adaptation_field_length);
            } else {
              this.payload = buffer.subarray(4);
            }
          }
        }
        valid() {
          return this.sync_byte === SYNC_BYTE && this.has_payload === 1;
        }
      }
      const CHUNK_BYTE_LENGTH = 188;
      class TSDemux extends DemuxFacade {
        constructor(options = {}) {
          super(options);
          __publicField(this, "psi_");
          __publicField(this, "pesStream_");
          __publicField(this, "elementaryStream_");
          __publicField(this, "complexStream_");
          this.psi_ = new PSI();
          this.pesStream_ = new PesStream(this.ctx_, this.psi_);
          this.elementaryStream_ = new ElementaryStream(this.ctx_, this.psi_, options);
          this.complexStream_ = new M2TSComplexStream(this.ctx_, this.psi_);
          this.pipe(this.pesStream_);
          this.pesStream_.pipe(this.elementaryStream_);
          this.elementaryStream_.pipe(this.complexStream_);
          super.listenEndStream_();
        }
        /**
         * This is end pipeline stream
         */
        get endStream() {
          let stream = this.elementaryStream_;
          if (this.options_.decodeCodec) {
            stream = this.complexStream_;
          }
          return stream;
        }
        /**
         * TS push support streaming incomplete data push.
         * @param buffer
         * @param conf
         * @param conf.done - If you need the done event, this boolean needs to be set
         */
        push(buffer, conf = {}) {
          const { done } = conf;
          const { options_, ctx_, cache_buffer_, psi_ } = this;
          let newBuf = super.constraintPushData_(buffer);
          let cacheByteLength = cache_buffer_.byteLength;
          let byteOffset = null;
          options_.config = conf;
          logger.log(`hls demux received ${newBuf.byteLength} bytes, cache ${cacheByteLength} bytes. ${done ? "chunk done" : ""}`);
          cache_buffer_.append(newBuf);
          while (cache_buffer_.byteLength >= CHUNK_BYTE_LENGTH) {
            let chunk = cache_buffer_.cut(CHUNK_BYTE_LENGTH);
            if (chunk) {
              let packet = new Packet(chunk);
              if (packet.valid()) {
                psi_.parse(packet);
                this.emit("data", packet);
              } else {
                let errMsg = `Encounter invalid ts packet, packet_length(${chunk.length}), cache_length(${this.cache_buffer_.byteLength}), has_payload(${packet.has_payload}), data(${chunk})`;
                logger.error(errMsg);
                this.reset();
                ctx_.emit("error", muxErrorCode.TS_SYNC_BYTE, errMsg, {
                  startByte: byteOffset,
                  endByte: byteOffset + chunk.byteLength
                });
                break;
              }
              byteOffset += chunk.byteLength;
            }
          }
          if (cache_buffer_.empty && done) {
            this.emit("done");
          }
        }
        reset() {
          this.cache_buffer_.clear();
          this.emit("reset");
        }
      }
      var FLVParseStage;
      (function(FLVParseStage2) {
        FLVParseStage2[FLVParseStage2["HEAD"] = 0] = "HEAD";
        FLVParseStage2[FLVParseStage2["BODY"] = 1] = "BODY";
      })(FLVParseStage || (FLVParseStage = {}));
      var FlvTagTypes;
      (function(FlvTagTypes2) {
        FlvTagTypes2[FlvTagTypes2["SCRIPT_DATA"] = 18] = "SCRIPT_DATA";
        FlvTagTypes2[FlvTagTypes2["VIDEO"] = 9] = "VIDEO";
        FlvTagTypes2[FlvTagTypes2["AUDIO"] = 8] = "AUDIO";
      })(FlvTagTypes || (FlvTagTypes = {}));
      var AudioSoundFormat;
      (function(AudioSoundFormat2) {
        AudioSoundFormat2[AudioSoundFormat2["G711A"] = 7] = "G711A";
        AudioSoundFormat2[AudioSoundFormat2["G711U"] = 8] = "G711U";
        AudioSoundFormat2[AudioSoundFormat2["AAC"] = 10] = "AAC";
        AudioSoundFormat2[AudioSoundFormat2["OPUS"] = 13] = "OPUS";
      })(AudioSoundFormat || (AudioSoundFormat = {}));
      var AudioSoundType;
      (function(AudioSoundType2) {
        AudioSoundType2[AudioSoundType2["MONO"] = 0] = "MONO";
        AudioSoundType2[AudioSoundType2["STEREO"] = 1] = "STEREO";
      })(AudioSoundType || (AudioSoundType = {}));
      var AACPacketType;
      (function(AACPacketType2) {
        AACPacketType2[AACPacketType2["SEQUENCE_HEAD"] = 0] = "SEQUENCE_HEAD";
        AACPacketType2[AACPacketType2["AAC_RAW"] = 1] = "AAC_RAW";
      })(AACPacketType || (AACPacketType = {}));
      var OpusPacketType;
      (function(OpusPacketType2) {
        OpusPacketType2[OpusPacketType2["SEQUENCE_HEAD"] = 0] = "SEQUENCE_HEAD";
        OpusPacketType2[OpusPacketType2["RAW"] = 1] = "RAW";
      })(OpusPacketType || (OpusPacketType = {}));
      var AVCPacketTypes;
      (function(AVCPacketTypes2) {
        AVCPacketTypes2[AVCPacketTypes2["SEQUENCE_HEAD"] = 0] = "SEQUENCE_HEAD";
        AVCPacketTypes2[AVCPacketTypes2["NALU"] = 1] = "NALU";
        AVCPacketTypes2[AVCPacketTypes2["SEQUENCE_END"] = 2] = "SEQUENCE_END";
      })(AVCPacketTypes || (AVCPacketTypes = {}));
      const avcCodec = new AVCCodec();
      avcCodec.on("nalu", (nalu) => {
      });
      var VideoCodecIDs;
      (function(VideoCodecIDs2) {
        VideoCodecIDs2[VideoCodecIDs2["AVC"] = 7] = "AVC";
      })(VideoCodecIDs || (VideoCodecIDs = {}));
      const NALU_TYPES = {
        SPS: 7
        // Sequence Parameter Set
      };
      class DemuxerTsNew {
        /**
         * 构造函数
         * @param options 解复用器选项
         */
        constructor(options) {
          Object.defineProperty(this, "demux", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "firstOnDataTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
          });
          Object.defineProperty(this, "_onDecodeChunk", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "_onConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.demux = new TSDemux({
            // 如果是生产环境，应该设为 false 或不指定
            debug: false,
            // 启用编解码器解析
            decodeCodec: true
          });
          this.demux.on(Events.DONE, this._onDeMuxDataDone.bind(this));
          this.demux.elementaryStream_.avcStream.on("frame", this._onDemuxFrame.bind(this));
          this._onDecodeChunk = options.onDecodeChunk;
          this._onConfig = options.onConfig;
        }
        /**
         * 推送数据
         * @param bytes 数据
         */
        push(bytes, options) {
          if (!this.demux) {
            throw new Error("解复用器未初始化");
          }
          this.demux.push(new Uint8Array(bytes), {
            ...options || {}
          });
        }
        /**
         * 销毁
         */
        destroy() {
          var _a;
          (_a = this.demux) == null ? void 0 : _a.destroy();
          this.demux = void 0;
        }
        /**
         * 处理解复用帧
         * @param avcFrame 解复用帧
         */
        _onDemuxFrame(avcFrame) {
          const frameData = this._createFrameData(avcFrame);
          if (frameData) {
            this._sendVideoFrame(avcFrame, frameData);
          }
        }
        /**
         * 创建帧数据
         * @description 创建帧数据，将 NALU 数据转换为帧数据，并且为 NALU 添加起始码，拦截 sps 发起配置回调
         */
        _createFrameData(avcFrame) {
          try {
            const nalus = [];
            const startCode = new Uint8Array([0, 0, 0, 1]);
            for (let i = 0, len = avcFrame.length; i < len; i++) {
              const nalu = avcFrame[i];
              if (!nalu || !nalu.rawData || nalu.rawData.byteLength === 0)
                continue;
              if (nalu.unit_type === NALU_TYPES.SPS) {
                const config = getAVCConfig(nalu.sps);
                this._onConfig({
                  codec: config.codec,
                  width: nalu.sps.width,
                  height: nalu.sps.height
                });
              }
              const naluData = new Uint8Array(startCode.length + nalu.rawData.byteLength);
              naluData.set(startCode, 0);
              naluData.set(new Uint8Array(nalu.rawData), startCode.length);
              nalus.push(naluData);
            }
            if (nalus.length === 0) {
              return null;
            }
            const totalLength = nalus.reduce((acc, nalu) => acc + nalu.byteLength, 0);
            const frameData = new Uint8Array(totalLength);
            let offset = 0;
            for (const nalu of nalus) {
              frameData.set(nalu, offset);
              offset += nalu.byteLength;
            }
            return frameData;
          } catch (error) {
            console.error("创建关键帧数据时出错:", error);
            return null;
          }
        }
        /**
         * 发送视频帧到解码器
         */
        _sendVideoFrame(avcFrame, frameData) {
          try {
            if (!frameData || frameData.byteLength === 0) {
              console.warn("尝试发送无效帧数据");
              return;
            }
            this._onDecodeChunk({
              avcFrame,
              rawData: frameData
            });
          } catch (error) {
            console.error("发送视频帧时出错:", error);
          }
        }
        /**
         * 解复用完成回调
         */
        _onDeMuxDataDone() {
          const endTime = performance.now();
          const duration = endTime - this.firstOnDataTime;
          console.log(`解复用完成，耗时: ${duration} 毫秒`);
        }
      }
      const microsecTimebase = {
        num: 1,
        den: 1e6
      };
      const secTimebase = {
        num: 1,
        den: 1
      };
      function timebaseConvert(value, fromTimebase, toTimebase) {
        return value * fromTimebase.num / fromTimebase.den * toTimebase.den / toTimebase.num;
      }
      const TIMEOUT_MS = 5e3;
      class M3U8ClipperNew {
        constructor(options) {
          Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
          });
          Object.defineProperty(this, "hlsIo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.hlsIo = new HlsIO();
        }
        /**
         * 销毁
         */
        destroy() {
          this.hlsIo.destroy();
        }
        /**
         * 打开
         * @description 打开 m3u8 文件
         */
        async open() {
          await this.hlsIo.open(this.options);
        }
        /**
         * 跳转
         * @description 跳转到分片截取 VideoFrame
         * @param time 时间
         * @param stream 是否只处理关键帧
         * @returns 视频帧
         */
        async seek(time, stream = false) {
          const now = Date.now();
          let frame;
          let loop = true;
          const segment = await this.hlsIo.seek(time);
          const io = new FetchIO();
          const sampleQueue = [];
          const videoDecoder = new VideoDecoder({
            output: (videoFrame) => {
              const frameTime = this._getFrameRealTime(videoFrame.timestamp);
              if (stream && !frame) {
                frame = videoFrame;
                return;
              }
              if (frameTime >= time && !frame) {
                frame = videoFrame;
                return;
              }
              videoFrame.close();
            },
            error: (error) => {
              console.error(error.message);
              console.error("解码器错误", this.hlsIo.segmentUrl);
              destroy();
            }
          });
          const demuxer = new DemuxerTsNew({
            onConfig: (config) => {
              videoDecoder.configure({
                codec: config.codec
              });
            },
            onDecodeChunk: (encodeChunk) => {
              const chunk = new EncodedVideoChunk({
                type: encodeChunk.avcFrame.keyframe ? "key" : "delta",
                timestamp: encodeChunk.avcFrame.pts * 1e6,
                duration: encodeChunk.avcFrame.duration * 1e6,
                data: encodeChunk.rawData
              });
              sampleQueue.push(chunk);
            },
            onDone: () => {
              videoDecoder.flush();
            }
          });
          const destroy = () => {
            loop = false;
            demuxer.destroy();
            if (frame) {
              try {
                frame.close();
              } catch {
              }
              frame = void 0;
            }
            if (videoDecoder.state !== "closed") {
              videoDecoder.close();
            }
          };
          if (stream) {
            io.streamChunks(segment.url, async (buffer) => {
              if (demuxer.demux) {
                demuxer.push(buffer);
              } else {
                return false;
              }
              await promiseDelay(100);
              if (frame) {
                return false;
              }
              console.count("继续读取");
              return true;
            });
          } else {
            const response = await io.fetchBufferRange(segment.url, 0, -1);
            const buffer = await response.arrayBuffer();
            demuxer.push(buffer, {
              done: true
            });
          }
          while (loop) {
            if (frame) {
              loop = false;
              demuxer.destroy();
              if (videoDecoder.state !== "closed") {
                videoDecoder.close();
              }
              return {
                videoFrame: frame,
                frameTime: this._getFrameRealTime(frame.timestamp),
                seekTime: time,
                consumedTime: Date.now() - now
              };
            }
            if (Date.now() - now > TIMEOUT_MS) {
              console.error(`m3u8Clipper seek timeout, time: ${time}`);
              loop = false;
              destroy();
              return void 0;
            }
            if (sampleQueue.length > 0) {
              const chunk = sampleQueue.shift();
              if (chunk) {
                videoDecoder.decode(chunk);
                await videoDecoder.flush();
              }
            } else {
              await promiseDelay(0);
            }
          }
        }
        /**
         * 获取帧的实际时间
         * @param timestamp 时间戳 (微秒) 来源与 VideoFrame 或 EncodedVideoChunk
         * @returns 实际时间 (秒)
         */
        _getFrameRealTime(timestamp) {
          const videoFrameTime = timebaseConvert(timestamp, microsecTimebase, secTimebase);
          const frameTime = videoFrameTime;
          return frameTime;
        }
      } exports("M", M3U8ClipperNew);
      function getImageResize(originalWidth, originalHeight, maxWidth, maxHeight) {
        let width = originalWidth;
        let height = originalHeight;
        if (width > height) {
          if (width > maxWidth) {
            height = Math.round(height * (maxWidth / width));
            width = maxWidth;
          }
        } else {
          if (height > maxHeight) {
            width = Math.round(width * (maxHeight / height));
            height = maxHeight;
          }
        }
        return { width, height };
      }
      var TaskStatus;
      (function(TaskStatus2) {
        TaskStatus2["Pending"] = "pending";
        TaskStatus2["Running"] = "running";
        TaskStatus2["Paused"] = "paused";
        TaskStatus2["Cancelled"] = "cancelled";
        TaskStatus2["Completed"] = "completed";
        TaskStatus2["Failed"] = "failed";
      })(TaskStatus || (TaskStatus = {}));
      class SchedulerError {
      } exports("n", SchedulerError);
      Object.defineProperty(SchedulerError, "TaskExist", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: class extends Error {
          constructor() {
            super("Task Exist");
          }
        }
      });
      Object.defineProperty(SchedulerError, "TaskCancelled", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: class extends Error {
          constructor() {
            super("Task Cancelled");
          }
        }
      });
      Object.defineProperty(SchedulerError, "QueueCleared", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: class extends Error {
          constructor() {
            super("Queue Cleared");
          }
        }
      });
      Object.defineProperty(SchedulerError, "QueueFull", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: class extends Error {
          constructor() {
            super("Queue Full");
          }
        }
      });
      Object.defineProperty(SchedulerError, "TaskTimeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: class extends Error {
          constructor() {
            super("Task Timeout");
          }
        }
      });
      class Scheduler {
        /**
         * 构造函数
         * @param options 配置选项
         */
        constructor(options = {}) {
          Object.defineProperty(this, "queue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
          });
          Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
              maxConcurrent: 3,
              maxQueueLength: Infinity,
              defaultRetryDelay: 1e3,
              laneConfig: {}
            }
          });
          Object.defineProperty(this, "running", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: /* @__PURE__ */ new Map()
          });
          Object.defineProperty(this, "laneRunningCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: /* @__PURE__ */ new Map()
          });
          this.options = {
            ...this.options,
            ...options
          };
          Object.keys(this.options.laneConfig).forEach((laneName) => {
            this.laneRunningCount.set(laneName, 0);
          });
        }
        /**
         * 获取队列长度
         */
        get length() {
          return this.queue.length;
        }
        /**
         * 获取正在运行的任务数
         */
        get runningCount() {
          return this.running.size;
        }
        /**
         * 添加任务到队列
         */
        async add(execute, options = {}) {
          if (this.queue.length >= this.options.maxQueueLength) {
            throw new SchedulerError.QueueFull();
          }
          if (options.id && this.get(options.id)) {
            throw new SchedulerError.TaskExist();
          }
          let resolve = void 0;
          let reject = void 0;
          const promise = new Promise((_resolve, _reject) => {
            resolve = _resolve;
            reject = _reject;
          });
          const task = {
            execute,
            promise,
            priority: options.priority || 0,
            resolve,
            reject,
            timeout: options.timeout,
            retries: options.retries || 0,
            id: options.id || Math.random().toString(36).substr(2, 9),
            lane: options.lane,
            status: TaskStatus.Pending,
            immediate: options.immediate,
            action: options.action
          };
          if (task.lane && this.isPaused(task.lane)) {
            task.status = TaskStatus.Paused;
          }
          if (task.action === "push") {
            this.queue.push(task);
          } else {
            this.queue.unshift(task);
          }
          this.sort();
          if (task.immediate) {
            this.processQueue();
          }
          return task.promise;
        }
        /**
         * 暂停全部或指定任务或任务车道
         */
        pause(idOrLane) {
          this.running.forEach((task) => {
            if (!idOrLane || task.id === idOrLane || task.lane === idOrLane) {
              task.status = TaskStatus.Paused;
            }
          });
          this.queue.forEach((task) => {
            if (!idOrLane || task.id === idOrLane || task.lane === idOrLane) {
              task.status = TaskStatus.Paused;
            }
          });
        }
        /**
         * 恢复全部或指定任务或任务车道
         */
        resume(idOrLane) {
          this.queue.forEach((task) => {
            if ((!idOrLane || task.id === idOrLane || task.lane === idOrLane) && task.status === TaskStatus.Paused) {
              task.status = TaskStatus.Pending;
            }
          });
          this.sort();
          this.processQueue();
        }
        /**
         * 取消指定任务或任务车道
         */
        cancel(idOrLane) {
          this.queue = this.queue.filter((task) => {
            if (task.id === idOrLane || task.lane === idOrLane) {
              task.status = TaskStatus.Cancelled;
              task.reject(new SchedulerError.TaskCancelled());
              return false;
            }
            return true;
          });
          this.running.forEach((task, taskId) => {
            if (task.id === idOrLane || task.lane === idOrLane) {
              task.status = TaskStatus.Cancelled;
              task.reject(new SchedulerError.TaskCancelled());
              this.running.delete(taskId);
              if (task.lane) {
                this.decrementLaneRunningCount(task.lane);
              }
            }
          });
        }
        /**
         * 移除指定任务或任务车道
         * @param idOrLane 任务ID或车道名
         */
        remove(idOrLane) {
          this.cancel(idOrLane);
          this.queue = this.queue.filter((task) => task.id !== idOrLane && task.lane !== idOrLane);
        }
        /**
         * 重试指定任务或任务车道
         */
        retry(idOrLane, retries) {
          const tasksToRetry = [];
          this.queue.forEach((task) => {
            if ((task.id === idOrLane || task.lane === idOrLane) && task.status === TaskStatus.Failed) {
              task.retries = retries ?? task.retries;
              task.status = TaskStatus.Pending;
              tasksToRetry.push(task);
            }
          });
          tasksToRetry.forEach((task) => {
            this.queue.push(task);
          });
          this.processQueue();
        }
        /**
         * 是否暂停
         * @param idOrLane 任务ID或车道名
         * @returns 是否暂停
         */
        isPaused(idOrLane) {
          return Boolean(this.queue.some((task) => task.lane === idOrLane && task.status === TaskStatus.Paused));
        }
        /**
         * 是否正在等待执行
         * @param idOrLane 任务ID或车道名
         * @returns 是否正在等待执行
         */
        isPending(idOrLane) {
          return Boolean(this.queue.some((task) => task.lane === idOrLane && task.status === TaskStatus.Pending));
        }
        /**
         * 获取队列状态
         */
        getStatus() {
          const laneStatus = {};
          this.laneRunningCount.forEach((count, lane) => {
            var _a;
            laneStatus[lane] = {
              running: count,
              maxConcurrent: ((_a = this.options.laneConfig[lane]) == null ? void 0 : _a.maxConcurrent) || 0
            };
          });
          return {
            queueLength: this.queue.length,
            runningCount: this.running.size,
            maxConcurrent: this.options.maxConcurrent,
            lanes: laneStatus,
            tasks: {
              pending: this.queue.filter((t) => t.status === "pending").length,
              running: this.running.size,
              paused: this.queue.filter((t) => t.status === "paused").length,
              failed: this.queue.filter((t) => t.status === "failed").length,
              completed: this.queue.filter((t) => t.status === "completed").length,
              cancelled: this.queue.filter((t) => t.status === "cancelled").length
            }
          };
        }
        /**
         * 获取任务
         */
        get(idOrLane) {
          return this.queue.find((t) => t.id === idOrLane || t.lane === idOrLane) ?? this.running.get(idOrLane);
        }
        /**
         * 是否有正在运行的任务
         */
        hasRunning() {
          return this.running.size > 0;
        }
        /**
         * 获取车道的运行状态
         */
        getLaneStatus(lane) {
          const laneConfig = this.options.laneConfig[lane];
          const runningCount = this.getLaneRunningCount(lane);
          return {
            name: lane,
            running: runningCount,
            maxConcurrent: (laneConfig == null ? void 0 : laneConfig.maxConcurrent) || 0,
            priority: (laneConfig == null ? void 0 : laneConfig.priority) || 0,
            hasConfig: !!laneConfig
          };
        }
        /**
         * 尝试抢占车道
         */
        tryOvertaking(id, lane, priority) {
          const task = this.get(id);
          if (!task)
            return false;
          if (task.status === TaskStatus.Pending || task.status === TaskStatus.Running || task.status === TaskStatus.Paused) {
            task.lane = lane;
            task.priority = priority ?? task.priority;
            this.sort();
            this.processQueue();
            return true;
          }
          return false;
        }
        /**
         *  尝试恢复任务
         */
        tryResume(id) {
          const task = this.get(id);
          if (!task)
            return false;
          if (task.status === TaskStatus.Paused) {
            this.resume(id);
            return true;
          }
          return false;
        }
        /**
         * 设置车道配置
         */
        setLaneConfig(lane, config) {
          const currentConfig = this.options.laneConfig[lane] || {
            name: lane,
            priority: 0,
            maxConcurrent: this.options.maxConcurrent
          };
          this.options.laneConfig[lane] = {
            ...currentConfig,
            ...config
          };
          if (!this.laneRunningCount.has(lane)) {
            this.laneRunningCount.set(lane, 0);
          }
          this.sort();
          this.processQueue();
        }
        /**
         * 等待队列空闲
         */
        async waitIdle(time = 100) {
          if (!this.hasRunning()) {
            return;
          }
          await new Promise((resolve) => setTimeout(resolve, time));
          await this.waitIdle();
        }
        /**
         * 等待特定车道空闲
         */
        async waitLaneIdle(lane, time = 100) {
          if (this.getLaneRunningCount(lane) === 0) {
            return;
          }
          await new Promise((resolve) => setTimeout(resolve, time));
          await this.waitLaneIdle(lane, time);
        }
        /**
         * 清空队列
         */
        clear() {
          this.queue.forEach((task) => {
            task.status = TaskStatus.Cancelled;
            task.reject(new SchedulerError.QueueCleared());
          });
          this.queue = [];
          this.running.clear();
          this.laneRunningCount.clear();
          Object.keys(this.options.laneConfig).forEach((laneName) => {
            this.laneRunningCount.set(laneName, 0);
          });
        }
        /**
         * 增加车道运行计数
         */
        incrementLaneRunningCount(lane) {
          const currentCount = this.laneRunningCount.get(lane) || 0;
          this.laneRunningCount.set(lane, currentCount + 1);
        }
        /**
         * 减少车道运行计数
         */
        decrementLaneRunningCount(lane) {
          const currentCount = this.laneRunningCount.get(lane) || 0;
          if (currentCount > 0) {
            this.laneRunningCount.set(lane, currentCount - 1);
          }
        }
        /**
         * 获取车道当前运行任务数
         */
        getLaneRunningCount(lane) {
          return this.laneRunningCount.get(lane) || 0;
        }
        /**
         * 检查车道是否可以运行更多任务
         */
        canLaneRunMoreTasks(lane) {
          const laneConfig = this.options.laneConfig[lane];
          if (!laneConfig)
            return true;
          const currentCount = this.getLaneRunningCount(lane);
          return currentCount < laneConfig.maxConcurrent;
        }
        /**
         * 处理队列
         */
        async processQueue() {
          if (this.running.size >= this.options.maxConcurrent) {
            return;
          }
          const nextTask = this.queue.find((task) => {
            if (task.status !== TaskStatus.Pending || this.isPaused(task.id)) {
              return false;
            }
            if (task.lane && !this.canLaneRunMoreTasks(task.lane)) {
              return false;
            }
            return true;
          });
          if (!nextTask)
            return;
          this.running.set(nextTask.id, nextTask);
          nextTask.status = TaskStatus.Running;
          if (nextTask.lane) {
            this.incrementLaneRunningCount(nextTask.lane);
          }
          try {
            let timeoutId;
            const executeWithTimeout = async () => {
              if (nextTask.timeout) {
                const timeoutPromise = new Promise((_, reject) => {
                  timeoutId = window.setTimeout(() => {
                    console.warn("Task timeout", nextTask.id);
                    reject(new SchedulerError.TaskTimeout());
                  }, nextTask.timeout);
                });
                return Promise.race([nextTask.execute(), timeoutPromise]);
              }
              return nextTask.execute();
            };
            const result2 = await this.executeWithRetry(executeWithTimeout, nextTask.retries || 0, nextTask);
            if (timeoutId)
              clearTimeout(timeoutId);
            nextTask.status = TaskStatus.Completed;
            nextTask.resolve(result2);
          } catch (error) {
            nextTask.status = TaskStatus.Failed;
            nextTask.reject(error);
          } finally {
            this.running.delete(nextTask.id);
            if (nextTask.lane) {
              this.decrementLaneRunningCount(nextTask.lane);
            }
            this.processQueue();
          }
        }
        /**
         * 带重试的执行
         */
        async executeWithRetry(fn, retriesLeft, task) {
          try {
            return await fn();
          } catch (error) {
            if (retriesLeft > 0 && task.status !== "cancelled") {
              console.warn("Task retry", task.id);
              await new Promise((resolve) => setTimeout(resolve, this.options.defaultRetryDelay));
              return this.executeWithRetry(fn, retriesLeft - 1, task);
            }
            throw error;
          }
        }
        /**
         * 排序队列
         */
        sort() {
          this.queue.sort((a, b) => {
            var _a, _b;
            const aLanePriority = a.lane ? ((_a = this.options.laneConfig[a.lane]) == null ? void 0 : _a.priority) || 0 : 0;
            const bLanePriority = b.lane ? ((_b = this.options.laneConfig[b.lane]) == null ? void 0 : _b.priority) || 0 : 0;
            if (aLanePriority !== bLanePriority) {
              return aLanePriority - bLanePriority;
            }
            return a.priority - b.priority;
          });
        }
      } exports("S", Scheduler);
      const MAX_WIDTH = 720;
      const MAX_HEIGHT = 720;
      const videoCoverScheduler = new Scheduler({
        maxConcurrent: 3
      });
      function generateTaskId(options) {
        return `cover_${options.sha1}_${options.pickCode}_${options.coverNum}_${options.duration}`;
      }
      const getCacheKey = (sha1, time) => `${sha1}_${time}`;
      function calculateVideoCoverTimes(duration, coverNum) {
        const offset = duration / 5;
        const minTime = offset;
        const maxTime = duration - offset;
        const range = maxTime - minTime;
        return Array.from({ length: coverNum }, (_, i) => Math.floor(minTime + range / coverNum * i));
      }
      function toDisplayableData(rawData) {
        return {
          img: URL.createObjectURL(rawData.blob),
          ...rawData
        };
      }
      async function generateVideoCoverRaw(clipper, time) {
        const result2 = await clipper.seek(time, true);
        if (!result2) {
          throw new Error("no clipper result");
        }
        try {
          const resize = getImageResize(result2.videoFrame.displayWidth, result2.videoFrame.displayHeight, MAX_WIDTH, MAX_HEIGHT);
          const canvas = new OffscreenCanvas(resize.width, resize.height);
          const ctx = canvas.getContext("2d");
          if (!ctx) {
            throw new Error("no canvas context");
          }
          const imageBitmap = await createImageBitmap(result2.videoFrame, {
            resizeQuality: "pixelated",
            resizeWidth: resize.width,
            resizeHeight: resize.height
          });
          try {
            ctx.drawImage(imageBitmap, 0, 0, resize.width, resize.height);
            const blob = await canvas.convertToBlob({
              type: "image/webp",
              quality: 0.85
            });
            const raw = {
              blob,
              width: resize.width,
              height: resize.height,
              frameTime: result2.frameTime,
              seekTime: time
            };
            return raw;
          } finally {
            imageBitmap.close();
          }
        } finally {
          result2.videoFrame.close();
        }
      }
      async function getVideoCoversFromCache(sha1, times) {
        const covers = [];
        for (const time of times) {
          const cacheKey = getCacheKey(sha1, time);
          const cache = await videoCoverCache.get(cacheKey);
          if (!cache) {
            return [];
          }
          const cacheData = cache.value;
          covers.push(toDisplayableData(cacheData));
        }
        return covers;
      }
      async function getVideoCover(sha1, pickCode, times) {
        const m3u8List = await drive115.getM3u8(pickCode);
        const source = m3u8List.sort((a, b) => a.quality - b.quality)[0];
        if (!source) {
          throw new Error("source is null");
        }
        const clipper = new M3U8ClipperNew({
          url: source.url
        });
        await clipper.open();
        const promises = times.map(async (time) => {
          const cacheKey = getCacheKey(sha1, time);
          const raw = await generateVideoCoverRaw(clipper, time);
          videoCoverCache.set(cacheKey, raw);
          return toDisplayableData(raw);
        });
        return Promise.all(promises);
      }
      function cleanupBlobUrl(covers) {
        covers.forEach((cover) => {
          if (cover.startsWith("blob:")) {
            URL.revokeObjectURL(cover);
          }
        });
      }
      function useSmartVideoCover(options, config) {
        const videoCover = reactive({
          isReady: false,
          isLoading: false,
          error: void 0,
          state: []
        });
        const taskId = generateTaskId(options.value);
        const times = calculateVideoCoverTimes(options.value.duration, options.value.coverNum);
        const visibility = useElementVisibility(config.elementRef, {
          threshold: config.threshold ?? 0,
          rootMargin: config.rootMargin ?? "0%",
          scrollTarget: config.scrollTarget
        });
        const addTask = (id, sha1, pickCode, times2) => {
          return videoCoverScheduler.add(() => {
            return getVideoCover(sha1, pickCode, times2);
          }, {
            id,
            immediate: true
          });
        };
        const cancelTask = () => {
          const task = videoCoverScheduler.get(taskId);
          if (task && task.status === TaskStatus.Pending) {
            videoCoverScheduler.cancel(taskId);
          }
        };
        const getData = async (id, options2) => {
          if (videoCover.isReady || videoCover.error) {
            return;
          }
          const task = videoCoverScheduler.get(id);
          if (task) {
            return;
          }
          videoCover.isLoading = true;
          try {
            const data = await addTask(id, options2.sha1, options2.pickCode, times);
            videoCover.state = data;
            videoCover.isReady = true;
          } catch (error) {
            if (error instanceof SchedulerError.TaskCancelled) {
              return;
            }
            if (error instanceof Drive115Error.NotFoundM3u8File) {
              videoCover.error = FRIENDLY_ERROR_MESSAGE.CANNOT_VIDEO_COVER_WITHOUT_TRANSCODING;
              return;
            }
            videoCover.error = error;
          } finally {
            videoCover.isLoading = false;
          }
        };
        const getDataByCache = async (options2) => {
          if (videoCover.isReady || videoCover.error) {
            return;
          }
          videoCover.isLoading = true;
          try {
            const data = await getVideoCoversFromCache(options2.sha1, times);
            if (data.length > 0) {
              videoCover.state = data;
              videoCover.isLoading = false;
              videoCover.isReady = true;
            }
          } catch (error) {
            videoCover.error = error;
          } finally {
            videoCover.isLoading = false;
          }
        };
        const { isScrolling } = useScroll(config.scrollTarget, {
          throttle: 16.666666666666668,
          idle: 100,
          onStop: async () => {
            if (visibility.value) {
              await getDataByCache(options.value);
              getData(taskId, options.value);
            }
          }
        });
        watch(visibility, async (value) => {
          if (value) {
            if (isScrolling.value) {
              getDataByCache(options.value);
            } else {
              await getDataByCache(options.value);
              getData(taskId, options.value);
            }
          } else {
            cancelTask();
          }
        });
        onUnmounted(() => {
          videoCoverScheduler.remove(taskId);
          cleanupBlobUrl(videoCover.state.map((item) => item == null ? void 0 : item.img).filter((item) => item !== void 0));
        });
        return {
          videoCover
        };
      }
      const _hoisted_1 = ["id"];
      const _hoisted_2 = ["onClick"];
      const _hoisted_3 = ["src", "alt"];
      const FILELIST_VIDEO_COVER_NUM = 5;
      const _sfc_main = /* @__PURE__ */ defineComponent({
        __name: "index",
        props: {
          pickCode: {},
          sha1: {},
          duration: {},
          listScrollBoxNode: {}
        },
        setup(__props) {
          const props = __props;
          const styles = {
            // 容器样式
            container: {
              main: "w-full max-w-214 px-20 h-24 [content-visibility:auto]",
              content: "relative h-full flex items-center bg-base-300 rounded overflow-hidden"
            },
            // 状态样式
            states: {
              error: "flex items-center justify-center flex-1"
            },
            // 骨架样式
            skeleton: "skeleton w-full h-full rounded",
            // 视频封面
            cover: {
              container: [
                "w-full h-full flex overflow-hidden select-none overflow-hidden"
              ],
              thumbItem: [
                "h-full aspect-video",
                "overflow-hidden",
                "cursor-zoom-in no-underline",
                "hover:opacity-90 transition-opacity"
              ],
              thumbImage: ["h-full w-full object-contain object-center align-top"]
            }
          };
          const rootRef = ref();
          const lightbox = ref(null);
          const scrollTargetRef = computed(() => props.listScrollBoxNode);
          const options = computed(() => ({
            sha1: props.sha1,
            pickCode: props.pickCode,
            coverNum: FILELIST_VIDEO_COVER_NUM,
            duration: Number(props.duration)
          }));
          const config = {
            elementRef: rootRef,
            scrollTarget: scrollTargetRef
          };
          const { videoCover } = useSmartVideoCover(options, config);
          function initPhotoSwipe() {
            if (lightbox.value) {
              lightbox.value.destroy();
              lightbox.value = null;
            }
            lightbox.value = new PhotoSwipeLightbox({
              dataSource: videoCover.state.map((item) => ({
                src: item.img,
                width: item.width,
                height: item.height,
                alt: "视频封面"
              })),
              showHideAnimationType: "fade",
              pswpModule: () => __vitePreload(() => module.import('photoswipe'), void 0 ),
              mouseMovePan: true,
              initialZoomLevel: "fit",
              secondaryZoomLevel: 2,
              maxZoomLevel: 4,
              wheelToZoom: true,
              bgOpacity: 0.9
            });
            lightbox.value.init();
          }
          function openPhotoSwipe(index) {
            if (!lightbox.value || !videoCover.isReady)
              return;
            lightbox.value.loadAndOpen(index);
          }
          watch(
            () => videoCover.isReady,
            async (isReady) => {
              if (isReady) {
                await nextTick();
                initPhotoSwipe();
              }
            }
          );
          onBeforeUnmount(() => {
            if (lightbox.value) {
              lightbox.value.destroy();
              lightbox.value = null;
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "rootRef",
              ref: rootRef,
              class: normalizeClass(styles.container.main)
            }, [
              createElementVNode("div", {
                class: normalizeClass(styles.container.content)
              }, [
                unref(videoCover).error ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(styles.states.error)
                }, [
                  createVNode(_sfc_main$1, {
                    size: "mini",
                    message: unref(videoCover).error
                  }, null, 8, ["message"])
                ], 2)) : unref(videoCover).isLoading ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(styles.skeleton)
                }, null, 2)) : unref(videoCover).isReady ? (openBlock(), createElementBlock("div", {
                  key: 2,
                  id: `gallery-${props.pickCode}`,
                  class: normalizeClass(["pswp-gallery", styles.cover.container])
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(videoCover).state, (thumbnail, index) => {
                    return openBlock(), createElementBlock("a", {
                      key: index,
                      class: normalizeClass([styles.cover.thumbItem]),
                      onClick: withModifiers(($event) => openPhotoSwipe(index), ["prevent", "stop"])
                    }, [
                      createElementVNode("img", {
                        src: thumbnail.img,
                        alt: `视频封面 ${index + 1}`,
                        class: normalizeClass(styles.cover.thumbImage)
                      }, null, 10, _hoisted_3)
                    ], 10, _hoisted_2);
                  }), 128))
                ], 10, _hoisted_1)) : createCommentVNode("", true)
              ], 2)
            ], 2);
          };
        }
      });
      class FileItemModVideoCover extends FileItemModBase {
        constructor() {
          super(...arguments);
          Object.defineProperty(this, "ENABLE_KEY_IN_USER_SETTING", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "enableFilelistPreview"
          });
          Object.defineProperty(this, "vueApp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
          });
        }
        onLoad() {
          if (this.itemInfo.fileListType === FileListType.grid) {
            return;
          }
          if (this.itemInfo.attributes.iv !== IvType.Yes) {
            return;
          }
          this.itemNode.classList.add("with-ext-video-cover");
          const container = document.createElement("div");
          container.style.width = "100%";
          this.itemNode.append(container);
          const shadowRoot = container.attachShadow({ mode: "open" });
          const styleElement = document.createElement("style");
          styleElement.textContent = mainStyles;
          shadowRoot.appendChild(styleElement);
          const root = document.createElement("div");
          root.className = "ext-video-cover-root";
          root.setAttribute("data-theme", "light");
          shadowRoot.appendChild(root);
          const app = createApp(_sfc_main, {
            pickCode: this.itemInfo.attributes.pick_code,
            sha1: this.itemInfo.attributes.sha1,
            duration: String(this.itemInfo.duration),
            listScrollBoxNode: this.itemInfo.listScrollBoxNode
          });
          app.mount(root);
          this.vueApp = app;
        }
        onDestroy() {
          var _a;
          (_a = this.vueApp) == null ? void 0 : _a.unmount();
        }
      }
      class FileListScrollHistory {
        constructor() {
          Object.defineProperty(this, "scrollBox", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
          });
          Object.defineProperty(this, "storage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new FileListScrollHistoryStorage()
          });
          Object.defineProperty(this, "handleScroll", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: throttle(() => {
              var _a;
              const scrollTop = ((_a = this.scrollBox) == null ? void 0 : _a.scrollTop) ?? 0;
              this.save(_unsafeWindow.FileMainReInstanceSetting, scrollTop);
            }, 16.666666666666668, {
              leading: true,
              trailing: true
            })
          });
        }
        /** 清除所有数据 */
        clearAll() {
          this.storage.clear();
        }
        /** 销毁 */
        destroy() {
          var _a;
          this.clearAll();
          (_a = this.scrollBox) == null ? void 0 : _a.removeEventListener("scroll", this.handleScroll);
        }
        /**
         * 设置滚动容器
         * @param scrollBox 滚动容器
         */
        setScrollBox(scrollBox) {
          if (this.scrollBox) {
            this.scrollBox.removeEventListener("scroll", this.handleScroll);
          }
          this.scrollBox = scrollBox;
          this.restore(_unsafeWindow.FileMainReInstanceSetting, scrollBox);
          this.scrollBox.addEventListener("scroll", this.handleScroll);
        }
        /**
         * 保存滚动位置
         */
        save(settings, position) {
          this.storage.set(settings.cid.toString(), Number(settings.offset), Number(settings.limit), position);
        }
        /**
         * 恢复滚动位置
         */
        restore(settings, scrollBox) {
          let position = this.storage.get(settings.cid.toString(), Number(settings.offset), Number(settings.limit));
          if (!position || position <= 0) {
            position = this.storage.getNearestPosition(settings.cid.toString(), Number(settings.offset), Number(settings.limit));
          }
          if (position && position > 0) {
            scrollBox.scrollTo({
              top: position,
              behavior: "instant"
            });
            return true;
          }
          return false;
        }
      }
      class FileListScrollHistoryStorage {
        constructor() {
          Object.defineProperty(this, "STORAGE_KEY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "115_master_file_list_scroll_history"
          });
          Object.defineProperty(this, "store", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: window.sessionStorage
          });
        }
        /** 存储数据 */
        get storeData() {
          return JSON.parse(this.store.getItem(this.STORAGE_KEY) ?? "{}");
        }
        /**
         * 设置存储数据
         * @param data 存储数据
         */
        set storeData(data) {
          this.store.setItem(this.STORAGE_KEY, JSON.stringify(data));
        }
        /**
         * 获取滚动位置
         * @param cid 目录id
         * @param offset 页偏移量
         * @param limit 页大小
         * @returns 滚动位置
         */
        get(cid, offset, limit) {
          const storeData = this.storeData;
          return storeData[this.getDataKey(cid, offset, limit)] ?? 0;
        }
        /**
         * 获取最接近的滚动位置（用于移动文件后 offset 可能变化的情况）
         * @param cid 目录id
         * @param currentOffset 当前页偏移量
         * @param limit 页大小
         * @returns 最接近的滚动位置
         */
        getNearestPosition(cid, currentOffset, limit) {
          const storeData = this.storeData;
          const prefix2 = `${cid}-`;
          let nearestPosition = 0;
          let minDiff = Infinity;
          for (const [key, position] of Object.entries(storeData)) {
            if (key.startsWith(prefix2)) {
              const parts = key.split("-");
              if (parts.length >= 3) {
                const storedOffset = Number.parseInt(parts[1]);
                const storedLimit = Number.parseInt(parts[2]);
                if (storedLimit === limit && typeof position === "number" && position > 0) {
                  const diff = Math.abs(storedOffset - currentOffset);
                  if (diff < minDiff) {
                    minDiff = diff;
                    nearestPosition = position;
                  }
                }
              }
            }
          }
          if (nearestPosition > 0 && minDiff <= limit * 2) {
            return nearestPosition;
          }
          return 0;
        }
        /**
         * 设置滚动位置
         * @param cid 目录id
         * @param offset 页偏移量
         * @param limit 页大小
         * @param position 滚动位置
         */
        set(cid, offset, limit, position) {
          const storeData = this.storeData;
          storeData[this.getDataKey(cid, offset, limit)] = position;
          this.storeData = storeData;
        }
        /** 清除所有数据 */
        clear() {
          this.storeData = {};
        }
        /**
         * 获取数据 key
         * @param cid 目录id
         * @param offset 页偏移量
         * @param limit 页大小
         * @returns 数据 key
         */
        getDataKey(cid, offset, limit) {
          return `${cid}-${offset}-${limit}`;
        }
      }
      const itemMods = [
        FileItemModVideoCover,
        FileItemModExtMenu,
        FileItemModClickPlay,
        FileItemModDownload
      ];
      class FileListMod extends BaseMod {
        constructor() {
          super();
          Object.defineProperty(this, "itemModLoaderMaps", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: /* @__PURE__ */ new Map()
          });
          Object.defineProperty(this, "observerContent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
          });
          Object.defineProperty(this, "scrollHistory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
          });
          this.init();
        }
        /**
         * 获取文件列表容器节点
         */
        get dataListBoxNode() {
          return document.querySelector(_unsafeWindow.Main.CONFIG.DataListBox);
        }
        /** 获取文件列表dom */
        get listCellNode() {
          return document.querySelector(".list-cell") ?? null;
        }
        /**
         * 获取文件列表内容节点
         */
        get listContentsNode() {
          var _a;
          return (_a = this.listCellNode) == null ? void 0 : _a.querySelector(".list-contents");
        }
        /**
         * 获取文件列表内容节点
         */
        get listThumbNode() {
          var _a;
          return (_a = this.listCellNode) == null ? void 0 : _a.querySelector(".list-thumb");
        }
        /**
         * 获取文件列表滚动容器节点
         */
        get listScrollBoxNode() {
          return this.listContentsNode ?? this.listThumbNode;
        }
        /**
         * 获取文件列表类型
         */
        get listType() {
          if (this.listContentsNode) {
            return FileListType.list;
          }
          return FileListType.grid;
        }
        /**
         * 获取文件列表 Item Nodes
         */
        get itemNodes() {
          var _a;
          return (_a = this.listCellNode) == null ? void 0 : _a.querySelectorAll("li");
        }
        /**
         * 销毁
         */
        destroy() {
          var _a, _b;
          (_a = this.observerContent) == null ? void 0 : _a.disconnect();
          this.destroyAllItemModLoader();
          (_b = this.scrollHistory) == null ? void 0 : _b.destroy();
        }
        /**
         * 初始化
         */
        async init() {
          var _a;
          this.updateItems();
          this.scrollHistory = new FileListScrollHistory();
          if (this.listScrollBoxNode) {
            (_a = this.scrollHistory) == null ? void 0 : _a.setScrollBox(this.listScrollBoxNode);
          }
          this.watchItemsChange();
        }
        /**
         * 监听文件列表 Item 变化
         */
        watchItemsChange() {
          let observerContent = null;
          observerContent = new MutationObserver((mutations) => {
            var _a;
            for (const mutation of mutations) {
              if (mutation.target.isSameNode(this.dataListBoxNode) && mutation.addedNodes.length > 0) {
                this.updateItems();
                this.listScrollBoxNode && ((_a = this.scrollHistory) == null ? void 0 : _a.setScrollBox(this.listScrollBoxNode));
                break;
              }
            }
          });
          if (!this.dataListBoxNode) {
            console.error("文件列表容器节点不存在, 无法监听文件列表变化");
            return;
          }
          observerContent.observe(this.dataListBoxNode, {
            childList: true
          });
          this.observerContent = observerContent;
        }
        /**
         * 更新文件列表
         */
        updateItems() {
          const itemNodes = this.itemNodes;
          const itemsSet = new Set(itemNodes);
          if (!itemsSet) {
            return;
          }
          for (const item of itemsSet) {
            if (this.itemModLoaderMaps.has(item)) {
              continue;
            }
            const itemModLoader = new FileItemModLoader(item, this.listType, this.listScrollBoxNode, itemMods);
            itemModLoader.load();
            this.itemModLoaderMaps.set(item, itemModLoader);
          }
          for (const [key, value] of this.itemModLoaderMaps.entries()) {
            if (itemsSet.has(key)) {
              continue;
            }
            value.destroy();
            this.itemModLoaderMaps.delete(key);
          }
        }
        /**
         * 销毁所有 Item Mod Loader
         */
        destroyAllItemModLoader() {
          this.itemModLoaderMaps.forEach((item) => {
            item.destroy();
          });
          this.itemModLoaderMaps.clear();
        }
      }
      /**
      * (c) Iconify
      *
      * For the full copyright and license information, please view the license.txt
      * files at https://github.com/iconify/iconify
      *
      * Licensed under MIT.
      *
      * @license MIT
      * @version 3.0.0
      */
      const defaultIconDimensions = Object.freeze(
        {
          left: 0,
          top: 0,
          width: 16,
          height: 16
        }
      );
      const defaultIconTransformations = Object.freeze({
        rotate: 0,
        vFlip: false,
        hFlip: false
      });
      const defaultIconProps = Object.freeze({
        ...defaultIconDimensions,
        ...defaultIconTransformations
      });
      const defaultExtendedIconProps = Object.freeze({
        ...defaultIconProps,
        body: "",
        hidden: false
      });
      const defaultIconSizeCustomisations = Object.freeze({
        width: null,
        height: null
      });
      const defaultIconCustomisations = Object.freeze({
        // Dimensions
        ...defaultIconSizeCustomisations,
        // Transformations
        ...defaultIconTransformations
      });
      function rotateFromString(value, defaultValue = 0) {
        const units = value.replace(/^-?[0-9.]*/, "");
        function cleanup(value2) {
          while (value2 < 0) {
            value2 += 4;
          }
          return value2 % 4;
        }
        if (units === "") {
          const num = parseInt(value);
          return isNaN(num) ? 0 : cleanup(num);
        } else if (units !== value) {
          let split = 0;
          switch (units) {
            case "%":
              split = 25;
              break;
            case "deg":
              split = 90;
          }
          if (split) {
            let num = parseFloat(value.slice(0, value.length - units.length));
            if (isNaN(num)) {
              return 0;
            }
            num = num / split;
            return num % 1 === 0 ? cleanup(num) : 0;
          }
        }
        return defaultValue;
      }
      const separator = /[\s,]+/;
      function flipFromString(custom, flip) {
        flip.split(separator).forEach((str) => {
          const value = str.trim();
          switch (value) {
            case "horizontal":
              custom.hFlip = true;
              break;
            case "vertical":
              custom.vFlip = true;
              break;
          }
        });
      }
      const defaultCustomisations = {
        ...defaultIconCustomisations,
        preserveAspectRatio: ""
      };
      function getCustomisations(node) {
        const customisations = {
          ...defaultCustomisations
        };
        const attr = (key, def) => node.getAttribute(key) || def;
        customisations.width = attr("width", null);
        customisations.height = attr("height", null);
        customisations.rotate = rotateFromString(attr("rotate", ""));
        flipFromString(customisations, attr("flip", ""));
        customisations.preserveAspectRatio = attr("preserveAspectRatio", attr("preserveaspectratio", ""));
        return customisations;
      }
      function haveCustomisationsChanged(value1, value2) {
        for (const key in defaultCustomisations) {
          if (value1[key] !== value2[key]) {
            return true;
          }
        }
        return false;
      }
      const matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
      const stringToIcon = (value, validate, allowSimpleName, provider = "") => {
        const colonSeparated = value.split(":");
        if (value.slice(0, 1) === "@") {
          if (colonSeparated.length < 2 || colonSeparated.length > 3) {
            return null;
          }
          provider = colonSeparated.shift().slice(1);
        }
        if (colonSeparated.length > 3 || !colonSeparated.length) {
          return null;
        }
        if (colonSeparated.length > 1) {
          const name2 = colonSeparated.pop();
          const prefix2 = colonSeparated.pop();
          const result2 = {
            // Allow provider without '@': "provider:prefix:name"
            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
            prefix: prefix2,
            name: name2
          };
          return validate && !validateIconName(result2) ? null : result2;
        }
        const name = colonSeparated[0];
        const dashSeparated = name.split("-");
        if (dashSeparated.length > 1) {
          const result2 = {
            provider,
            prefix: dashSeparated.shift(),
            name: dashSeparated.join("-")
          };
          return validate && !validateIconName(result2) ? null : result2;
        }
        if (allowSimpleName && provider === "") {
          const result2 = {
            provider,
            prefix: "",
            name
          };
          return validate && !validateIconName(result2, allowSimpleName) ? null : result2;
        }
        return null;
      };
      const validateIconName = (icon, allowSimpleName) => {
        if (!icon) {
          return false;
        }
        return !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
        // Check name: cannot be empty
        ((allowSimpleName && icon.prefix === "" || !!icon.prefix) && !!icon.name);
      };
      function mergeIconTransformations(obj1, obj2) {
        const result2 = {};
        if (!obj1.hFlip !== !obj2.hFlip) {
          result2.hFlip = true;
        }
        if (!obj1.vFlip !== !obj2.vFlip) {
          result2.vFlip = true;
        }
        const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
        if (rotate) {
          result2.rotate = rotate;
        }
        return result2;
      }
      function mergeIconData(parent, child) {
        const result2 = mergeIconTransformations(parent, child);
        for (const key in defaultExtendedIconProps) {
          if (key in defaultIconTransformations) {
            if (key in parent && !(key in result2)) {
              result2[key] = defaultIconTransformations[key];
            }
          } else if (key in child) {
            result2[key] = child[key];
          } else if (key in parent) {
            result2[key] = parent[key];
          }
        }
        return result2;
      }
      function getIconsTree(data, names) {
        const icons = data.icons;
        const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
        const resolved = /* @__PURE__ */ Object.create(null);
        function resolve(name) {
          if (icons[name]) {
            return resolved[name] = [];
          }
          if (!(name in resolved)) {
            resolved[name] = null;
            const parent = aliases[name] && aliases[name].parent;
            const value = parent && resolve(parent);
            if (value) {
              resolved[name] = [parent].concat(value);
            }
          }
          return resolved[name];
        }
        Object.keys(icons).concat(Object.keys(aliases)).forEach(resolve);
        return resolved;
      }
      function internalGetIconData(data, name, tree) {
        const icons = data.icons;
        const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
        let currentProps = {};
        function parse(name2) {
          currentProps = mergeIconData(
            icons[name2] || aliases[name2],
            currentProps
          );
        }
        parse(name);
        tree.forEach(parse);
        return mergeIconData(data, currentProps);
      }
      function parseIconSet(data, callback) {
        const names = [];
        if (typeof data !== "object" || typeof data.icons !== "object") {
          return names;
        }
        if (data.not_found instanceof Array) {
          data.not_found.forEach((name) => {
            callback(name, null);
            names.push(name);
          });
        }
        const tree = getIconsTree(data);
        for (const name in tree) {
          const item = tree[name];
          if (item) {
            callback(name, internalGetIconData(data, name, item));
            names.push(name);
          }
        }
        return names;
      }
      const optionalPropertyDefaults = {
        provider: "",
        aliases: {},
        not_found: {},
        ...defaultIconDimensions
      };
      function checkOptionalProps(item, defaults) {
        for (const prop in defaults) {
          if (prop in item && typeof item[prop] !== typeof defaults[prop]) {
            return false;
          }
        }
        return true;
      }
      function quicklyValidateIconSet(obj) {
        if (typeof obj !== "object" || obj === null) {
          return null;
        }
        const data = obj;
        if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
          return null;
        }
        if (!checkOptionalProps(obj, optionalPropertyDefaults)) {
          return null;
        }
        const icons = data.icons;
        for (const name in icons) {
          const icon = icons[name];
          if (
            // Name cannot be empty
            !name || // Must have body
            typeof icon.body !== "string" || // Check other props
            !checkOptionalProps(
              icon,
              defaultExtendedIconProps
            )
          ) {
            return null;
          }
        }
        const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
        for (const name in aliases) {
          const icon = aliases[name];
          const parent = icon.parent;
          if (
            // Name cannot be empty
            !name || // Parent must be set and point to existing icon
            typeof parent !== "string" || !icons[parent] && !aliases[parent] || // Check other props
            !checkOptionalProps(
              icon,
              defaultExtendedIconProps
            )
          ) {
            return null;
          }
        }
        return data;
      }
      const dataStorage = /* @__PURE__ */ Object.create(null);
      function newStorage(provider, prefix2) {
        return {
          provider,
          prefix: prefix2,
          icons: /* @__PURE__ */ Object.create(null),
          missing: /* @__PURE__ */ new Set()
        };
      }
      function getStorage(provider, prefix2) {
        const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));
        return providerStorage[prefix2] || (providerStorage[prefix2] = newStorage(provider, prefix2));
      }
      function addIconSet(storage2, data) {
        if (!quicklyValidateIconSet(data)) {
          return [];
        }
        return parseIconSet(data, (name, icon) => {
          if (icon) {
            storage2.icons[name] = icon;
          } else {
            storage2.missing.add(name);
          }
        });
      }
      function addIconToStorage(storage2, name, icon) {
        try {
          if (typeof icon.body === "string") {
            storage2.icons[name] = { ...icon };
            return true;
          }
        } catch (err) {
        }
        return false;
      }
      function listIcons$1(provider, prefix2) {
        let allIcons = [];
        const providers = typeof provider === "string" ? [provider] : Object.keys(dataStorage);
        providers.forEach((provider2) => {
          const prefixes = typeof provider2 === "string" && typeof prefix2 === "string" ? [prefix2] : Object.keys(dataStorage[provider2] || {});
          prefixes.forEach((prefix22) => {
            const storage2 = getStorage(provider2, prefix22);
            allIcons = allIcons.concat(
              Object.keys(storage2.icons).map(
                (name) => (provider2 !== "" ? "@" + provider2 + ":" : "") + prefix22 + ":" + name
              )
            );
          });
        });
        return allIcons;
      }
      let simpleNames = false;
      function allowSimpleNames(allow) {
        if (typeof allow === "boolean") {
          simpleNames = allow;
        }
        return simpleNames;
      }
      function getIconData(name) {
        const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;
        if (icon) {
          const storage2 = getStorage(icon.provider, icon.prefix);
          const iconName = icon.name;
          return storage2.icons[iconName] || (storage2.missing.has(iconName) ? null : void 0);
        }
      }
      function addIcon$1(name, data) {
        const icon = stringToIcon(name, true, simpleNames);
        if (!icon) {
          return false;
        }
        const storage2 = getStorage(icon.provider, icon.prefix);
        if (data) {
          return addIconToStorage(storage2, icon.name, data);
        } else {
          storage2.missing.add(icon.name);
          return true;
        }
      }
      function addCollection$1(data, provider) {
        if (typeof data !== "object") {
          return false;
        }
        if (typeof provider !== "string") {
          provider = data.provider || "";
        }
        if (simpleNames && !provider && !data.prefix) {
          let added = false;
          if (quicklyValidateIconSet(data)) {
            data.prefix = "";
            parseIconSet(data, (name, icon) => {
              if (addIcon$1(name, icon)) {
                added = true;
              }
            });
          }
          return added;
        }
        const prefix2 = data.prefix;
        if (!validateIconName({
          prefix: prefix2,
          name: "a"
        })) {
          return false;
        }
        const storage2 = getStorage(provider, prefix2);
        return !!addIconSet(storage2, data);
      }
      function iconLoaded$1(name) {
        return !!getIconData(name);
      }
      function getIcon$1(name) {
        const result2 = getIconData(name);
        return result2 ? {
          ...defaultIconProps,
          ...result2
        } : result2;
      }
      function sortIcons(icons) {
        const result2 = {
          loaded: [],
          missing: [],
          pending: []
        };
        const storage2 = /* @__PURE__ */ Object.create(null);
        icons.sort((a, b) => {
          if (a.provider !== b.provider) {
            return a.provider.localeCompare(b.provider);
          }
          if (a.prefix !== b.prefix) {
            return a.prefix.localeCompare(b.prefix);
          }
          return a.name.localeCompare(b.name);
        });
        let lastIcon = {
          provider: "",
          prefix: "",
          name: ""
        };
        icons.forEach((icon) => {
          if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
            return;
          }
          lastIcon = icon;
          const provider = icon.provider;
          const prefix2 = icon.prefix;
          const name = icon.name;
          const providerStorage = storage2[provider] || (storage2[provider] = /* @__PURE__ */ Object.create(null));
          const localStorage = providerStorage[prefix2] || (providerStorage[prefix2] = getStorage(provider, prefix2));
          let list;
          if (name in localStorage.icons) {
            list = result2.loaded;
          } else if (prefix2 === "" || localStorage.missing.has(name)) {
            list = result2.missing;
          } else {
            list = result2.pending;
          }
          const item = {
            provider,
            prefix: prefix2,
            name
          };
          list.push(item);
        });
        return result2;
      }
      function removeCallback(storages, id) {
        storages.forEach((storage2) => {
          const items = storage2.loaderCallbacks;
          if (items) {
            storage2.loaderCallbacks = items.filter((row) => row.id !== id);
          }
        });
      }
      function updateCallbacks(storage2) {
        if (!storage2.pendingCallbacksFlag) {
          storage2.pendingCallbacksFlag = true;
          setTimeout(() => {
            storage2.pendingCallbacksFlag = false;
            const items = storage2.loaderCallbacks ? storage2.loaderCallbacks.slice(0) : [];
            if (!items.length) {
              return;
            }
            let hasPending = false;
            const provider = storage2.provider;
            const prefix2 = storage2.prefix;
            items.forEach((item) => {
              const icons = item.icons;
              const oldLength = icons.pending.length;
              icons.pending = icons.pending.filter((icon) => {
                if (icon.prefix !== prefix2) {
                  return true;
                }
                const name = icon.name;
                if (storage2.icons[name]) {
                  icons.loaded.push({
                    provider,
                    prefix: prefix2,
                    name
                  });
                } else if (storage2.missing.has(name)) {
                  icons.missing.push({
                    provider,
                    prefix: prefix2,
                    name
                  });
                } else {
                  hasPending = true;
                  return true;
                }
                return false;
              });
              if (icons.pending.length !== oldLength) {
                if (!hasPending) {
                  removeCallback([storage2], item.id);
                }
                item.callback(
                  icons.loaded.slice(0),
                  icons.missing.slice(0),
                  icons.pending.slice(0),
                  item.abort
                );
              }
            });
          });
        }
      }
      let idCounter = 0;
      function storeCallback(callback, icons, pendingSources) {
        const id = idCounter++;
        const abort = removeCallback.bind(null, pendingSources, id);
        if (!icons.pending.length) {
          return abort;
        }
        const item = {
          id,
          icons,
          callback,
          abort
        };
        pendingSources.forEach((storage2) => {
          (storage2.loaderCallbacks || (storage2.loaderCallbacks = [])).push(item);
        });
        return abort;
      }
      const storage = /* @__PURE__ */ Object.create(null);
      function setAPIModule(provider, item) {
        storage[provider] = item;
      }
      function getAPIModule(provider) {
        return storage[provider] || storage[""];
      }
      function listToIcons(list, validate = true, simpleNames2 = false) {
        const result2 = [];
        list.forEach((item) => {
          const icon = typeof item === "string" ? stringToIcon(item, validate, simpleNames2) : item;
          if (icon) {
            result2.push(icon);
          }
        });
        return result2;
      }
      var defaultConfig = {
        resources: [],
        index: 0,
        timeout: 2e3,
        rotate: 750,
        random: false,
        dataAfterTimeout: false
      };
      function sendQuery(config, payload, query, done) {
        const resourcesCount = config.resources.length;
        const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;
        let resources;
        if (config.random) {
          let list = config.resources.slice(0);
          resources = [];
          while (list.length > 1) {
            const nextIndex = Math.floor(Math.random() * list.length);
            resources.push(list[nextIndex]);
            list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
          }
          resources = resources.concat(list);
        } else {
          resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));
        }
        const startTime = Date.now();
        let status = "pending";
        let queriesSent = 0;
        let lastError;
        let timer = null;
        let queue = [];
        let doneCallbacks = [];
        if (typeof done === "function") {
          doneCallbacks.push(done);
        }
        function resetTimer() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function abort() {
          if (status === "pending") {
            status = "aborted";
          }
          resetTimer();
          queue.forEach((item) => {
            if (item.status === "pending") {
              item.status = "aborted";
            }
          });
          queue = [];
        }
        function subscribe(callback, overwrite) {
          if (overwrite) {
            doneCallbacks = [];
          }
          if (typeof callback === "function") {
            doneCallbacks.push(callback);
          }
        }
        function getQueryStatus() {
          return {
            startTime,
            payload,
            status,
            queriesSent,
            queriesPending: queue.length,
            subscribe,
            abort
          };
        }
        function failQuery() {
          status = "failed";
          doneCallbacks.forEach((callback) => {
            callback(void 0, lastError);
          });
        }
        function clearQueue() {
          queue.forEach((item) => {
            if (item.status === "pending") {
              item.status = "aborted";
            }
          });
          queue = [];
        }
        function moduleResponse(item, response, data) {
          const isError = response !== "success";
          queue = queue.filter((queued) => queued !== item);
          switch (status) {
            case "pending":
              break;
            case "failed":
              if (isError || !config.dataAfterTimeout) {
                return;
              }
              break;
            default:
              return;
          }
          if (response === "abort") {
            lastError = data;
            failQuery();
            return;
          }
          if (isError) {
            lastError = data;
            if (!queue.length) {
              if (!resources.length) {
                failQuery();
              } else {
                execNext();
              }
            }
            return;
          }
          resetTimer();
          clearQueue();
          if (!config.random) {
            const index = config.resources.indexOf(item.resource);
            if (index !== -1 && index !== config.index) {
              config.index = index;
            }
          }
          status = "completed";
          doneCallbacks.forEach((callback) => {
            callback(data);
          });
        }
        function execNext() {
          if (status !== "pending") {
            return;
          }
          resetTimer();
          const resource = resources.shift();
          if (resource === void 0) {
            if (queue.length) {
              timer = setTimeout(() => {
                resetTimer();
                if (status === "pending") {
                  clearQueue();
                  failQuery();
                }
              }, config.timeout);
              return;
            }
            failQuery();
            return;
          }
          const item = {
            status: "pending",
            resource,
            callback: (status2, data) => {
              moduleResponse(item, status2, data);
            }
          };
          queue.push(item);
          queriesSent++;
          timer = setTimeout(execNext, config.rotate);
          query(resource, payload, item.callback);
        }
        setTimeout(execNext);
        return getQueryStatus;
      }
      function initRedundancy(cfg) {
        const config = {
          ...defaultConfig,
          ...cfg
        };
        let queries = [];
        function cleanup() {
          queries = queries.filter((item) => item().status === "pending");
        }
        function query(payload, queryCallback, doneCallback) {
          const query2 = sendQuery(
            config,
            payload,
            queryCallback,
            (data, error) => {
              cleanup();
              if (doneCallback) {
                doneCallback(data, error);
              }
            }
          );
          queries.push(query2);
          return query2;
        }
        function find(callback) {
          return queries.find((value) => {
            return callback(value);
          }) || null;
        }
        const instance = {
          query,
          find,
          setIndex: (index) => {
            config.index = index;
          },
          getIndex: () => config.index,
          cleanup
        };
        return instance;
      }
      function createAPIConfig(source) {
        let resources;
        if (typeof source.resources === "string") {
          resources = [source.resources];
        } else {
          resources = source.resources;
          if (!(resources instanceof Array) || !resources.length) {
            return null;
          }
        }
        const result2 = {
          // API hosts
          resources,
          // Root path
          path: source.path || "/",
          // URL length limit
          maxURL: source.maxURL || 500,
          // Timeout before next host is used.
          rotate: source.rotate || 750,
          // Timeout before failing query.
          timeout: source.timeout || 5e3,
          // Randomise default API end point.
          random: source.random === true,
          // Start index
          index: source.index || 0,
          // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
          dataAfterTimeout: source.dataAfterTimeout !== false
        };
        return result2;
      }
      const configStorage = /* @__PURE__ */ Object.create(null);
      const fallBackAPISources = [
        "https://api.simplesvg.com",
        "https://api.unisvg.com"
      ];
      const fallBackAPI = [];
      while (fallBackAPISources.length > 0) {
        if (fallBackAPISources.length === 1) {
          fallBackAPI.push(fallBackAPISources.shift());
        } else {
          if (Math.random() > 0.5) {
            fallBackAPI.push(fallBackAPISources.shift());
          } else {
            fallBackAPI.push(fallBackAPISources.pop());
          }
        }
      }
      configStorage[""] = createAPIConfig({
        resources: ["https://api.iconify.design"].concat(fallBackAPI)
      });
      function addAPIProvider$1(provider, customConfig) {
        const config = createAPIConfig(customConfig);
        if (config === null) {
          return false;
        }
        configStorage[provider] = config;
        return true;
      }
      function getAPIConfig(provider) {
        return configStorage[provider];
      }
      function listAPIProviders() {
        return Object.keys(configStorage);
      }
      function emptyCallback$1() {
      }
      const redundancyCache = /* @__PURE__ */ Object.create(null);
      function getRedundancyCache(provider) {
        if (!redundancyCache[provider]) {
          const config = getAPIConfig(provider);
          if (!config) {
            return;
          }
          const redundancy = initRedundancy(config);
          const cachedReundancy = {
            config,
            redundancy
          };
          redundancyCache[provider] = cachedReundancy;
        }
        return redundancyCache[provider];
      }
      function sendAPIQuery(target, query, callback) {
        let redundancy;
        let send2;
        if (typeof target === "string") {
          const api = getAPIModule(target);
          if (!api) {
            callback(void 0, 424);
            return emptyCallback$1;
          }
          send2 = api.send;
          const cached = getRedundancyCache(target);
          if (cached) {
            redundancy = cached.redundancy;
          }
        } else {
          const config = createAPIConfig(target);
          if (config) {
            redundancy = initRedundancy(config);
            const moduleKey = target.resources ? target.resources[0] : "";
            const api = getAPIModule(moduleKey);
            if (api) {
              send2 = api.send;
            }
          }
        }
        if (!redundancy || !send2) {
          callback(void 0, 424);
          return emptyCallback$1;
        }
        return redundancy.query(query, send2, callback)().abort;
      }
      function emptyCallback() {
      }
      function loadedNewIcons(storage2) {
        if (!storage2.iconsLoaderFlag) {
          storage2.iconsLoaderFlag = true;
          setTimeout(() => {
            storage2.iconsLoaderFlag = false;
            updateCallbacks(storage2);
          });
        }
      }
      function checkIconNamesForAPI(icons) {
        const valid = [];
        const invalid = [];
        icons.forEach((name) => {
          (name.match(matchIconName) ? valid : invalid).push(name);
        });
        return {
          valid,
          invalid
        };
      }
      function parseLoaderResponse(storage2, icons, data) {
        function checkMissing() {
          const pending = storage2.pendingIcons;
          icons.forEach((name) => {
            if (pending) {
              pending.delete(name);
            }
            if (!storage2.icons[name]) {
              storage2.missing.add(name);
            }
          });
        }
        if (data && typeof data === "object") {
          try {
            const parsed = addIconSet(storage2, data);
            if (!parsed.length) {
              checkMissing();
              return;
            }
          } catch (err) {
            console.error(err);
          }
        }
        checkMissing();
        loadedNewIcons(storage2);
      }
      function parsePossiblyAsyncResponse(response, callback) {
        if (response instanceof Promise) {
          response.then((data) => {
            callback(data);
          }).catch(() => {
            callback(null);
          });
        } else {
          callback(response);
        }
      }
      function loadNewIcons(storage2, icons) {
        if (!storage2.iconsToLoad) {
          storage2.iconsToLoad = icons;
        } else {
          storage2.iconsToLoad = storage2.iconsToLoad.concat(icons).sort();
        }
        if (!storage2.iconsQueueFlag) {
          storage2.iconsQueueFlag = true;
          setTimeout(() => {
            storage2.iconsQueueFlag = false;
            const { provider, prefix: prefix2 } = storage2;
            const icons2 = storage2.iconsToLoad;
            delete storage2.iconsToLoad;
            if (!icons2 || !icons2.length) {
              return;
            }
            const customIconLoader = storage2.loadIcon;
            if (storage2.loadIcons && (icons2.length > 1 || !customIconLoader)) {
              parsePossiblyAsyncResponse(
                storage2.loadIcons(icons2, prefix2, provider),
                (data) => {
                  parseLoaderResponse(storage2, icons2, data);
                }
              );
              return;
            }
            if (customIconLoader) {
              icons2.forEach((name) => {
                const response = customIconLoader(name, prefix2, provider);
                parsePossiblyAsyncResponse(response, (data) => {
                  const iconSet = data ? {
                    prefix: prefix2,
                    icons: {
                      [name]: data
                    }
                  } : null;
                  parseLoaderResponse(storage2, [name], iconSet);
                });
              });
              return;
            }
            const { valid, invalid } = checkIconNamesForAPI(icons2);
            if (invalid.length) {
              parseLoaderResponse(storage2, invalid, null);
            }
            if (!valid.length) {
              return;
            }
            const api = prefix2.match(matchIconName) ? getAPIModule(provider) : null;
            if (!api) {
              parseLoaderResponse(storage2, valid, null);
              return;
            }
            const params = api.prepare(provider, prefix2, valid);
            params.forEach((item) => {
              sendAPIQuery(provider, item, (data) => {
                parseLoaderResponse(storage2, item.icons, data);
              });
            });
          });
        }
      }
      const loadIcons$1 = (icons, callback) => {
        const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
        const sortedIcons = sortIcons(cleanedIcons);
        if (!sortedIcons.pending.length) {
          let callCallback = true;
          if (callback) {
            setTimeout(() => {
              if (callCallback) {
                callback(
                  sortedIcons.loaded,
                  sortedIcons.missing,
                  sortedIcons.pending,
                  emptyCallback
                );
              }
            });
          }
          return () => {
            callCallback = false;
          };
        }
        const newIcons = /* @__PURE__ */ Object.create(null);
        const sources = [];
        let lastProvider, lastPrefix;
        sortedIcons.pending.forEach((icon) => {
          const { provider, prefix: prefix2 } = icon;
          if (prefix2 === lastPrefix && provider === lastProvider) {
            return;
          }
          lastProvider = provider;
          lastPrefix = prefix2;
          sources.push(getStorage(provider, prefix2));
          const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));
          if (!providerNewIcons[prefix2]) {
            providerNewIcons[prefix2] = [];
          }
        });
        sortedIcons.pending.forEach((icon) => {
          const { provider, prefix: prefix2, name } = icon;
          const storage2 = getStorage(provider, prefix2);
          const pendingQueue = storage2.pendingIcons || (storage2.pendingIcons = /* @__PURE__ */ new Set());
          if (!pendingQueue.has(name)) {
            pendingQueue.add(name);
            newIcons[provider][prefix2].push(name);
          }
        });
        sources.forEach((storage2) => {
          const list = newIcons[storage2.provider][storage2.prefix];
          if (list.length) {
            loadNewIcons(storage2, list);
          }
        });
        return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;
      };
      const loadIcon$1 = (icon) => {
        return new Promise((fulfill, reject) => {
          const iconObj = typeof icon === "string" ? stringToIcon(icon, true) : icon;
          if (!iconObj) {
            reject(icon);
            return;
          }
          loadIcons$1([iconObj || icon], (loaded) => {
            if (loaded.length && iconObj) {
              const data = getIconData(iconObj);
              if (data) {
                fulfill({
                  ...defaultIconProps,
                  ...data
                });
                return;
              }
            }
            reject(icon);
          });
        });
      };
      function testIconObject(value) {
        try {
          const obj = typeof value === "string" ? JSON.parse(value) : value;
          if (typeof obj.body === "string") {
            return {
              ...obj
            };
          }
        } catch (err) {
        }
      }
      function parseIconValue(value, onload) {
        if (typeof value === "object") {
          const data2 = testIconObject(value);
          return {
            data: data2,
            value
          };
        }
        if (typeof value !== "string") {
          return {
            value
          };
        }
        if (value.includes("{")) {
          const data2 = testIconObject(value);
          if (data2) {
            return {
              data: data2,
              value
            };
          }
        }
        const name = stringToIcon(value, true, true);
        if (!name) {
          return {
            value
          };
        }
        const data = getIconData(name);
        if (data !== void 0 || !name.prefix) {
          return {
            value,
            name,
            data
            // could be 'null' -> icon is missing
          };
        }
        const loading = loadIcons$1([name], () => onload(value, name, getIconData(name)));
        return {
          value,
          name,
          loading
        };
      }
      let isBuggedSafari = false;
      try {
        isBuggedSafari = navigator.vendor.indexOf("Apple") === 0;
      } catch (err) {
      }
      function getRenderMode(body, mode) {
        switch (mode) {
          // Force mode
          case "svg":
          case "bg":
          case "mask":
            return mode;
        }
        if (mode !== "style" && (isBuggedSafari || body.indexOf("<a") === -1)) {
          return "svg";
        }
        return body.indexOf("currentColor") === -1 ? "bg" : "mask";
      }
      const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
      const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
      function calculateSize$1(size, ratio, precision) {
        if (ratio === 1) {
          return size;
        }
        precision = precision || 100;
        if (typeof size === "number") {
          return Math.ceil(size * ratio * precision) / precision;
        }
        if (typeof size !== "string") {
          return size;
        }
        const oldParts = size.split(unitsSplit);
        if (oldParts === null || !oldParts.length) {
          return size;
        }
        const newParts = [];
        let code = oldParts.shift();
        let isNumber2 = unitsTest.test(code);
        while (true) {
          if (isNumber2) {
            const num = parseFloat(code);
            if (isNaN(num)) {
              newParts.push(code);
            } else {
              newParts.push(Math.ceil(num * ratio * precision) / precision);
            }
          } else {
            newParts.push(code);
          }
          code = oldParts.shift();
          if (code === void 0) {
            return newParts.join("");
          }
          isNumber2 = !isNumber2;
        }
      }
      function splitSVGDefs(content, tag = "defs") {
        let defs = "";
        const index = content.indexOf("<" + tag);
        while (index >= 0) {
          const start = content.indexOf(">", index);
          const end = content.indexOf("</" + tag);
          if (start === -1 || end === -1) {
            break;
          }
          const endEnd = content.indexOf(">", end);
          if (endEnd === -1) {
            break;
          }
          defs += content.slice(start + 1, end).trim();
          content = content.slice(0, index).trim() + content.slice(endEnd + 1);
        }
        return {
          defs,
          content
        };
      }
      function mergeDefsAndContent(defs, content) {
        return defs ? "<defs>" + defs + "</defs>" + content : content;
      }
      function wrapSVGContent(body, start, end) {
        const split = splitSVGDefs(body);
        return mergeDefsAndContent(split.defs, start + split.content + end);
      }
      const isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
      function iconToSVG(icon, customisations) {
        const fullIcon = {
          ...defaultIconProps,
          ...icon
        };
        const fullCustomisations = {
          ...defaultIconCustomisations,
          ...customisations
        };
        const box = {
          left: fullIcon.left,
          top: fullIcon.top,
          width: fullIcon.width,
          height: fullIcon.height
        };
        let body = fullIcon.body;
        [fullIcon, fullCustomisations].forEach((props) => {
          const transformations = [];
          const hFlip = props.hFlip;
          const vFlip = props.vFlip;
          let rotation = props.rotate;
          if (hFlip) {
            if (vFlip) {
              rotation += 2;
            } else {
              transformations.push(
                "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
              );
              transformations.push("scale(-1 1)");
              box.top = box.left = 0;
            }
          } else if (vFlip) {
            transformations.push(
              "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
            );
            transformations.push("scale(1 -1)");
            box.top = box.left = 0;
          }
          let tempValue;
          if (rotation < 0) {
            rotation -= Math.floor(rotation / 4) * 4;
          }
          rotation = rotation % 4;
          switch (rotation) {
            case 1:
              tempValue = box.height / 2 + box.top;
              transformations.unshift(
                "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
              );
              break;
            case 2:
              transformations.unshift(
                "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
              );
              break;
            case 3:
              tempValue = box.width / 2 + box.left;
              transformations.unshift(
                "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
              );
              break;
          }
          if (rotation % 2 === 1) {
            if (box.left !== box.top) {
              tempValue = box.left;
              box.left = box.top;
              box.top = tempValue;
            }
            if (box.width !== box.height) {
              tempValue = box.width;
              box.width = box.height;
              box.height = tempValue;
            }
          }
          if (transformations.length) {
            body = wrapSVGContent(
              body,
              '<g transform="' + transformations.join(" ") + '">',
              "</g>"
            );
          }
        });
        const customisationsWidth = fullCustomisations.width;
        const customisationsHeight = fullCustomisations.height;
        const boxWidth = box.width;
        const boxHeight = box.height;
        let width;
        let height;
        if (customisationsWidth === null) {
          height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
          width = calculateSize$1(height, boxWidth / boxHeight);
        } else {
          width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
          height = customisationsHeight === null ? calculateSize$1(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
        }
        const attributes = {};
        const setAttr = (prop, value) => {
          if (!isUnsetKeyword(value)) {
            attributes[prop] = value.toString();
          }
        };
        setAttr("width", width);
        setAttr("height", height);
        const viewBox = [box.left, box.top, boxWidth, boxHeight];
        attributes.viewBox = viewBox.join(" ");
        return {
          attributes,
          viewBox,
          body
        };
      }
      function iconToHTML$1(body, attributes) {
        let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
        for (const attr in attributes) {
          renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
        }
        return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
      }
      function encodeSVGforURL(svg) {
        return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
      }
      function svgToData(svg) {
        return "data:image/svg+xml," + encodeSVGforURL(svg);
      }
      function svgToURL$1(svg) {
        return 'url("' + svgToData(svg) + '")';
      }
      const detectFetch = () => {
        let callback;
        try {
          callback = fetch;
          if (typeof callback === "function") {
            return callback;
          }
        } catch (err) {
        }
      };
      let fetchModule = detectFetch();
      function setFetch(fetch2) {
        fetchModule = fetch2;
      }
      function getFetch() {
        return fetchModule;
      }
      function calculateMaxLength(provider, prefix2) {
        const config = getAPIConfig(provider);
        if (!config) {
          return 0;
        }
        let result2;
        if (!config.maxURL) {
          result2 = 0;
        } else {
          let maxHostLength = 0;
          config.resources.forEach((item) => {
            const host = item;
            maxHostLength = Math.max(maxHostLength, host.length);
          });
          const url = prefix2 + ".json?icons=";
          result2 = config.maxURL - maxHostLength - config.path.length - url.length;
        }
        return result2;
      }
      function shouldAbort(status) {
        return status === 404;
      }
      const prepare = (provider, prefix2, icons) => {
        const results = [];
        const maxLength = calculateMaxLength(provider, prefix2);
        const type = "icons";
        let item = {
          type,
          provider,
          prefix: prefix2,
          icons: []
        };
        let length = 0;
        icons.forEach((name, index) => {
          length += name.length + 1;
          if (length >= maxLength && index > 0) {
            results.push(item);
            item = {
              type,
              provider,
              prefix: prefix2,
              icons: []
            };
            length = name.length;
          }
          item.icons.push(name);
        });
        results.push(item);
        return results;
      };
      function getPath(provider) {
        if (typeof provider === "string") {
          const config = getAPIConfig(provider);
          if (config) {
            return config.path;
          }
        }
        return "/";
      }
      const send = (host, params, callback) => {
        if (!fetchModule) {
          callback("abort", 424);
          return;
        }
        let path = getPath(params.provider);
        switch (params.type) {
          case "icons": {
            const prefix2 = params.prefix;
            const icons = params.icons;
            const iconsList = icons.join(",");
            const urlParams = new URLSearchParams({
              icons: iconsList
            });
            path += prefix2 + ".json?" + urlParams.toString();
            break;
          }
          case "custom": {
            const uri = params.uri;
            path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
            break;
          }
          default:
            callback("abort", 400);
            return;
        }
        let defaultError = 503;
        fetchModule(host + path).then((response) => {
          const status = response.status;
          if (status !== 200) {
            setTimeout(() => {
              callback(shouldAbort(status) ? "abort" : "next", status);
            });
            return;
          }
          defaultError = 501;
          return response.json();
        }).then((data) => {
          if (typeof data !== "object" || data === null) {
            setTimeout(() => {
              if (data === 404) {
                callback("abort", data);
              } else {
                callback("next", defaultError);
              }
            });
            return;
          }
          setTimeout(() => {
            callback("success", data);
          });
        }).catch(() => {
          callback("next", defaultError);
        });
      };
      const fetchAPIModule = {
        prepare,
        send
      };
      function setCustomIconsLoader$1(loader, prefix2, provider) {
        getStorage(provider || "", prefix2).loadIcons = loader;
      }
      function setCustomIconLoader$1(loader, prefix2, provider) {
        getStorage(provider || "", prefix2).loadIcon = loader;
      }
      const nodeAttr = "data-style";
      let customStyle = "";
      function appendCustomStyle(style) {
        customStyle = style;
      }
      function updateStyle(parent, inline) {
        let styleNode = Array.from(parent.childNodes).find((node) => node.hasAttribute && node.hasAttribute(nodeAttr));
        if (!styleNode) {
          styleNode = document.createElement("style");
          styleNode.setAttribute(nodeAttr, nodeAttr);
          parent.appendChild(styleNode);
        }
        styleNode.textContent = ":host{display:inline-block;vertical-align:" + (inline ? "-0.125em" : "0") + "}span,svg{display:block;margin:auto}" + customStyle;
      }
      function exportFunctions() {
        setAPIModule("", fetchAPIModule);
        allowSimpleNames(true);
        let _window;
        try {
          _window = window;
        } catch (err) {
        }
        if (_window) {
          if (_window.IconifyPreload !== void 0) {
            const preload2 = _window.IconifyPreload;
            const err = "Invalid IconifyPreload syntax.";
            if (typeof preload2 === "object" && preload2 !== null) {
              (preload2 instanceof Array ? preload2 : [preload2]).forEach((item) => {
                try {
                  if (
                    // Check if item is an object and not null/array
                    typeof item !== "object" || item === null || item instanceof Array || // Check for 'icons' and 'prefix'
                    typeof item.icons !== "object" || typeof item.prefix !== "string" || // Add icon set
                    !addCollection$1(item)
                  ) {
                    console.error(err);
                  }
                } catch (e) {
                  console.error(err);
                }
              });
            }
          }
          if (_window.IconifyProviders !== void 0) {
            const providers = _window.IconifyProviders;
            if (typeof providers === "object" && providers !== null) {
              for (const key in providers) {
                const err = "IconifyProviders[" + key + "] is invalid.";
                try {
                  const value = providers[key];
                  if (typeof value !== "object" || !value || value.resources === void 0) {
                    continue;
                  }
                  if (!addAPIProvider$1(key, value)) {
                    console.error(err);
                  }
                } catch (e) {
                  console.error(err);
                }
              }
            }
          }
        }
        const _api2 = {
          getAPIConfig,
          setAPIModule,
          sendAPIQuery,
          setFetch,
          getFetch,
          listAPIProviders
        };
        return {
          iconLoaded: iconLoaded$1,
          getIcon: getIcon$1,
          listIcons: listIcons$1,
          addIcon: addIcon$1,
          addCollection: addCollection$1,
          calculateSize: calculateSize$1,
          buildIcon: iconToSVG,
          iconToHTML: iconToHTML$1,
          svgToURL: svgToURL$1,
          loadIcons: loadIcons$1,
          loadIcon: loadIcon$1,
          addAPIProvider: addAPIProvider$1,
          setCustomIconLoader: setCustomIconLoader$1,
          setCustomIconsLoader: setCustomIconsLoader$1,
          appendCustomStyle,
          _api: _api2
        };
      }
      const monotoneProps = {
        "background-color": "currentColor"
      };
      const coloredProps = {
        "background-color": "transparent"
      };
      const propsToAdd = {
        image: "var(--svg)",
        repeat: "no-repeat",
        size: "100% 100%"
      };
      const propsToAddTo = {
        "-webkit-mask": monotoneProps,
        "mask": monotoneProps,
        "background": coloredProps
      };
      for (const prefix2 in propsToAddTo) {
        const list = propsToAddTo[prefix2];
        for (const prop in propsToAdd) {
          list[prefix2 + "-" + prop] = propsToAdd[prop];
        }
      }
      function fixSize(value) {
        return value ? value + (value.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
      }
      function renderSPAN(data, icon, useMask) {
        const node = document.createElement("span");
        let body = data.body;
        if (body.indexOf("<a") !== -1) {
          body += "<!-- " + Date.now() + " -->";
        }
        const renderAttribs = data.attributes;
        const html = iconToHTML$1(body, {
          ...renderAttribs,
          width: icon.width + "",
          height: icon.height + ""
        });
        const url = svgToURL$1(html);
        const svgStyle = node.style;
        const styles = {
          "--svg": url,
          "width": fixSize(renderAttribs.width),
          "height": fixSize(renderAttribs.height),
          ...useMask ? monotoneProps : coloredProps
        };
        for (const prop in styles) {
          svgStyle.setProperty(prop, styles[prop]);
        }
        return node;
      }
      let policy;
      function createPolicy() {
        try {
          policy = window.trustedTypes.createPolicy("iconify", {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            createHTML: (s) => s
          });
        } catch (err) {
          policy = null;
        }
      }
      function cleanUpInnerHTML(html) {
        if (policy === void 0) {
          createPolicy();
        }
        return policy ? policy.createHTML(html) : html;
      }
      function renderSVG(data) {
        const node = document.createElement("span");
        const attr = data.attributes;
        let style = "";
        if (!attr.width) {
          style = "width: inherit;";
        }
        if (!attr.height) {
          style += "height: inherit;";
        }
        if (style) {
          attr.style = style;
        }
        const html = iconToHTML$1(data.body, attr);
        node.innerHTML = cleanUpInnerHTML(html);
        return node.firstChild;
      }
      function findIconElement(parent) {
        return Array.from(parent.childNodes).find((node) => {
          const tag = node.tagName && node.tagName.toUpperCase();
          return tag === "SPAN" || tag === "SVG";
        });
      }
      function renderIcon(parent, state) {
        const iconData = state.icon.data;
        const customisations = state.customisations;
        const renderData = iconToSVG(iconData, customisations);
        if (customisations.preserveAspectRatio) {
          renderData.attributes["preserveAspectRatio"] = customisations.preserveAspectRatio;
        }
        const mode = state.renderedMode;
        let node;
        switch (mode) {
          case "svg":
            node = renderSVG(renderData);
            break;
          default:
            node = renderSPAN(renderData, {
              ...defaultIconProps,
              ...iconData
            }, mode === "mask");
        }
        const oldNode = findIconElement(parent);
        if (oldNode) {
          if (node.tagName === "SPAN" && oldNode.tagName === node.tagName) {
            oldNode.setAttribute("style", node.getAttribute("style"));
          } else {
            parent.replaceChild(node, oldNode);
          }
        } else {
          parent.appendChild(node);
        }
      }
      function setPendingState(icon, inline, lastState) {
        const lastRender = lastState && (lastState.rendered ? lastState : lastState.lastRender);
        return {
          rendered: false,
          inline,
          icon,
          lastRender
        };
      }
      function defineIconifyIcon(name = "iconify-icon") {
        let customElements;
        let ParentClass;
        try {
          customElements = window.customElements;
          ParentClass = window.HTMLElement;
        } catch (err) {
          return;
        }
        if (!customElements || !ParentClass) {
          return;
        }
        const ConflictingClass = customElements.get(name);
        if (ConflictingClass) {
          return ConflictingClass;
        }
        const attributes = [
          // Icon
          "icon",
          // Mode
          "mode",
          "inline",
          "noobserver",
          // Customisations
          "width",
          "height",
          "rotate",
          "flip"
        ];
        const IconifyIcon = class extends ParentClass {
          /**
           * Constructor
           */
          constructor() {
            super();
            // Root
            __publicField(this, "_shadowRoot");
            // Initialised
            __publicField(this, "_initialised", false);
            // Icon state
            __publicField(this, "_state");
            // Attributes check queued
            __publicField(this, "_checkQueued", false);
            // Connected
            __publicField(this, "_connected", false);
            // Observer
            __publicField(this, "_observer", null);
            __publicField(this, "_visible", true);
            const root = this._shadowRoot = this.attachShadow({
              mode: "open"
            });
            const inline = this.hasAttribute("inline");
            updateStyle(root, inline);
            this._state = setPendingState({
              value: ""
            }, inline);
            this._queueCheck();
          }
          /**
           * Connected to DOM
           */
          connectedCallback() {
            this._connected = true;
            this.startObserver();
          }
          /**
           * Disconnected from DOM
           */
          disconnectedCallback() {
            this._connected = false;
            this.stopObserver();
          }
          /**
           * Observed attributes
           */
          static get observedAttributes() {
            return attributes.slice(0);
          }
          /**
           * Observed properties that are different from attributes
           *
           * Experimental! Need to test with various frameworks that support it
           */
          /*
          static get properties() {
              return {
                  inline: {
                      type: Boolean,
                      reflect: true,
                  },
                  // Not listing other attributes because they are strings or combination
                  // of string and another type. Cannot have multiple types
              };
          }
          */
          /**
           * Attribute has changed
           */
          attributeChangedCallback(name2) {
            switch (name2) {
              case "inline": {
                const newInline = this.hasAttribute("inline");
                const state = this._state;
                if (newInline !== state.inline) {
                  state.inline = newInline;
                  updateStyle(this._shadowRoot, newInline);
                }
                break;
              }
              case "noobserver": {
                const value = this.hasAttribute("noobserver");
                if (value) {
                  this.startObserver();
                } else {
                  this.stopObserver();
                }
                break;
              }
              default:
                this._queueCheck();
            }
          }
          /**
           * Get/set icon
           */
          get icon() {
            const value = this.getAttribute("icon");
            if (value && value.slice(0, 1) === "{") {
              try {
                return JSON.parse(value);
              } catch (err) {
              }
            }
            return value;
          }
          set icon(value) {
            if (typeof value === "object") {
              value = JSON.stringify(value);
            }
            this.setAttribute("icon", value);
          }
          /**
           * Get/set inline
           */
          get inline() {
            return this.hasAttribute("inline");
          }
          set inline(value) {
            if (value) {
              this.setAttribute("inline", "true");
            } else {
              this.removeAttribute("inline");
            }
          }
          /**
           * Get/set observer
           */
          get observer() {
            return this.hasAttribute("observer");
          }
          set observer(value) {
            if (value) {
              this.setAttribute("observer", "true");
            } else {
              this.removeAttribute("observer");
            }
          }
          /**
           * Restart animation
           */
          restartAnimation() {
            const state = this._state;
            if (state.rendered) {
              const root = this._shadowRoot;
              if (state.renderedMode === "svg") {
                try {
                  root.lastChild.setCurrentTime(0);
                  return;
                } catch (err) {
                }
              }
              renderIcon(root, state);
            }
          }
          /**
           * Get status
           */
          get status() {
            const state = this._state;
            return state.rendered ? "rendered" : state.icon.data === null ? "failed" : "loading";
          }
          /**
           * Queue attributes re-check
           */
          _queueCheck() {
            if (!this._checkQueued) {
              this._checkQueued = true;
              setTimeout(() => {
                this._check();
              });
            }
          }
          /**
           * Check for changes
           */
          _check() {
            if (!this._checkQueued) {
              return;
            }
            this._checkQueued = false;
            const state = this._state;
            const newIcon = this.getAttribute("icon");
            if (newIcon !== state.icon.value) {
              this._iconChanged(newIcon);
              return;
            }
            if (!state.rendered || !this._visible) {
              return;
            }
            const mode = this.getAttribute("mode");
            const customisations = getCustomisations(this);
            if (state.attrMode !== mode || haveCustomisationsChanged(state.customisations, customisations) || !findIconElement(this._shadowRoot)) {
              this._renderIcon(state.icon, customisations, mode);
            }
          }
          /**
           * Icon value has changed
           */
          _iconChanged(newValue) {
            const icon = parseIconValue(newValue, (value, name2, data) => {
              const state = this._state;
              if (state.rendered || this.getAttribute("icon") !== value) {
                return;
              }
              const icon2 = {
                value,
                name: name2,
                data
              };
              if (icon2.data) {
                this._gotIconData(icon2);
              } else {
                state.icon = icon2;
              }
            });
            if (icon.data) {
              this._gotIconData(icon);
            } else {
              this._state = setPendingState(icon, this._state.inline, this._state);
            }
          }
          /**
           * Force render icon on state change
           */
          _forceRender() {
            if (!this._visible) {
              const node = findIconElement(this._shadowRoot);
              if (node) {
                this._shadowRoot.removeChild(node);
              }
              return;
            }
            this._queueCheck();
          }
          /**
           * Got new icon data, icon is ready to (re)render
           */
          _gotIconData(icon) {
            this._checkQueued = false;
            this._renderIcon(icon, getCustomisations(this), this.getAttribute("mode"));
          }
          /**
           * Re-render based on icon data
           */
          _renderIcon(icon, customisations, attrMode) {
            const renderedMode = getRenderMode(icon.data.body, attrMode);
            const inline = this._state.inline;
            renderIcon(this._shadowRoot, this._state = {
              rendered: true,
              icon,
              inline,
              customisations,
              attrMode,
              renderedMode
            });
          }
          /**
           * Start observer
           */
          startObserver() {
            if (!this._observer && !this.hasAttribute("noobserver")) {
              try {
                this._observer = new IntersectionObserver((entries) => {
                  const intersecting = entries.some((entry) => entry.isIntersecting);
                  if (intersecting !== this._visible) {
                    this._visible = intersecting;
                    this._forceRender();
                  }
                });
                this._observer.observe(this);
              } catch (err) {
                if (this._observer) {
                  try {
                    this._observer.disconnect();
                  } catch (err2) {
                  }
                  this._observer = null;
                }
              }
            }
          }
          /**
           * Stop observer
           */
          stopObserver() {
            if (this._observer) {
              this._observer.disconnect();
              this._observer = null;
              this._visible = true;
              if (this._connected) {
                this._forceRender();
              }
            }
          }
        };
        attributes.forEach((attr) => {
          if (!(attr in IconifyIcon.prototype)) {
            Object.defineProperty(IconifyIcon.prototype, attr, {
              get: function() {
                return this.getAttribute(attr);
              },
              set: function(value) {
                if (value !== null) {
                  this.setAttribute(attr, value);
                } else {
                  this.removeAttribute(attr);
                }
              }
            });
          }
        });
        const functions = exportFunctions();
        for (const key in functions) {
          IconifyIcon[key] = IconifyIcon.prototype[key] = functions[key];
        }
        customElements.define(name, IconifyIcon);
        return IconifyIcon;
      }
      const IconifyIconComponent = defineIconifyIcon() || exportFunctions();
      const { iconLoaded, getIcon, listIcons, addIcon, addCollection, calculateSize, buildIcon, iconToHTML, svgToURL, loadIcons, loadIcon, setCustomIconLoader, setCustomIconsLoader, addAPIProvider, _api } = IconifyIconComponent;
      class TopFilePathMod extends BaseMod {
        constructor() {
          super();
          Object.defineProperty(this, "mutationObserver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
          });
          Object.defineProperty(this, "backButton", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
          });
          this.init();
        }
        /**
         * 文件路径 Box
         */
        get filePathBoxNode() {
          return document.querySelector("#js_top_header_file_path_box");
        }
        /**
         * 当前路径容器
         */
        get topFilePathContainerNode() {
          return document.querySelector(".list-topheader .top-file-path");
        }
        /**
         * 路径Tooltip
         */
        get commonLittlePopNode() {
          var _a;
          return (_a = this.filePathBoxNode) == null ? void 0 : _a.querySelector(".common-little-pop");
        }
        /**
         * 当前目录路径节点
         */
        get filePathNode() {
          var _a;
          return (_a = this.topFilePathContainerNode) == null ? void 0 : _a.querySelector(".file-path");
        }
        /**
         * 当前目录路径链接
         */
        get readPathLinkNodes() {
          var _a;
          return (_a = this.filePathNode) == null ? void 0 : _a.querySelectorAll("a");
        }
        /**
         * 是否存在搜索返回按钮
         * @description 在星标页面进入二级目录后会出现这个按钮
         */
        get hasSearchBackButton() {
          var _a;
          return (_a = this.topFilePathContainerNode) == null ? void 0 : _a.querySelector('[menu="back_search"]');
        }
        /**
         * 销毁
         */
        destroy() {
          var _a, _b;
          (_a = this.mutationObserver) == null ? void 0 : _a.disconnect();
          (_b = this.backButton) == null ? void 0 : _b.remove();
        }
        /**
         * 当前路径
         * @returns 路径列表
         */
        readPaths() {
          const pathDom = this.readPathLinkNodes;
          if (!pathDom)
            return [];
          const isMultiLevel = pathDom.length > 1;
          return Array.from(pathDom).map((item) => {
            const title = item.getAttribute("titletext") ?? "";
            const cid = item.getAttribute("cid") ?? "";
            const isRoot = cid === "0";
            if (isMultiLevel && isRoot) {
              return "";
            }
            return title;
          }).filter((item) => item !== "");
        }
        /**
         * 设置页面标题为当前路径
         */
        setTopDocumentTitleWithPaths() {
          const paths = this.readPaths();
          const title = (paths == null ? void 0 : paths.reverse().join(" < ")) ?? "";
          if ((top == null ? void 0 : top.document) && title !== "") {
            top.document.title = title;
          }
        }
        /**
         * 添加返回上级目录按钮
         */
        addBackButton() {
          var _a, _b;
          if (!this.topFilePathContainerNode)
            return;
          this.backButton = document.createElement("a");
          this.backButton.classList.add("master-back-button");
          this.backButton.href = "javascript:void(0)";
          this.backButton.innerHTML = '<iconify-icon icon="material-symbols:line-start-arrow-notch" noobserver></iconify-icon>返回目录';
          (_a = this.topFilePathContainerNode) == null ? void 0 : _a.before(this.backButton);
          if (this.commonLittlePopNode) {
            this.commonLittlePopNode.style.marginLeft = `${(_b = this.filePathNode) == null ? void 0 : _b.getBoundingClientRect().left}px`;
          }
          this.backButton.addEventListener("click", () => {
            var _a2;
            const prevPathLink = (_a2 = this.readPathLinkNodes) == null ? void 0 : _a2[this.readPathLinkNodes.length - 2];
            if (prevPathLink) {
              prevPathLink.click();
            }
          });
        }
        /**
         * 删除返回按钮
         */
        removeBackButton() {
          var _a;
          (_a = this.backButton) == null ? void 0 : _a.remove();
          this.backButton = null;
          if (this.commonLittlePopNode) {
            this.commonLittlePopNode.style.marginLeft = "0";
          }
        }
        /**
         * 控制返回按钮显示/隐藏
         */
        controlBackButtonShow() {
          var _a;
          const onlyOnePath = (((_a = this.readPathLinkNodes) == null ? void 0 : _a.length) ?? 0) <= 1;
          if (onlyOnePath || this.hasSearchBackButton) {
            this.removeBackButton();
          } else if (!this.backButton) {
            this.addBackButton();
          }
        }
        /**
         * 监听路径变化
         * @param callback 回调函数
         */
        watchPathsChange(callback) {
          if (!this.topFilePathContainerNode)
            return;
          this.mutationObserver = new MutationObserver(callback);
          this.mutationObserver.observe(this.topFilePathContainerNode, {
            childList: true,
            subtree: true
          });
        }
        /**
         * 初始化
         */
        init() {
          defer(() => {
            this.setTopDocumentTitleWithPaths();
            this.controlBackButtonShow();
            this.watchPathsChange(() => {
              this.setTopDocumentTitleWithPaths();
              this.controlBackButtonShow();
            });
          });
        }
      }
      class HomePage {
        /**
         * 构造函数
         */
        constructor() {
          Object.defineProperty(this, "modManager", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.init();
        }
        /**
         * 销毁
         */
        destroy() {
          var _a;
          (_a = this.modManager) == null ? void 0 : _a.destroy();
        }
        /**
         * 初始化
         */
        async init() {
          this.modManager = new ModManager([
            new FileListMod(),
            new TopFilePathMod()
          ]);
        }
      }
      function resetDocument() {
        document.body.style.backgroundColor = "#000";
        document.body.style.margin = "0";
        document.body.innerHTML = `<div id="my-app" data-theme="dark"></div>`;
        document.title = "";
        _GM_addStyle(`
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
      /* display: none !important; */
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* 隐藏滚动条 */
    :fullscreen html::-webkit-scrollbar,
    :fullscreen body::-webkit-scrollbar {
      width: 0 !important;
      height: 0 !important;
      display: none !important
    }
  `);
      }
      function setVideoCookie(cookieDetail) {
        return new Promise((resolve, reject) => {
          const iframe = document.createElement("iframe");
          iframe.src = `${DL_URL_115}/video/token`;
          iframe.style.display = "none";
          window.addEventListener("message", (event) => {
            var _a;
            if (event.origin === DL_URL_115 && event.data.event === "ready") {
              (_a = iframe.contentWindow) == null ? void 0 : _a.postMessage({
                event: "set-cookies",
                data: cookieDetail
              }, DL_URL_115);
            }
            if (event.origin === DL_URL_115 && event.data.event === "set-cookies-callback") {
              if (event.data.data) {
                reject(event.data.data);
              } else {
                resolve("success");
              }
              iframe.remove();
            }
          });
          document.body.appendChild(iframe);
        });
      }
      function videoTokenPage() {
        window.parent.postMessage({
          event: "ready"
        }, NORMAL_URL_115);
        window.addEventListener("message", (event) => {
          if (event.origin === NORMAL_URL_115 && event.data.event === "set-cookies") {
            _GM_cookie.set(event.data.data, (error) => {
              window.parent.postMessage({
                event: "set-cookies-callback",
                data: error
              }, NORMAL_URL_115);
            });
          }
        });
      }
      async function videoPage() {
        resetDocument();
        const style = document.createElement("style");
        style.textContent = mainStyles;
        style.dataset.v = "style_css";
        document.head.append(style);
        createApp(defineAsyncComponent({
          loader: () => __vitePreload(() => module.import('./index-DyGkyIRh-BVJmzfFR.js'), void 0 )
        })).mount("#my-app");
      }
      class DebugInfo {
        constructor() {
          Object.defineProperty(this, "Logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.Logger = new Logger$1("115Master", "DebugInfo");
        }
        bootstrapInfo() {
          this.Logger.log("bootstrap-info", `${_GM_info.script.name} 已启动`);
        }
      }
      const debugInfo = new DebugInfo();
      debugInfo.bootstrapInfo();
      const routeMatch = [
        /** 首页 */
        {
          match: ROUTE_MATCH.HOME,
          exec: () => new HomePage()
        },
        /** 视频页 */
        {
          match: ROUTE_MATCH.VIDEO,
          exec: () => videoPage()
        },
        /** 视频页（token中转） */
        {
          match: ROUTE_MATCH.VIDEO_TOKEN,
          exec: () => videoTokenPage()
        }
      ];
      function main() {
        for (const route of routeMatch) {
          if (globToRegex(route.match).test(window.location.href)) {
            route.exec();
          }
        }
      }
      if (document.readyState === "complete" || document.readyState === "interactive") {
        main();
      } else {
        window.addEventListener("DOMContentLoaded", main);
      }

    })
  };
}));

System.register("./index-DyGkyIRh-BVJmzfFR.js", ['vue', './__monkey.entry-BzBceu9h.js', 'lodash', 'hls.js', 'localforage', 'dayjs', 'blueimp-md5', 'big-integer', 'photoswipe/lightbox', 'm3u8-parser'], (function (exports, module) {
  'use strict';
  var defineComponent, ref, shallowRef, computed, onMounted, createElementBlock, openBlock, normalizeClass, createElementVNode, createCommentVNode, unref, createVNode, normalizeStyle, withCtx, reactive, onUnmounted, watch, watchEffect, createBlock, renderSlot, toDisplayString, Fragment, renderList, useTemplateRef, createTextVNode, nextTick, provide, Transition, withModifiers, toValue, inject, withDirectives, vShow, Teleport, mergeProps, Icon, ICON_PLAYLIST, ICON_SKIP_PREVIOUS, ICON_SKIP_NEXT, PLUS_VERSION, useStorage, Scheduler, tryOnUnmounted, useAsyncState, useThrottleFn, useDebounceFn, useTitle, _sfc_main$1$1, ICON_STAR_FILL, ICON_STAR, ICON_CLOSE, goToPlayer, drive115, setVideoCookie, qualityNumMap, blurTime, SchedulerError, FRIENDLY_ERROR_MESSAGE, M3U8ClipperNew, useVModels, useSmartVideoCover, getImageResize, useEventListener, useElementSize, useCssVar$1, useMouseInElement, qualityPreferenceCache, transformPreferenceCache, useVModel, useElementBounding, onClickOutside, getDefaultExportFromCjs, syncRef, toReactive, useIntervalFn, CDN_BASE_URL, _unsafeWindow, shuffle, get, Hls, dayjs;
  return {
    setters: [module => {
      defineComponent = module.defineComponent;
      ref = module.ref;
      shallowRef = module.shallowRef;
      computed = module.computed;
      onMounted = module.onMounted;
      createElementBlock = module.createElementBlock;
      openBlock = module.openBlock;
      normalizeClass = module.normalizeClass;
      createElementVNode = module.createElementVNode;
      createCommentVNode = module.createCommentVNode;
      unref = module.unref;
      createVNode = module.createVNode;
      normalizeStyle = module.normalizeStyle;
      withCtx = module.withCtx;
      reactive = module.reactive;
      onUnmounted = module.onUnmounted;
      watch = module.watch;
      watchEffect = module.watchEffect;
      createBlock = module.createBlock;
      renderSlot = module.renderSlot;
      toDisplayString = module.toDisplayString;
      Fragment = module.Fragment;
      renderList = module.renderList;
      useTemplateRef = module.useTemplateRef;
      createTextVNode = module.createTextVNode;
      nextTick = module.nextTick;
      provide = module.provide;
      Transition = module.Transition;
      withModifiers = module.withModifiers;
      toValue = module.toValue;
      inject = module.inject;
      withDirectives = module.withDirectives;
      vShow = module.vShow;
      Teleport = module.Teleport;
      mergeProps = module.mergeProps;
    }, module => {
      Icon = module.I;
      ICON_PLAYLIST = module.a;
      ICON_SKIP_PREVIOUS = module.b;
      ICON_SKIP_NEXT = module.c;
      PLUS_VERSION = module.P;
      useStorage = module.u;
      Scheduler = module.S;
      tryOnUnmounted = module.t;
      useAsyncState = module.d;
      useThrottleFn = module.e;
      useDebounceFn = module.f;
      useTitle = module.g;
      _sfc_main$1$1 = module._;
      ICON_STAR_FILL = module.h;
      ICON_STAR = module.i;
      ICON_CLOSE = module.j;
      goToPlayer = module.k;
      drive115 = module.l;
      setVideoCookie = module.s;
      qualityNumMap = module.q;
      blurTime = module.m;
      SchedulerError = module.n;
      FRIENDLY_ERROR_MESSAGE = module.F;
      M3U8ClipperNew = module.M;
      useVModels = module.o;
      useSmartVideoCover = module.p;
      getImageResize = module.r;
      useEventListener = module.v;
      useElementSize = module.w;
      useCssVar$1 = module.x;
      useMouseInElement = module.y;
      qualityPreferenceCache = module.z;
      transformPreferenceCache = module.A;
      useVModel = module.B;
      useElementBounding = module.C;
      onClickOutside = module.D;
      getDefaultExportFromCjs = module.E;
      syncRef = module.G;
      toReactive = module.H;
      useIntervalFn = module.J;
      CDN_BASE_URL = module.K;
      _unsafeWindow = module.L;
    }, module => {
      shuffle = module.shuffle;
      get = module.get;
    }, module => {
      Hls = module.default;
    }, null, module => {
      dayjs = module.default;
    }, null, null, null, null],
    execute: (function () {

      const controlStyles = {
        btn: {
          root: [
            "btn btn-link btn-circle tooltip",
            "text-base-content disabled:text-base-content/30",
            "hover:text-base-content/80"
          ],
          icon: ["size-8", "drop-shadow-xs/60"]
        },
        btnText: {
          root: [
            "btn btn-link text-base rounded-full tooltip px-1.5 font-semibold",
            "text-base-content disabled:text-base-content/30",
            "hover:text-base-content/80",
            "no-underline hover:no-underline!",
            "text-shadow-[0_0_2px_rgba(0_0_0_/0.3),0_0_2px_rgba(0_0_0_/0.3),0_0_2px_rgba(0_0_0_/0.3)]"
          ]
        },
        menu: {
          root: "menu p-0 min-w-32 gap-1",
          a: "rounded-lg",
          active: "menu-active",
          icon: "size-6",
          label: "text-base-content",
          desc: "text-base-content/60"
        },
        text: "text-sm text-base-content text-shadow-xs/60 text-shadow-[0_0_2px_rgba(0_0_0_/0.3),0_0_2px_rgba(0_0_0_/0.3),0_0_2px_rgba(0_0_0_/0.3)]",
        subtext: "text-base-content/60"
      };
      const controlRightStyles = {
        btn: {
          root: [controlStyles.btn.root, "tooltip-left"],
          icon: controlStyles.btn.icon
        },
        btnText: {
          root: controlStyles.btnText.root
        }
      };
      const _hoisted_1$d = ["disabled"];
      const _sfc_main$s = /* @__PURE__ */ defineComponent({
        __name: "StarButton",
        props: {
          isMark: { type: [Boolean, null] },
          onToggleMark: { type: Function }
        },
        emits: ["toggleMark"],
        setup(__props, { emit: __emit }) {
          const props = __props;
          const emit = __emit;
          const styles = {
            ...controlRightStyles
          };
          const isMarkReady = computed(() => props.isMark !== null);
          function handleToggleMark() {
            if (props.onToggleMark) {
              props.onToggleMark();
            }
            emit("toggleMark");
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("button", {
              class: normalizeClass([styles.btn.root]),
              disabled: !isMarkReady.value,
              "data-tip": "收藏",
              onClick: handleToggleMark
            }, [
              createVNode(unref(Icon), {
                class: normalizeClass([styles.btn.icon]),
                icon: _ctx.isMark ? unref(ICON_STAR_FILL) : unref(ICON_STAR)
              }, null, 8, ["class", "icon"])
            ], 10, _hoisted_1$d);
          };
        }
      });
      var PlayMode;
      (function(PlayMode2) {
        PlayMode2["STOP"] = "stop";
        PlayMode2["REPEAT_ONE"] = "repeat_one";
        PlayMode2["AUTO_NEXT"] = "auto_next";
      })(PlayMode || (PlayMode = {}));
      const PLAY_MODE_NAMES = {
        [PlayMode.STOP]: "播放完停止",
        [PlayMode.REPEAT_ONE]: "单集循环",
        [PlayMode.AUTO_NEXT]: "自动下一集"
      };
      const PLAY_MODE_ICONS = {
        [PlayMode.STOP]: "material-symbols:pause-rounded",
        [PlayMode.REPEAT_ONE]: "material-symbols:restart-alt-rounded",
        [PlayMode.AUTO_NEXT]: "material-symbols:fast-forward-rounded"
      };
      const PLAY_MODE_DESCRIPTIONS = {
        [PlayMode.STOP]: "播放完成后暂停",
        [PlayMode.REPEAT_ONE]: "播放完成后重新播放当前视频",
        [PlayMode.AUTO_NEXT]: "播放完成后自动播放下一集"
      };
      function usePlayEndHandler(ctx) {
        const getNextVideo = () => {
          const getCurrentPlaylist = ctx.rootProps.getCurrentPlaylist;
          const getCurrentPickCode = ctx.rootProps.getCurrentPickCode;
          if (!getCurrentPlaylist || !getCurrentPickCode) {
            console.warn("播放列表或当前播放码获取函数未提供");
            return null;
          }
          const playlist = getCurrentPlaylist();
          const currentPickCode = getCurrentPickCode();
          if (!(playlist == null ? void 0 : playlist.data) || playlist.data.length === 0) {
            console.log("播放列表为空");
            return null;
          }
          const currentIndex = playlist.data.findIndex((item) => item.pc === currentPickCode);
          if (currentIndex === -1) {
            console.warn("当前视频不在播放列表中");
            return null;
          }
          const nextIndex = currentIndex + 1;
          if (nextIndex >= playlist.data.length) {
            console.log("已经是最后一集");
            return null;
          }
          return playlist.data[nextIndex].pc;
        };
        const handlePlayEnd = async (playMode) => {
          const playerCore = ctx.playerCore.value;
          if (!playerCore) {
            console.error("播放器核心不存在");
            return;
          }
          console.log(`🎬 视频播放结束，当前播放模式: ${playMode}`);
          switch (playMode) {
            case PlayMode.STOP:
              console.log("⏹️ 播放模式：停止");
              break;
            case PlayMode.REPEAT_ONE:
              console.log("🔁 播放模式：单集循环，重新播放当前视频");
              try {
                await playerCore.seek(0);
                await playerCore.play();
              } catch (error) {
                console.error("重播失败:", error);
              }
              break;
            case PlayMode.AUTO_NEXT: {
              console.log("⏭️ 播放模式：自动下一集");
              const nextPickCode = getNextVideo();
              if (nextPickCode) {
                console.log(`🎯 找到下一集: ${nextPickCode}`);
                const onChangeVideo = ctx.rootProps.onChangeVideo;
                if (onChangeVideo) {
                  try {
                    await onChangeVideo(nextPickCode);
                    console.log("✅ 成功切换到下一集");
                  } catch (error) {
                    console.error("切换到下一集失败:", error);
                  }
                } else {
                  console.error("视频切换回调函数未提供");
                }
              } else {
                console.log("📝 没有下一集，播放结束");
              }
              break;
            }
            default:
              console.warn(`未知播放模式: ${playMode}`);
          }
        };
        return {
          handlePlayEnd,
          getNextVideo
        };
      }
      var PlayerCoreType;
      (function(PlayerCoreType2) {
        PlayerCoreType2["Native"] = "Native";
        PlayerCoreType2["AvPlayer"] = "AvPlayer";
        PlayerCoreType2["Hls"] = "HLS.js";
      })(PlayerCoreType || (PlayerCoreType = {}));
      var AVCodecID;
      !(function(AVCodecID2) {
        AVCodecID2[AVCodecID2.AV_CODEC_ID_NONE = 0] = "AV_CODEC_ID_NONE", AVCodecID2[AVCodecID2.AV_CODEC_ID_MPEG1VIDEO = 1] = "AV_CODEC_ID_MPEG1VIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_MPEG2VIDEO = 2] = "AV_CODEC_ID_MPEG2VIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_H261 = 3] = "AV_CODEC_ID_H261", AVCodecID2[AVCodecID2.AV_CODEC_ID_H263 = 4] = "AV_CODEC_ID_H263", AVCodecID2[AVCodecID2.AV_CODEC_ID_RV10 = 5] = "AV_CODEC_ID_RV10", AVCodecID2[AVCodecID2.AV_CODEC_ID_RV20 = 6] = "AV_CODEC_ID_RV20", AVCodecID2[AVCodecID2.AV_CODEC_ID_MJPEG = 7] = "AV_CODEC_ID_MJPEG", AVCodecID2[AVCodecID2.AV_CODEC_ID_MJPEGB = 8] = "AV_CODEC_ID_MJPEGB", AVCodecID2[AVCodecID2.AV_CODEC_ID_LJPEG = 9] = "AV_CODEC_ID_LJPEG", AVCodecID2[AVCodecID2.AV_CODEC_ID_SP5X = 10] = "AV_CODEC_ID_SP5X", AVCodecID2[AVCodecID2.AV_CODEC_ID_JPEGLS = 11] = "AV_CODEC_ID_JPEGLS", AVCodecID2[AVCodecID2.AV_CODEC_ID_MPEG4 = 12] = "AV_CODEC_ID_MPEG4", AVCodecID2[AVCodecID2.AV_CODEC_ID_RAWVIDEO = 13] = "AV_CODEC_ID_RAWVIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSMPEG4V1 = 14] = "AV_CODEC_ID_MSMPEG4V1", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSMPEG4V2 = 15] = "AV_CODEC_ID_MSMPEG4V2", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSMPEG4V3 = 16] = "AV_CODEC_ID_MSMPEG4V3", AVCodecID2[AVCodecID2.AV_CODEC_ID_WMV1 = 17] = "AV_CODEC_ID_WMV1", AVCodecID2[AVCodecID2.AV_CODEC_ID_WMV2 = 18] = "AV_CODEC_ID_WMV2", AVCodecID2[AVCodecID2.AV_CODEC_ID_H263P = 19] = "AV_CODEC_ID_H263P", AVCodecID2[AVCodecID2.AV_CODEC_ID_H263I = 20] = "AV_CODEC_ID_H263I", AVCodecID2[AVCodecID2.AV_CODEC_ID_FLV1 = 21] = "AV_CODEC_ID_FLV1", AVCodecID2[AVCodecID2.AV_CODEC_ID_SVQ1 = 22] = "AV_CODEC_ID_SVQ1", AVCodecID2[AVCodecID2.AV_CODEC_ID_SVQ3 = 23] = "AV_CODEC_ID_SVQ3", AVCodecID2[AVCodecID2.AV_CODEC_ID_DVVIDEO = 24] = "AV_CODEC_ID_DVVIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_HUFFYUV = 25] = "AV_CODEC_ID_HUFFYUV", AVCodecID2[AVCodecID2.AV_CODEC_ID_CYUV = 26] = "AV_CODEC_ID_CYUV", AVCodecID2[AVCodecID2.AV_CODEC_ID_H264 = 27] = "AV_CODEC_ID_H264", AVCodecID2[AVCodecID2.AV_CODEC_ID_INDEO3 = 28] = "AV_CODEC_ID_INDEO3", AVCodecID2[AVCodecID2.AV_CODEC_ID_VP3 = 29] = "AV_CODEC_ID_VP3", AVCodecID2[AVCodecID2.AV_CODEC_ID_THEORA = 30] = "AV_CODEC_ID_THEORA", AVCodecID2[AVCodecID2.AV_CODEC_ID_ASV1 = 31] = "AV_CODEC_ID_ASV1", AVCodecID2[AVCodecID2.AV_CODEC_ID_ASV2 = 32] = "AV_CODEC_ID_ASV2", AVCodecID2[AVCodecID2.AV_CODEC_ID_FFV1 = 33] = "AV_CODEC_ID_FFV1", AVCodecID2[AVCodecID2.AV_CODEC_ID_4XM = 34] = "AV_CODEC_ID_4XM", AVCodecID2[AVCodecID2.AV_CODEC_ID_VCR1 = 35] = "AV_CODEC_ID_VCR1", AVCodecID2[AVCodecID2.AV_CODEC_ID_CLJR = 36] = "AV_CODEC_ID_CLJR", AVCodecID2[AVCodecID2.AV_CODEC_ID_MDEC = 37] = "AV_CODEC_ID_MDEC", AVCodecID2[AVCodecID2.AV_CODEC_ID_ROQ = 38] = "AV_CODEC_ID_ROQ", AVCodecID2[AVCodecID2.AV_CODEC_ID_INTERPLAY_VIDEO = 39] = "AV_CODEC_ID_INTERPLAY_VIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_XAN_WC3 = 40] = "AV_CODEC_ID_XAN_WC3", AVCodecID2[AVCodecID2.AV_CODEC_ID_XAN_WC4 = 41] = "AV_CODEC_ID_XAN_WC4", AVCodecID2[AVCodecID2.AV_CODEC_ID_RPZA = 42] = "AV_CODEC_ID_RPZA", AVCodecID2[AVCodecID2.AV_CODEC_ID_CINEPAK = 43] = "AV_CODEC_ID_CINEPAK", AVCodecID2[AVCodecID2.AV_CODEC_ID_WS_VQA = 44] = "AV_CODEC_ID_WS_VQA", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSRLE = 45] = "AV_CODEC_ID_MSRLE", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSVIDEO1 = 46] = "AV_CODEC_ID_MSVIDEO1", AVCodecID2[AVCodecID2.AV_CODEC_ID_IDCIN = 47] = "AV_CODEC_ID_IDCIN", AVCodecID2[AVCodecID2.AV_CODEC_ID_8BPS = 48] = "AV_CODEC_ID_8BPS", AVCodecID2[AVCodecID2.AV_CODEC_ID_SMC = 49] = "AV_CODEC_ID_SMC", AVCodecID2[AVCodecID2.AV_CODEC_ID_FLIC = 50] = "AV_CODEC_ID_FLIC", AVCodecID2[AVCodecID2.AV_CODEC_ID_TRUEMOTION1 = 51] = "AV_CODEC_ID_TRUEMOTION1", AVCodecID2[AVCodecID2.AV_CODEC_ID_VMDVIDEO = 52] = "AV_CODEC_ID_VMDVIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSZH = 53] = "AV_CODEC_ID_MSZH", AVCodecID2[AVCodecID2.AV_CODEC_ID_ZLIB = 54] = "AV_CODEC_ID_ZLIB", AVCodecID2[AVCodecID2.AV_CODEC_ID_QTRLE = 55] = "AV_CODEC_ID_QTRLE", AVCodecID2[AVCodecID2.AV_CODEC_ID_TSCC = 56] = "AV_CODEC_ID_TSCC", AVCodecID2[AVCodecID2.AV_CODEC_ID_ULTI = 57] = "AV_CODEC_ID_ULTI", AVCodecID2[AVCodecID2.AV_CODEC_ID_QDRAW = 58] = "AV_CODEC_ID_QDRAW", AVCodecID2[AVCodecID2.AV_CODEC_ID_VIXL = 59] = "AV_CODEC_ID_VIXL", AVCodecID2[AVCodecID2.AV_CODEC_ID_QPEG = 60] = "AV_CODEC_ID_QPEG", AVCodecID2[AVCodecID2.AV_CODEC_ID_PNG = 61] = "AV_CODEC_ID_PNG", AVCodecID2[AVCodecID2.AV_CODEC_ID_PPM = 62] = "AV_CODEC_ID_PPM", AVCodecID2[AVCodecID2.AV_CODEC_ID_PBM = 63] = "AV_CODEC_ID_PBM", AVCodecID2[AVCodecID2.AV_CODEC_ID_PGM = 64] = "AV_CODEC_ID_PGM", AVCodecID2[AVCodecID2.AV_CODEC_ID_PGMYUV = 65] = "AV_CODEC_ID_PGMYUV", AVCodecID2[AVCodecID2.AV_CODEC_ID_PAM = 66] = "AV_CODEC_ID_PAM", AVCodecID2[AVCodecID2.AV_CODEC_ID_FFVHUFF = 67] = "AV_CODEC_ID_FFVHUFF", AVCodecID2[AVCodecID2.AV_CODEC_ID_RV30 = 68] = "AV_CODEC_ID_RV30", AVCodecID2[AVCodecID2.AV_CODEC_ID_RV40 = 69] = "AV_CODEC_ID_RV40", AVCodecID2[AVCodecID2.AV_CODEC_ID_VC1 = 70] = "AV_CODEC_ID_VC1", AVCodecID2[AVCodecID2.AV_CODEC_ID_WMV3 = 71] = "AV_CODEC_ID_WMV3", AVCodecID2[AVCodecID2.AV_CODEC_ID_LOCO = 72] = "AV_CODEC_ID_LOCO", AVCodecID2[AVCodecID2.AV_CODEC_ID_WNV1 = 73] = "AV_CODEC_ID_WNV1", AVCodecID2[AVCodecID2.AV_CODEC_ID_AASC = 74] = "AV_CODEC_ID_AASC", AVCodecID2[AVCodecID2.AV_CODEC_ID_INDEO2 = 75] = "AV_CODEC_ID_INDEO2", AVCodecID2[AVCodecID2.AV_CODEC_ID_FRAPS = 76] = "AV_CODEC_ID_FRAPS", AVCodecID2[AVCodecID2.AV_CODEC_ID_TRUEMOTION2 = 77] = "AV_CODEC_ID_TRUEMOTION2", AVCodecID2[AVCodecID2.AV_CODEC_ID_BMP = 78] = "AV_CODEC_ID_BMP", AVCodecID2[AVCodecID2.AV_CODEC_ID_CSCD = 79] = "AV_CODEC_ID_CSCD", AVCodecID2[AVCodecID2.AV_CODEC_ID_MMVIDEO = 80] = "AV_CODEC_ID_MMVIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_ZMBV = 81] = "AV_CODEC_ID_ZMBV", AVCodecID2[AVCodecID2.AV_CODEC_ID_AVS = 82] = "AV_CODEC_ID_AVS", AVCodecID2[AVCodecID2.AV_CODEC_ID_SMACKVIDEO = 83] = "AV_CODEC_ID_SMACKVIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_NUV = 84] = "AV_CODEC_ID_NUV", AVCodecID2[AVCodecID2.AV_CODEC_ID_KMVC = 85] = "AV_CODEC_ID_KMVC", AVCodecID2[AVCodecID2.AV_CODEC_ID_FLASHSV = 86] = "AV_CODEC_ID_FLASHSV", AVCodecID2[AVCodecID2.AV_CODEC_ID_CAVS = 87] = "AV_CODEC_ID_CAVS", AVCodecID2[AVCodecID2.AV_CODEC_ID_JPEG2000 = 88] = "AV_CODEC_ID_JPEG2000", AVCodecID2[AVCodecID2.AV_CODEC_ID_VMNC = 89] = "AV_CODEC_ID_VMNC", AVCodecID2[AVCodecID2.AV_CODEC_ID_VP5 = 90] = "AV_CODEC_ID_VP5", AVCodecID2[AVCodecID2.AV_CODEC_ID_VP6 = 91] = "AV_CODEC_ID_VP6", AVCodecID2[AVCodecID2.AV_CODEC_ID_VP6F = 92] = "AV_CODEC_ID_VP6F", AVCodecID2[AVCodecID2.AV_CODEC_ID_TARGA = 93] = "AV_CODEC_ID_TARGA", AVCodecID2[AVCodecID2.AV_CODEC_ID_DSICINVIDEO = 94] = "AV_CODEC_ID_DSICINVIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_TIERTEXSEQVIDEO = 95] = "AV_CODEC_ID_TIERTEXSEQVIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_TIFF = 96] = "AV_CODEC_ID_TIFF", AVCodecID2[AVCodecID2.AV_CODEC_ID_GIF = 97] = "AV_CODEC_ID_GIF", AVCodecID2[AVCodecID2.AV_CODEC_ID_DXA = 98] = "AV_CODEC_ID_DXA", AVCodecID2[AVCodecID2.AV_CODEC_ID_DNXHD = 99] = "AV_CODEC_ID_DNXHD", AVCodecID2[AVCodecID2.AV_CODEC_ID_THP = 100] = "AV_CODEC_ID_THP", AVCodecID2[AVCodecID2.AV_CODEC_ID_SGI = 101] = "AV_CODEC_ID_SGI", AVCodecID2[AVCodecID2.AV_CODEC_ID_C93 = 102] = "AV_CODEC_ID_C93", AVCodecID2[AVCodecID2.AV_CODEC_ID_BETHSOFTVID = 103] = "AV_CODEC_ID_BETHSOFTVID", AVCodecID2[AVCodecID2.AV_CODEC_ID_PTX = 104] = "AV_CODEC_ID_PTX", AVCodecID2[AVCodecID2.AV_CODEC_ID_TXD = 105] = "AV_CODEC_ID_TXD", AVCodecID2[AVCodecID2.AV_CODEC_ID_VP6A = 106] = "AV_CODEC_ID_VP6A", AVCodecID2[AVCodecID2.AV_CODEC_ID_AMV = 107] = "AV_CODEC_ID_AMV", AVCodecID2[AVCodecID2.AV_CODEC_ID_VB = 108] = "AV_CODEC_ID_VB", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCX = 109] = "AV_CODEC_ID_PCX", AVCodecID2[AVCodecID2.AV_CODEC_ID_SUNRAST = 110] = "AV_CODEC_ID_SUNRAST", AVCodecID2[AVCodecID2.AV_CODEC_ID_INDEO4 = 111] = "AV_CODEC_ID_INDEO4", AVCodecID2[AVCodecID2.AV_CODEC_ID_INDEO5 = 112] = "AV_CODEC_ID_INDEO5", AVCodecID2[AVCodecID2.AV_CODEC_ID_MIMIC = 113] = "AV_CODEC_ID_MIMIC", AVCodecID2[AVCodecID2.AV_CODEC_ID_RL2 = 114] = "AV_CODEC_ID_RL2", AVCodecID2[AVCodecID2.AV_CODEC_ID_ESCAPE124 = 115] = "AV_CODEC_ID_ESCAPE124", AVCodecID2[AVCodecID2.AV_CODEC_ID_DIRAC = 116] = "AV_CODEC_ID_DIRAC", AVCodecID2[AVCodecID2.AV_CODEC_ID_BFI = 117] = "AV_CODEC_ID_BFI", AVCodecID2[AVCodecID2.AV_CODEC_ID_CMV = 118] = "AV_CODEC_ID_CMV", AVCodecID2[AVCodecID2.AV_CODEC_ID_MOTIONPIXELS = 119] = "AV_CODEC_ID_MOTIONPIXELS", AVCodecID2[AVCodecID2.AV_CODEC_ID_TGV = 120] = "AV_CODEC_ID_TGV", AVCodecID2[AVCodecID2.AV_CODEC_ID_TGQ = 121] = "AV_CODEC_ID_TGQ", AVCodecID2[AVCodecID2.AV_CODEC_ID_TQI = 122] = "AV_CODEC_ID_TQI", AVCodecID2[AVCodecID2.AV_CODEC_ID_AURA = 123] = "AV_CODEC_ID_AURA", AVCodecID2[AVCodecID2.AV_CODEC_ID_AURA2 = 124] = "AV_CODEC_ID_AURA2", AVCodecID2[AVCodecID2.AV_CODEC_ID_V210X = 125] = "AV_CODEC_ID_V210X", AVCodecID2[AVCodecID2.AV_CODEC_ID_TMV = 126] = "AV_CODEC_ID_TMV", AVCodecID2[AVCodecID2.AV_CODEC_ID_V210 = 127] = "AV_CODEC_ID_V210", AVCodecID2[AVCodecID2.AV_CODEC_ID_DPX = 128] = "AV_CODEC_ID_DPX", AVCodecID2[AVCodecID2.AV_CODEC_ID_MAD = 129] = "AV_CODEC_ID_MAD", AVCodecID2[AVCodecID2.AV_CODEC_ID_FRWU = 130] = "AV_CODEC_ID_FRWU", AVCodecID2[AVCodecID2.AV_CODEC_ID_FLASHSV2 = 131] = "AV_CODEC_ID_FLASHSV2", AVCodecID2[AVCodecID2.AV_CODEC_ID_CDGRAPHICS = 132] = "AV_CODEC_ID_CDGRAPHICS", AVCodecID2[AVCodecID2.AV_CODEC_ID_R210 = 133] = "AV_CODEC_ID_R210", AVCodecID2[AVCodecID2.AV_CODEC_ID_ANM = 134] = "AV_CODEC_ID_ANM", AVCodecID2[AVCodecID2.AV_CODEC_ID_BINKVIDEO = 135] = "AV_CODEC_ID_BINKVIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_IFF_ILBM = 136] = "AV_CODEC_ID_IFF_ILBM", AVCodecID2[AVCodecID2.AV_CODEC_ID_IFF_BYTERUN1 = 136] = "AV_CODEC_ID_IFF_BYTERUN1", AVCodecID2[AVCodecID2.AV_CODEC_ID_KGV1 = 137] = "AV_CODEC_ID_KGV1", AVCodecID2[AVCodecID2.AV_CODEC_ID_YOP = 138] = "AV_CODEC_ID_YOP", AVCodecID2[AVCodecID2.AV_CODEC_ID_VP8 = 139] = "AV_CODEC_ID_VP8", AVCodecID2[AVCodecID2.AV_CODEC_ID_PICTOR = 140] = "AV_CODEC_ID_PICTOR", AVCodecID2[AVCodecID2.AV_CODEC_ID_ANSI = 141] = "AV_CODEC_ID_ANSI", AVCodecID2[AVCodecID2.AV_CODEC_ID_A64_MULTI = 142] = "AV_CODEC_ID_A64_MULTI", AVCodecID2[AVCodecID2.AV_CODEC_ID_A64_MULTI5 = 143] = "AV_CODEC_ID_A64_MULTI5", AVCodecID2[AVCodecID2.AV_CODEC_ID_R10K = 144] = "AV_CODEC_ID_R10K", AVCodecID2[AVCodecID2.AV_CODEC_ID_MXPEG = 145] = "AV_CODEC_ID_MXPEG", AVCodecID2[AVCodecID2.AV_CODEC_ID_LAGARITH = 146] = "AV_CODEC_ID_LAGARITH", AVCodecID2[AVCodecID2.AV_CODEC_ID_PRORES = 147] = "AV_CODEC_ID_PRORES", AVCodecID2[AVCodecID2.AV_CODEC_ID_JV = 148] = "AV_CODEC_ID_JV", AVCodecID2[AVCodecID2.AV_CODEC_ID_DFA = 149] = "AV_CODEC_ID_DFA", AVCodecID2[AVCodecID2.AV_CODEC_ID_WMV3IMAGE = 150] = "AV_CODEC_ID_WMV3IMAGE", AVCodecID2[AVCodecID2.AV_CODEC_ID_VC1IMAGE = 151] = "AV_CODEC_ID_VC1IMAGE", AVCodecID2[AVCodecID2.AV_CODEC_ID_UTVIDEO = 152] = "AV_CODEC_ID_UTVIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_BMV_VIDEO = 153] = "AV_CODEC_ID_BMV_VIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_VBLE = 154] = "AV_CODEC_ID_VBLE", AVCodecID2[AVCodecID2.AV_CODEC_ID_DXTORY = 155] = "AV_CODEC_ID_DXTORY", AVCodecID2[AVCodecID2.AV_CODEC_ID_V410 = 156] = "AV_CODEC_ID_V410", AVCodecID2[AVCodecID2.AV_CODEC_ID_XWD = 157] = "AV_CODEC_ID_XWD", AVCodecID2[AVCodecID2.AV_CODEC_ID_CDXL = 158] = "AV_CODEC_ID_CDXL", AVCodecID2[AVCodecID2.AV_CODEC_ID_XBM = 159] = "AV_CODEC_ID_XBM", AVCodecID2[AVCodecID2.AV_CODEC_ID_ZEROCODEC = 160] = "AV_CODEC_ID_ZEROCODEC", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSS1 = 161] = "AV_CODEC_ID_MSS1", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSA1 = 162] = "AV_CODEC_ID_MSA1", AVCodecID2[AVCodecID2.AV_CODEC_ID_TSCC2 = 163] = "AV_CODEC_ID_TSCC2", AVCodecID2[AVCodecID2.AV_CODEC_ID_MTS2 = 164] = "AV_CODEC_ID_MTS2", AVCodecID2[AVCodecID2.AV_CODEC_ID_CLLC = 165] = "AV_CODEC_ID_CLLC", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSS2 = 166] = "AV_CODEC_ID_MSS2", AVCodecID2[AVCodecID2.AV_CODEC_ID_VP9 = 167] = "AV_CODEC_ID_VP9", AVCodecID2[AVCodecID2.AV_CODEC_ID_AIC = 168] = "AV_CODEC_ID_AIC", AVCodecID2[AVCodecID2.AV_CODEC_ID_ESCAPE130 = 169] = "AV_CODEC_ID_ESCAPE130", AVCodecID2[AVCodecID2.AV_CODEC_ID_G2M = 170] = "AV_CODEC_ID_G2M", AVCodecID2[AVCodecID2.AV_CODEC_ID_WEBP = 171] = "AV_CODEC_ID_WEBP", AVCodecID2[AVCodecID2.AV_CODEC_ID_HNM4_VIDEO = 172] = "AV_CODEC_ID_HNM4_VIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_HEVC = 173] = "AV_CODEC_ID_HEVC", AVCodecID2[AVCodecID2.AV_CODEC_ID_H265 = 173] = "AV_CODEC_ID_H265", AVCodecID2[AVCodecID2.AV_CODEC_ID_FIC = 174] = "AV_CODEC_ID_FIC", AVCodecID2[AVCodecID2.AV_CODEC_ID_ALIAS_PIX = 175] = "AV_CODEC_ID_ALIAS_PIX", AVCodecID2[AVCodecID2.AV_CODEC_ID_BRENDER_PIX = 176] = "AV_CODEC_ID_BRENDER_PIX", AVCodecID2[AVCodecID2.AV_CODEC_ID_PAF_VIDEO = 177] = "AV_CODEC_ID_PAF_VIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_EXR = 178] = "AV_CODEC_ID_EXR", AVCodecID2[AVCodecID2.AV_CODEC_ID_VP7 = 179] = "AV_CODEC_ID_VP7", AVCodecID2[AVCodecID2.AV_CODEC_ID_SANM = 180] = "AV_CODEC_ID_SANM", AVCodecID2[AVCodecID2.AV_CODEC_ID_SGIRLE = 181] = "AV_CODEC_ID_SGIRLE", AVCodecID2[AVCodecID2.AV_CODEC_ID_MVC1 = 182] = "AV_CODEC_ID_MVC1", AVCodecID2[AVCodecID2.AV_CODEC_ID_MVC2 = 183] = "AV_CODEC_ID_MVC2", AVCodecID2[AVCodecID2.AV_CODEC_ID_HQX = 184] = "AV_CODEC_ID_HQX", AVCodecID2[AVCodecID2.AV_CODEC_ID_TDSC = 185] = "AV_CODEC_ID_TDSC", AVCodecID2[AVCodecID2.AV_CODEC_ID_HQ_HQA = 186] = "AV_CODEC_ID_HQ_HQA", AVCodecID2[AVCodecID2.AV_CODEC_ID_HAP = 187] = "AV_CODEC_ID_HAP", AVCodecID2[AVCodecID2.AV_CODEC_ID_DDS = 188] = "AV_CODEC_ID_DDS", AVCodecID2[AVCodecID2.AV_CODEC_ID_DXV = 189] = "AV_CODEC_ID_DXV", AVCodecID2[AVCodecID2.AV_CODEC_ID_SCREENPRESSO = 190] = "AV_CODEC_ID_SCREENPRESSO", AVCodecID2[AVCodecID2.AV_CODEC_ID_RSCC = 191] = "AV_CODEC_ID_RSCC", AVCodecID2[AVCodecID2.AV_CODEC_ID_AVS2 = 192] = "AV_CODEC_ID_AVS2", AVCodecID2[AVCodecID2.AV_CODEC_ID_PGX = 193] = "AV_CODEC_ID_PGX", AVCodecID2[AVCodecID2.AV_CODEC_ID_AVS3 = 194] = "AV_CODEC_ID_AVS3", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSP2 = 195] = "AV_CODEC_ID_MSP2", AVCodecID2[AVCodecID2.AV_CODEC_ID_VVC = 196] = "AV_CODEC_ID_VVC", AVCodecID2[AVCodecID2.AV_CODEC_ID_H266 = 196] = "AV_CODEC_ID_H266", AVCodecID2[AVCodecID2.AV_CODEC_ID_Y41P = 197] = "AV_CODEC_ID_Y41P", AVCodecID2[AVCodecID2.AV_CODEC_ID_AVRP = 198] = "AV_CODEC_ID_AVRP", AVCodecID2[AVCodecID2.AV_CODEC_ID_012V = 199] = "AV_CODEC_ID_012V", AVCodecID2[AVCodecID2.AV_CODEC_ID_AVUI = 200] = "AV_CODEC_ID_AVUI", AVCodecID2[AVCodecID2.AV_CODEC_ID_TARGA_Y216 = 201] = "AV_CODEC_ID_TARGA_Y216", AVCodecID2[AVCodecID2.AV_CODEC_ID_V308 = 202] = "AV_CODEC_ID_V308", AVCodecID2[AVCodecID2.AV_CODEC_ID_V408 = 203] = "AV_CODEC_ID_V408", AVCodecID2[AVCodecID2.AV_CODEC_ID_YUV4 = 204] = "AV_CODEC_ID_YUV4", AVCodecID2[AVCodecID2.AV_CODEC_ID_AVRN = 205] = "AV_CODEC_ID_AVRN", AVCodecID2[AVCodecID2.AV_CODEC_ID_CPIA = 206] = "AV_CODEC_ID_CPIA", AVCodecID2[AVCodecID2.AV_CODEC_ID_XFACE = 207] = "AV_CODEC_ID_XFACE", AVCodecID2[AVCodecID2.AV_CODEC_ID_SNOW = 208] = "AV_CODEC_ID_SNOW", AVCodecID2[AVCodecID2.AV_CODEC_ID_SMVJPEG = 209] = "AV_CODEC_ID_SMVJPEG", AVCodecID2[AVCodecID2.AV_CODEC_ID_APNG = 210] = "AV_CODEC_ID_APNG", AVCodecID2[AVCodecID2.AV_CODEC_ID_DAALA = 211] = "AV_CODEC_ID_DAALA", AVCodecID2[AVCodecID2.AV_CODEC_ID_CFHD = 212] = "AV_CODEC_ID_CFHD", AVCodecID2[AVCodecID2.AV_CODEC_ID_TRUEMOTION2RT = 213] = "AV_CODEC_ID_TRUEMOTION2RT", AVCodecID2[AVCodecID2.AV_CODEC_ID_M101 = 214] = "AV_CODEC_ID_M101", AVCodecID2[AVCodecID2.AV_CODEC_ID_MAGICYUV = 215] = "AV_CODEC_ID_MAGICYUV", AVCodecID2[AVCodecID2.AV_CODEC_ID_SHEERVIDEO = 216] = "AV_CODEC_ID_SHEERVIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_YLC = 217] = "AV_CODEC_ID_YLC", AVCodecID2[AVCodecID2.AV_CODEC_ID_PSD = 218] = "AV_CODEC_ID_PSD", AVCodecID2[AVCodecID2.AV_CODEC_ID_PIXLET = 219] = "AV_CODEC_ID_PIXLET", AVCodecID2[AVCodecID2.AV_CODEC_ID_SPEEDHQ = 220] = "AV_CODEC_ID_SPEEDHQ", AVCodecID2[AVCodecID2.AV_CODEC_ID_FMVC = 221] = "AV_CODEC_ID_FMVC", AVCodecID2[AVCodecID2.AV_CODEC_ID_SCPR = 222] = "AV_CODEC_ID_SCPR", AVCodecID2[AVCodecID2.AV_CODEC_ID_CLEARVIDEO = 223] = "AV_CODEC_ID_CLEARVIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_XPM = 224] = "AV_CODEC_ID_XPM", AVCodecID2[AVCodecID2.AV_CODEC_ID_AV1 = 225] = "AV_CODEC_ID_AV1", AVCodecID2[AVCodecID2.AV_CODEC_ID_BITPACKED = 226] = "AV_CODEC_ID_BITPACKED", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSCC = 227] = "AV_CODEC_ID_MSCC", AVCodecID2[AVCodecID2.AV_CODEC_ID_SRGC = 228] = "AV_CODEC_ID_SRGC", AVCodecID2[AVCodecID2.AV_CODEC_ID_SVG = 229] = "AV_CODEC_ID_SVG", AVCodecID2[AVCodecID2.AV_CODEC_ID_GDV = 230] = "AV_CODEC_ID_GDV", AVCodecID2[AVCodecID2.AV_CODEC_ID_FITS = 231] = "AV_CODEC_ID_FITS", AVCodecID2[AVCodecID2.AV_CODEC_ID_IMM4 = 232] = "AV_CODEC_ID_IMM4", AVCodecID2[AVCodecID2.AV_CODEC_ID_PROSUMER = 233] = "AV_CODEC_ID_PROSUMER", AVCodecID2[AVCodecID2.AV_CODEC_ID_MWSC = 234] = "AV_CODEC_ID_MWSC", AVCodecID2[AVCodecID2.AV_CODEC_ID_WCMV = 235] = "AV_CODEC_ID_WCMV", AVCodecID2[AVCodecID2.AV_CODEC_ID_RASC = 236] = "AV_CODEC_ID_RASC", AVCodecID2[AVCodecID2.AV_CODEC_ID_HYMT = 237] = "AV_CODEC_ID_HYMT", AVCodecID2[AVCodecID2.AV_CODEC_ID_ARBC = 238] = "AV_CODEC_ID_ARBC", AVCodecID2[AVCodecID2.AV_CODEC_ID_AGM = 239] = "AV_CODEC_ID_AGM", AVCodecID2[AVCodecID2.AV_CODEC_ID_LSCR = 240] = "AV_CODEC_ID_LSCR", AVCodecID2[AVCodecID2.AV_CODEC_ID_VP4 = 241] = "AV_CODEC_ID_VP4", AVCodecID2[AVCodecID2.AV_CODEC_ID_IMM5 = 242] = "AV_CODEC_ID_IMM5", AVCodecID2[AVCodecID2.AV_CODEC_ID_MVDV = 243] = "AV_CODEC_ID_MVDV", AVCodecID2[AVCodecID2.AV_CODEC_ID_MVHA = 244] = "AV_CODEC_ID_MVHA", AVCodecID2[AVCodecID2.AV_CODEC_ID_CDTOONS = 245] = "AV_CODEC_ID_CDTOONS", AVCodecID2[AVCodecID2.AV_CODEC_ID_MV30 = 246] = "AV_CODEC_ID_MV30", AVCodecID2[AVCodecID2.AV_CODEC_ID_NOTCHLC = 247] = "AV_CODEC_ID_NOTCHLC", AVCodecID2[AVCodecID2.AV_CODEC_ID_PFM = 248] = "AV_CODEC_ID_PFM", AVCodecID2[AVCodecID2.AV_CODEC_ID_MOBICLIP = 249] = "AV_CODEC_ID_MOBICLIP", AVCodecID2[AVCodecID2.AV_CODEC_ID_PHOTOCD = 250] = "AV_CODEC_ID_PHOTOCD", AVCodecID2[AVCodecID2.AV_CODEC_ID_IPU = 251] = "AV_CODEC_ID_IPU", AVCodecID2[AVCodecID2.AV_CODEC_ID_ARGO = 252] = "AV_CODEC_ID_ARGO", AVCodecID2[AVCodecID2.AV_CODEC_ID_CRI = 253] = "AV_CODEC_ID_CRI", AVCodecID2[AVCodecID2.AV_CODEC_ID_SIMBIOSIS_IMX = 254] = "AV_CODEC_ID_SIMBIOSIS_IMX", AVCodecID2[AVCodecID2.AV_CODEC_ID_SGA_VIDEO = 255] = "AV_CODEC_ID_SGA_VIDEO", AVCodecID2[AVCodecID2.AV_CODEC_ID_GEM = 256] = "AV_CODEC_ID_GEM", AVCodecID2[AVCodecID2.AV_CODEC_ID_VBN = 257] = "AV_CODEC_ID_VBN", AVCodecID2[AVCodecID2.AV_CODEC_ID_JPEGXL = 258] = "AV_CODEC_ID_JPEGXL", AVCodecID2[AVCodecID2.AV_CODEC_ID_QOI = 259] = "AV_CODEC_ID_QOI", AVCodecID2[AVCodecID2.AV_CODEC_ID_PHM = 260] = "AV_CODEC_ID_PHM", AVCodecID2[AVCodecID2.AV_CODEC_ID_RADIANCE_HDR = 261] = "AV_CODEC_ID_RADIANCE_HDR", AVCodecID2[AVCodecID2.AV_CODEC_ID_WBMP = 262] = "AV_CODEC_ID_WBMP", AVCodecID2[AVCodecID2.AV_CODEC_ID_MEDIA100 = 263] = "AV_CODEC_ID_MEDIA100", AVCodecID2[AVCodecID2.AV_CODEC_ID_VQC = 264] = "AV_CODEC_ID_VQC", AVCodecID2[AVCodecID2.AV_CODEC_ID_PDV = 265] = "AV_CODEC_ID_PDV", AVCodecID2[AVCodecID2.AV_CODEC_ID_EVC = 266] = "AV_CODEC_ID_EVC", AVCodecID2[AVCodecID2.AV_CODEC_ID_RTV1 = 267] = "AV_CODEC_ID_RTV1", AVCodecID2[AVCodecID2.AV_CODEC_ID_VMIX = 268] = "AV_CODEC_ID_VMIX", AVCodecID2[AVCodecID2.AV_CODEC_ID_LEAD = 269] = "AV_CODEC_ID_LEAD", AVCodecID2[AVCodecID2.AV_CODEC_ID_FIRST_AUDIO = 65536] = "AV_CODEC_ID_FIRST_AUDIO", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S16LE = 65536] = "AV_CODEC_ID_PCM_S16LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S16BE = 65537] = "AV_CODEC_ID_PCM_S16BE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_U16LE = 65538] = "AV_CODEC_ID_PCM_U16LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_U16BE = 65539] = "AV_CODEC_ID_PCM_U16BE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S8 = 65540] = "AV_CODEC_ID_PCM_S8", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_U8 = 65541] = "AV_CODEC_ID_PCM_U8", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_MULAW = 65542] = "AV_CODEC_ID_PCM_MULAW", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_ALAW = 65543] = "AV_CODEC_ID_PCM_ALAW", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S32LE = 65544] = "AV_CODEC_ID_PCM_S32LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S32BE = 65545] = "AV_CODEC_ID_PCM_S32BE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_U32LE = 65546] = "AV_CODEC_ID_PCM_U32LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_U32BE = 65547] = "AV_CODEC_ID_PCM_U32BE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S24LE = 65548] = "AV_CODEC_ID_PCM_S24LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S24BE = 65549] = "AV_CODEC_ID_PCM_S24BE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_U24LE = 65550] = "AV_CODEC_ID_PCM_U24LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_U24BE = 65551] = "AV_CODEC_ID_PCM_U24BE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S24DAUD = 65552] = "AV_CODEC_ID_PCM_S24DAUD", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_ZORK = 65553] = "AV_CODEC_ID_PCM_ZORK", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S16LE_PLANAR = 65554] = "AV_CODEC_ID_PCM_S16LE_PLANAR", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_DVD = 65555] = "AV_CODEC_ID_PCM_DVD", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_F32BE = 65556] = "AV_CODEC_ID_PCM_F32BE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_F32LE = 65557] = "AV_CODEC_ID_PCM_F32LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_F64BE = 65558] = "AV_CODEC_ID_PCM_F64BE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_F64LE = 65559] = "AV_CODEC_ID_PCM_F64LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_BLURAY = 65560] = "AV_CODEC_ID_PCM_BLURAY", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_LXF = 65561] = "AV_CODEC_ID_PCM_LXF", AVCodecID2[AVCodecID2.AV_CODEC_ID_S302M = 65562] = "AV_CODEC_ID_S302M", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S8_PLANAR = 65563] = "AV_CODEC_ID_PCM_S8_PLANAR", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S24LE_PLANAR = 65564] = "AV_CODEC_ID_PCM_S24LE_PLANAR", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S32LE_PLANAR = 65565] = "AV_CODEC_ID_PCM_S32LE_PLANAR", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S16BE_PLANAR = 65566] = "AV_CODEC_ID_PCM_S16BE_PLANAR", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S64LE = 65567] = "AV_CODEC_ID_PCM_S64LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_S64BE = 65568] = "AV_CODEC_ID_PCM_S64BE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_F16LE = 65569] = "AV_CODEC_ID_PCM_F16LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_F24LE = 65570] = "AV_CODEC_ID_PCM_F24LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_VIDC = 65571] = "AV_CODEC_ID_PCM_VIDC", AVCodecID2[AVCodecID2.AV_CODEC_ID_PCM_SGA = 65572] = "AV_CODEC_ID_PCM_SGA", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_QT = 69632] = "AV_CODEC_ID_ADPCM_IMA_QT", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_WAV = 69633] = "AV_CODEC_ID_ADPCM_IMA_WAV", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_DK3 = 69634] = "AV_CODEC_ID_ADPCM_IMA_DK3", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_DK4 = 69635] = "AV_CODEC_ID_ADPCM_IMA_DK4", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_WS = 69636] = "AV_CODEC_ID_ADPCM_IMA_WS", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637] = "AV_CODEC_ID_ADPCM_IMA_SMJPEG", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_MS = 69638] = "AV_CODEC_ID_ADPCM_MS", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_4XM = 69639] = "AV_CODEC_ID_ADPCM_4XM", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_XA = 69640] = "AV_CODEC_ID_ADPCM_XA", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_ADX = 69641] = "AV_CODEC_ID_ADPCM_ADX", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_EA = 69642] = "AV_CODEC_ID_ADPCM_EA", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_G726 = 69643] = "AV_CODEC_ID_ADPCM_G726", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_CT = 69644] = "AV_CODEC_ID_ADPCM_CT", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_SWF = 69645] = "AV_CODEC_ID_ADPCM_SWF", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_YAMAHA = 69646] = "AV_CODEC_ID_ADPCM_YAMAHA", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_SBPRO_4 = 69647] = "AV_CODEC_ID_ADPCM_SBPRO_4", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_SBPRO_3 = 69648] = "AV_CODEC_ID_ADPCM_SBPRO_3", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_SBPRO_2 = 69649] = "AV_CODEC_ID_ADPCM_SBPRO_2", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_THP = 69650] = "AV_CODEC_ID_ADPCM_THP", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_AMV = 69651] = "AV_CODEC_ID_ADPCM_IMA_AMV", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_EA_R1 = 69652] = "AV_CODEC_ID_ADPCM_EA_R1", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_EA_R3 = 69653] = "AV_CODEC_ID_ADPCM_EA_R3", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_EA_R2 = 69654] = "AV_CODEC_ID_ADPCM_EA_R2", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655] = "AV_CODEC_ID_ADPCM_IMA_EA_SEAD", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656] = "AV_CODEC_ID_ADPCM_IMA_EA_EACS", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_EA_XAS = 69657] = "AV_CODEC_ID_ADPCM_EA_XAS", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658] = "AV_CODEC_ID_ADPCM_EA_MAXIS_XA", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_ISS = 69659] = "AV_CODEC_ID_ADPCM_IMA_ISS", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_G722 = 69660] = "AV_CODEC_ID_ADPCM_G722", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_APC = 69661] = "AV_CODEC_ID_ADPCM_IMA_APC", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_VIMA = 69662] = "AV_CODEC_ID_ADPCM_VIMA", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_AFC = 69663] = "AV_CODEC_ID_ADPCM_AFC", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_OKI = 69664] = "AV_CODEC_ID_ADPCM_IMA_OKI", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_DTK = 69665] = "AV_CODEC_ID_ADPCM_DTK", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_RAD = 69666] = "AV_CODEC_ID_ADPCM_IMA_RAD", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_G726LE = 69667] = "AV_CODEC_ID_ADPCM_G726LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_THP_LE = 69668] = "AV_CODEC_ID_ADPCM_THP_LE", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_PSX = 69669] = "AV_CODEC_ID_ADPCM_PSX", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_AICA = 69670] = "AV_CODEC_ID_ADPCM_AICA", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_DAT4 = 69671] = "AV_CODEC_ID_ADPCM_IMA_DAT4", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_MTAF = 69672] = "AV_CODEC_ID_ADPCM_MTAF", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_AGM = 69673] = "AV_CODEC_ID_ADPCM_AGM", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_ARGO = 69674] = "AV_CODEC_ID_ADPCM_ARGO", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_SSI = 69675] = "AV_CODEC_ID_ADPCM_IMA_SSI", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_ZORK = 69676] = "AV_CODEC_ID_ADPCM_ZORK", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_APM = 69677] = "AV_CODEC_ID_ADPCM_IMA_APM", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_ALP = 69678] = "AV_CODEC_ID_ADPCM_IMA_ALP", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_MTF = 69679] = "AV_CODEC_ID_ADPCM_IMA_MTF", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_CUNNING = 69680] = "AV_CODEC_ID_ADPCM_IMA_CUNNING", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_MOFLEX = 69681] = "AV_CODEC_ID_ADPCM_IMA_MOFLEX", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_IMA_ACORN = 69682] = "AV_CODEC_ID_ADPCM_IMA_ACORN", AVCodecID2[AVCodecID2.AV_CODEC_ID_ADPCM_XMD = 69683] = "AV_CODEC_ID_ADPCM_XMD", AVCodecID2[AVCodecID2.AV_CODEC_ID_AMR_NB = 73728] = "AV_CODEC_ID_AMR_NB", AVCodecID2[AVCodecID2.AV_CODEC_ID_AMR_WB = 73729] = "AV_CODEC_ID_AMR_WB", AVCodecID2[AVCodecID2.AV_CODEC_ID_RA_144 = 77824] = "AV_CODEC_ID_RA_144", AVCodecID2[AVCodecID2.AV_CODEC_ID_RA_288 = 77825] = "AV_CODEC_ID_RA_288", AVCodecID2[AVCodecID2.AV_CODEC_ID_ROQ_DPCM = 81920] = "AV_CODEC_ID_ROQ_DPCM", AVCodecID2[AVCodecID2.AV_CODEC_ID_INTERPLAY_DPCM = 81921] = "AV_CODEC_ID_INTERPLAY_DPCM", AVCodecID2[AVCodecID2.AV_CODEC_ID_XAN_DPCM = 81922] = "AV_CODEC_ID_XAN_DPCM", AVCodecID2[AVCodecID2.AV_CODEC_ID_SOL_DPCM = 81923] = "AV_CODEC_ID_SOL_DPCM", AVCodecID2[AVCodecID2.AV_CODEC_ID_SDX2_DPCM = 81924] = "AV_CODEC_ID_SDX2_DPCM", AVCodecID2[AVCodecID2.AV_CODEC_ID_GREMLIN_DPCM = 81925] = "AV_CODEC_ID_GREMLIN_DPCM", AVCodecID2[AVCodecID2.AV_CODEC_ID_DERF_DPCM = 81926] = "AV_CODEC_ID_DERF_DPCM", AVCodecID2[AVCodecID2.AV_CODEC_ID_WADY_DPCM = 81927] = "AV_CODEC_ID_WADY_DPCM", AVCodecID2[AVCodecID2.AV_CODEC_ID_CBD2_DPCM = 81928] = "AV_CODEC_ID_CBD2_DPCM", AVCodecID2[AVCodecID2.AV_CODEC_ID_MP2 = 86016] = "AV_CODEC_ID_MP2", AVCodecID2[AVCodecID2.AV_CODEC_ID_MP3 = 86017] = "AV_CODEC_ID_MP3", AVCodecID2[AVCodecID2.AV_CODEC_ID_AAC = 86018] = "AV_CODEC_ID_AAC", AVCodecID2[AVCodecID2.AV_CODEC_ID_AC3 = 86019] = "AV_CODEC_ID_AC3", AVCodecID2[AVCodecID2.AV_CODEC_ID_DTS = 86020] = "AV_CODEC_ID_DTS", AVCodecID2[AVCodecID2.AV_CODEC_ID_VORBIS = 86021] = "AV_CODEC_ID_VORBIS", AVCodecID2[AVCodecID2.AV_CODEC_ID_DVAUDIO = 86022] = "AV_CODEC_ID_DVAUDIO", AVCodecID2[AVCodecID2.AV_CODEC_ID_WMAV1 = 86023] = "AV_CODEC_ID_WMAV1", AVCodecID2[AVCodecID2.AV_CODEC_ID_WMAV2 = 86024] = "AV_CODEC_ID_WMAV2", AVCodecID2[AVCodecID2.AV_CODEC_ID_MACE3 = 86025] = "AV_CODEC_ID_MACE3", AVCodecID2[AVCodecID2.AV_CODEC_ID_MACE6 = 86026] = "AV_CODEC_ID_MACE6", AVCodecID2[AVCodecID2.AV_CODEC_ID_VMDAUDIO = 86027] = "AV_CODEC_ID_VMDAUDIO", AVCodecID2[AVCodecID2.AV_CODEC_ID_FLAC = 86028] = "AV_CODEC_ID_FLAC", AVCodecID2[AVCodecID2.AV_CODEC_ID_MP3ADU = 86029] = "AV_CODEC_ID_MP3ADU", AVCodecID2[AVCodecID2.AV_CODEC_ID_MP3ON4 = 86030] = "AV_CODEC_ID_MP3ON4", AVCodecID2[AVCodecID2.AV_CODEC_ID_SHORTEN = 86031] = "AV_CODEC_ID_SHORTEN", AVCodecID2[AVCodecID2.AV_CODEC_ID_ALAC = 86032] = "AV_CODEC_ID_ALAC", AVCodecID2[AVCodecID2.AV_CODEC_ID_WESTWOOD_SND1 = 86033] = "AV_CODEC_ID_WESTWOOD_SND1", AVCodecID2[AVCodecID2.AV_CODEC_ID_GSM = 86034] = "AV_CODEC_ID_GSM", AVCodecID2[AVCodecID2.AV_CODEC_ID_QDM2 = 86035] = "AV_CODEC_ID_QDM2", AVCodecID2[AVCodecID2.AV_CODEC_ID_COOK = 86036] = "AV_CODEC_ID_COOK", AVCodecID2[AVCodecID2.AV_CODEC_ID_TRUESPEECH = 86037] = "AV_CODEC_ID_TRUESPEECH", AVCodecID2[AVCodecID2.AV_CODEC_ID_TTA = 86038] = "AV_CODEC_ID_TTA", AVCodecID2[AVCodecID2.AV_CODEC_ID_SMACKAUDIO = 86039] = "AV_CODEC_ID_SMACKAUDIO", AVCodecID2[AVCodecID2.AV_CODEC_ID_QCELP = 86040] = "AV_CODEC_ID_QCELP", AVCodecID2[AVCodecID2.AV_CODEC_ID_WAVPACK = 86041] = "AV_CODEC_ID_WAVPACK", AVCodecID2[AVCodecID2.AV_CODEC_ID_DSICINAUDIO = 86042] = "AV_CODEC_ID_DSICINAUDIO", AVCodecID2[AVCodecID2.AV_CODEC_ID_IMC = 86043] = "AV_CODEC_ID_IMC", AVCodecID2[AVCodecID2.AV_CODEC_ID_MUSEPACK7 = 86044] = "AV_CODEC_ID_MUSEPACK7", AVCodecID2[AVCodecID2.AV_CODEC_ID_MLP = 86045] = "AV_CODEC_ID_MLP", AVCodecID2[AVCodecID2.AV_CODEC_ID_GSM_MS = 86046] = "AV_CODEC_ID_GSM_MS", AVCodecID2[AVCodecID2.AV_CODEC_ID_ATRAC3 = 86047] = "AV_CODEC_ID_ATRAC3", AVCodecID2[AVCodecID2.AV_CODEC_ID_APE = 86048] = "AV_CODEC_ID_APE", AVCodecID2[AVCodecID2.AV_CODEC_ID_NELLYMOSER = 86049] = "AV_CODEC_ID_NELLYMOSER", AVCodecID2[AVCodecID2.AV_CODEC_ID_MUSEPACK8 = 86050] = "AV_CODEC_ID_MUSEPACK8", AVCodecID2[AVCodecID2.AV_CODEC_ID_SPEEX = 86051] = "AV_CODEC_ID_SPEEX", AVCodecID2[AVCodecID2.AV_CODEC_ID_WMAVOICE = 86052] = "AV_CODEC_ID_WMAVOICE", AVCodecID2[AVCodecID2.AV_CODEC_ID_WMAPRO = 86053] = "AV_CODEC_ID_WMAPRO", AVCodecID2[AVCodecID2.AV_CODEC_ID_WMALOSSLESS = 86054] = "AV_CODEC_ID_WMALOSSLESS", AVCodecID2[AVCodecID2.AV_CODEC_ID_ATRAC3P = 86055] = "AV_CODEC_ID_ATRAC3P", AVCodecID2[AVCodecID2.AV_CODEC_ID_EAC3 = 86056] = "AV_CODEC_ID_EAC3", AVCodecID2[AVCodecID2.AV_CODEC_ID_SIPR = 86057] = "AV_CODEC_ID_SIPR", AVCodecID2[AVCodecID2.AV_CODEC_ID_MP1 = 86058] = "AV_CODEC_ID_MP1", AVCodecID2[AVCodecID2.AV_CODEC_ID_TWINVQ = 86059] = "AV_CODEC_ID_TWINVQ", AVCodecID2[AVCodecID2.AV_CODEC_ID_TRUEHD = 86060] = "AV_CODEC_ID_TRUEHD", AVCodecID2[AVCodecID2.AV_CODEC_ID_MP4ALS = 86061] = "AV_CODEC_ID_MP4ALS", AVCodecID2[AVCodecID2.AV_CODEC_ID_ATRAC1 = 86062] = "AV_CODEC_ID_ATRAC1", AVCodecID2[AVCodecID2.AV_CODEC_ID_BINKAUDIO_RDFT = 86063] = "AV_CODEC_ID_BINKAUDIO_RDFT", AVCodecID2[AVCodecID2.AV_CODEC_ID_BINKAUDIO_DCT = 86064] = "AV_CODEC_ID_BINKAUDIO_DCT", AVCodecID2[AVCodecID2.AV_CODEC_ID_AAC_LATM = 86065] = "AV_CODEC_ID_AAC_LATM", AVCodecID2[AVCodecID2.AV_CODEC_ID_QDMC = 86066] = "AV_CODEC_ID_QDMC", AVCodecID2[AVCodecID2.AV_CODEC_ID_CELT = 86067] = "AV_CODEC_ID_CELT", AVCodecID2[AVCodecID2.AV_CODEC_ID_G723_1 = 86068] = "AV_CODEC_ID_G723_1", AVCodecID2[AVCodecID2.AV_CODEC_ID_G729 = 86069] = "AV_CODEC_ID_G729", AVCodecID2[AVCodecID2.AV_CODEC_ID_8SVX_EXP = 86070] = "AV_CODEC_ID_8SVX_EXP", AVCodecID2[AVCodecID2.AV_CODEC_ID_8SVX_FIB = 86071] = "AV_CODEC_ID_8SVX_FIB", AVCodecID2[AVCodecID2.AV_CODEC_ID_BMV_AUDIO = 86072] = "AV_CODEC_ID_BMV_AUDIO", AVCodecID2[AVCodecID2.AV_CODEC_ID_RALF = 86073] = "AV_CODEC_ID_RALF", AVCodecID2[AVCodecID2.AV_CODEC_ID_IAC = 86074] = "AV_CODEC_ID_IAC", AVCodecID2[AVCodecID2.AV_CODEC_ID_ILBC = 86075] = "AV_CODEC_ID_ILBC", AVCodecID2[AVCodecID2.AV_CODEC_ID_OPUS = 86076] = "AV_CODEC_ID_OPUS", AVCodecID2[AVCodecID2.AV_CODEC_ID_COMFORT_NOISE = 86077] = "AV_CODEC_ID_COMFORT_NOISE", AVCodecID2[AVCodecID2.AV_CODEC_ID_TAK = 86078] = "AV_CODEC_ID_TAK", AVCodecID2[AVCodecID2.AV_CODEC_ID_METASOUND = 86079] = "AV_CODEC_ID_METASOUND", AVCodecID2[AVCodecID2.AV_CODEC_ID_PAF_AUDIO = 86080] = "AV_CODEC_ID_PAF_AUDIO", AVCodecID2[AVCodecID2.AV_CODEC_ID_ON2AVC = 86081] = "AV_CODEC_ID_ON2AVC", AVCodecID2[AVCodecID2.AV_CODEC_ID_DSS_SP = 86082] = "AV_CODEC_ID_DSS_SP", AVCodecID2[AVCodecID2.AV_CODEC_ID_CODEC2 = 86083] = "AV_CODEC_ID_CODEC2", AVCodecID2[AVCodecID2.AV_CODEC_ID_FFWAVESYNTH = 86084] = "AV_CODEC_ID_FFWAVESYNTH", AVCodecID2[AVCodecID2.AV_CODEC_ID_SONIC = 86085] = "AV_CODEC_ID_SONIC", AVCodecID2[AVCodecID2.AV_CODEC_ID_SONIC_LS = 86086] = "AV_CODEC_ID_SONIC_LS", AVCodecID2[AVCodecID2.AV_CODEC_ID_EVRC = 86087] = "AV_CODEC_ID_EVRC", AVCodecID2[AVCodecID2.AV_CODEC_ID_SMV = 86088] = "AV_CODEC_ID_SMV", AVCodecID2[AVCodecID2.AV_CODEC_ID_DSD_LSBF = 86089] = "AV_CODEC_ID_DSD_LSBF", AVCodecID2[AVCodecID2.AV_CODEC_ID_DSD_MSBF = 86090] = "AV_CODEC_ID_DSD_MSBF", AVCodecID2[AVCodecID2.AV_CODEC_ID_DSD_LSBF_PLANAR = 86091] = "AV_CODEC_ID_DSD_LSBF_PLANAR", AVCodecID2[AVCodecID2.AV_CODEC_ID_DSD_MSBF_PLANAR = 86092] = "AV_CODEC_ID_DSD_MSBF_PLANAR", AVCodecID2[AVCodecID2.AV_CODEC_ID_4GV = 86093] = "AV_CODEC_ID_4GV", AVCodecID2[AVCodecID2.AV_CODEC_ID_INTERPLAY_ACM = 86094] = "AV_CODEC_ID_INTERPLAY_ACM", AVCodecID2[AVCodecID2.AV_CODEC_ID_XMA1 = 86095] = "AV_CODEC_ID_XMA1", AVCodecID2[AVCodecID2.AV_CODEC_ID_XMA2 = 86096] = "AV_CODEC_ID_XMA2", AVCodecID2[AVCodecID2.AV_CODEC_ID_DST = 86097] = "AV_CODEC_ID_DST", AVCodecID2[AVCodecID2.AV_CODEC_ID_ATRAC3AL = 86098] = "AV_CODEC_ID_ATRAC3AL", AVCodecID2[AVCodecID2.AV_CODEC_ID_ATRAC3PAL = 86099] = "AV_CODEC_ID_ATRAC3PAL", AVCodecID2[AVCodecID2.AV_CODEC_ID_DOLBY_E = 86100] = "AV_CODEC_ID_DOLBY_E", AVCodecID2[AVCodecID2.AV_CODEC_ID_APTX = 86101] = "AV_CODEC_ID_APTX", AVCodecID2[AVCodecID2.AV_CODEC_ID_APTX_HD = 86102] = "AV_CODEC_ID_APTX_HD", AVCodecID2[AVCodecID2.AV_CODEC_ID_SBC = 86103] = "AV_CODEC_ID_SBC", AVCodecID2[AVCodecID2.AV_CODEC_ID_ATRAC9 = 86104] = "AV_CODEC_ID_ATRAC9", AVCodecID2[AVCodecID2.AV_CODEC_ID_HCOM = 86105] = "AV_CODEC_ID_HCOM", AVCodecID2[AVCodecID2.AV_CODEC_ID_ACELP_KELVIN = 86106] = "AV_CODEC_ID_ACELP_KELVIN", AVCodecID2[AVCodecID2.AV_CODEC_ID_MPEGH_3D_AUDIO = 86107] = "AV_CODEC_ID_MPEGH_3D_AUDIO", AVCodecID2[AVCodecID2.AV_CODEC_ID_SIREN = 86108] = "AV_CODEC_ID_SIREN", AVCodecID2[AVCodecID2.AV_CODEC_ID_HCA = 86109] = "AV_CODEC_ID_HCA", AVCodecID2[AVCodecID2.AV_CODEC_ID_FASTAUDIO = 86110] = "AV_CODEC_ID_FASTAUDIO", AVCodecID2[AVCodecID2.AV_CODEC_ID_MSNSIREN = 86111] = "AV_CODEC_ID_MSNSIREN", AVCodecID2[AVCodecID2.AV_CODEC_ID_DFPWM = 86112] = "AV_CODEC_ID_DFPWM", AVCodecID2[AVCodecID2.AV_CODEC_ID_BONK = 86113] = "AV_CODEC_ID_BONK", AVCodecID2[AVCodecID2.AV_CODEC_ID_MISC4 = 86114] = "AV_CODEC_ID_MISC4", AVCodecID2[AVCodecID2.AV_CODEC_ID_APAC = 86115] = "AV_CODEC_ID_APAC", AVCodecID2[AVCodecID2.AV_CODEC_ID_FTR = 86116] = "AV_CODEC_ID_FTR", AVCodecID2[AVCodecID2.AV_CODEC_ID_WAVARC = 86117] = "AV_CODEC_ID_WAVARC", AVCodecID2[AVCodecID2.AV_CODEC_ID_RKA = 86118] = "AV_CODEC_ID_RKA", AVCodecID2[AVCodecID2.AV_CODEC_ID_AC4 = 86119] = "AV_CODEC_ID_AC4", AVCodecID2[AVCodecID2.AV_CODEC_ID_OSQ = 86120] = "AV_CODEC_ID_OSQ", AVCodecID2[AVCodecID2.AV_CODEC_ID_QOA = 86121] = "AV_CODEC_ID_QOA", AVCodecID2[AVCodecID2.AV_CODEC_ID_FIRST_SUBTITLE = 94208] = "AV_CODEC_ID_FIRST_SUBTITLE", AVCodecID2[AVCodecID2.AV_CODEC_ID_DVD_SUBTITLE = 94208] = "AV_CODEC_ID_DVD_SUBTITLE", AVCodecID2[AVCodecID2.AV_CODEC_ID_DVB_SUBTITLE = 94209] = "AV_CODEC_ID_DVB_SUBTITLE", AVCodecID2[AVCodecID2.AV_CODEC_ID_TEXT = 94210] = "AV_CODEC_ID_TEXT", AVCodecID2[AVCodecID2.AV_CODEC_ID_XSUB = 94211] = "AV_CODEC_ID_XSUB", AVCodecID2[AVCodecID2.AV_CODEC_ID_SSA = 94212] = "AV_CODEC_ID_SSA", AVCodecID2[AVCodecID2.AV_CODEC_ID_MOV_TEXT = 94213] = "AV_CODEC_ID_MOV_TEXT", AVCodecID2[AVCodecID2.AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214] = "AV_CODEC_ID_HDMV_PGS_SUBTITLE", AVCodecID2[AVCodecID2.AV_CODEC_ID_DVB_TELETEXT = 94215] = "AV_CODEC_ID_DVB_TELETEXT", AVCodecID2[AVCodecID2.AV_CODEC_ID_SRT = 94216] = "AV_CODEC_ID_SRT", AVCodecID2[AVCodecID2.AV_CODEC_ID_MICRODVD = 94217] = "AV_CODEC_ID_MICRODVD", AVCodecID2[AVCodecID2.AV_CODEC_ID_EIA_608 = 94218] = "AV_CODEC_ID_EIA_608", AVCodecID2[AVCodecID2.AV_CODEC_ID_JACOSUB = 94219] = "AV_CODEC_ID_JACOSUB", AVCodecID2[AVCodecID2.AV_CODEC_ID_SAMI = 94220] = "AV_CODEC_ID_SAMI", AVCodecID2[AVCodecID2.AV_CODEC_ID_REALTEXT = 94221] = "AV_CODEC_ID_REALTEXT", AVCodecID2[AVCodecID2.AV_CODEC_ID_STL = 94222] = "AV_CODEC_ID_STL", AVCodecID2[AVCodecID2.AV_CODEC_ID_SUBVIEWER1 = 94223] = "AV_CODEC_ID_SUBVIEWER1", AVCodecID2[AVCodecID2.AV_CODEC_ID_SUBVIEWER = 94224] = "AV_CODEC_ID_SUBVIEWER", AVCodecID2[AVCodecID2.AV_CODEC_ID_SUBRIP = 94225] = "AV_CODEC_ID_SUBRIP", AVCodecID2[AVCodecID2.AV_CODEC_ID_WEBVTT = 94226] = "AV_CODEC_ID_WEBVTT", AVCodecID2[AVCodecID2.AV_CODEC_ID_MPL2 = 94227] = "AV_CODEC_ID_MPL2", AVCodecID2[AVCodecID2.AV_CODEC_ID_VPLAYER = 94228] = "AV_CODEC_ID_VPLAYER", AVCodecID2[AVCodecID2.AV_CODEC_ID_PJS = 94229] = "AV_CODEC_ID_PJS", AVCodecID2[AVCodecID2.AV_CODEC_ID_ASS = 94230] = "AV_CODEC_ID_ASS", AVCodecID2[AVCodecID2.AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 94231] = "AV_CODEC_ID_HDMV_TEXT_SUBTITLE", AVCodecID2[AVCodecID2.AV_CODEC_ID_TTML = 94232] = "AV_CODEC_ID_TTML", AVCodecID2[AVCodecID2.AV_CODEC_ID_ARIB_CAPTION = 94233] = "AV_CODEC_ID_ARIB_CAPTION", AVCodecID2[AVCodecID2.AV_CODEC_ID_FIRST_UNKNOWN = 98304] = "AV_CODEC_ID_FIRST_UNKNOWN", AVCodecID2[AVCodecID2.AV_CODEC_ID_TTF = 98304] = "AV_CODEC_ID_TTF", AVCodecID2[AVCodecID2.AV_CODEC_ID_SCTE_35 = 98305] = "AV_CODEC_ID_SCTE_35", AVCodecID2[AVCodecID2.AV_CODEC_ID_EPG = 98306] = "AV_CODEC_ID_EPG", AVCodecID2[AVCodecID2.AV_CODEC_ID_BINTEXT = 98307] = "AV_CODEC_ID_BINTEXT", AVCodecID2[AVCodecID2.AV_CODEC_ID_XBIN = 98308] = "AV_CODEC_ID_XBIN", AVCodecID2[AVCodecID2.AV_CODEC_ID_IDF = 98309] = "AV_CODEC_ID_IDF", AVCodecID2[AVCodecID2.AV_CODEC_ID_OTF = 98310] = "AV_CODEC_ID_OTF", AVCodecID2[AVCodecID2.AV_CODEC_ID_SMPTE_KLV = 98311] = "AV_CODEC_ID_SMPTE_KLV", AVCodecID2[AVCodecID2.AV_CODEC_ID_DVD_NAV = 98312] = "AV_CODEC_ID_DVD_NAV", AVCodecID2[AVCodecID2.AV_CODEC_ID_TIMED_ID3 = 98313] = "AV_CODEC_ID_TIMED_ID3", AVCodecID2[AVCodecID2.AV_CODEC_ID_BIN_DATA = 98314] = "AV_CODEC_ID_BIN_DATA", AVCodecID2[AVCodecID2.AV_CODEC_ID_SMPTE_2038 = 98315] = "AV_CODEC_ID_SMPTE_2038", AVCodecID2[AVCodecID2.AV_CODEC_ID_PROBE = 102400] = "AV_CODEC_ID_PROBE", AVCodecID2[AVCodecID2.AV_CODEC_ID_MPEG2TS = 131072] = "AV_CODEC_ID_MPEG2TS", AVCodecID2[AVCodecID2.AV_CODEC_ID_MPEG4SYSTEMS = 131073] = "AV_CODEC_ID_MPEG4SYSTEMS", AVCodecID2[AVCodecID2.AV_CODEC_ID_FFMETADATA = 135168] = "AV_CODEC_ID_FFMETADATA", AVCodecID2[AVCodecID2.AV_CODEC_ID_WRAPPED_AVFRAME = 135169] = "AV_CODEC_ID_WRAPPED_AVFRAME", AVCodecID2[AVCodecID2.AV_CODEC_ID_VNULL = 135170] = "AV_CODEC_ID_VNULL", AVCodecID2[AVCodecID2.AV_CODEC_ID_ANULL = 135171] = "AV_CODEC_ID_ANULL";
      })(AVCodecID || (AVCodecID = {}));
      var AVMediaType;
      !(function(AVMediaType2) {
        AVMediaType2[AVMediaType2.AVMEDIA_TYPE_UNKNOWN = -1] = "AVMEDIA_TYPE_UNKNOWN", AVMediaType2[AVMediaType2.AVMEDIA_TYPE_VIDEO = 0] = "AVMEDIA_TYPE_VIDEO", AVMediaType2[AVMediaType2.AVMEDIA_TYPE_AUDIO = 1] = "AVMEDIA_TYPE_AUDIO", AVMediaType2[AVMediaType2.AVMEDIA_TYPE_DATA = 2] = "AVMEDIA_TYPE_DATA", AVMediaType2[AVMediaType2.AVMEDIA_TYPE_SUBTITLE = 3] = "AVMEDIA_TYPE_SUBTITLE", AVMediaType2[AVMediaType2.AVMEDIA_TYPE_ATTACHMENT = 4] = "AVMEDIA_TYPE_ATTACHMENT", AVMediaType2[AVMediaType2.AVMEDIA_TYPE_NB = 5] = "AVMEDIA_TYPE_NB";
      })(AVMediaType || (AVMediaType = {}));
      var AVPacketSideDataType;
      !(function(AVPacketSideDataType2) {
        AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_UNKNOWN = -1] = "AV_PKT_DATA_UNKNOWN", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_PALETTE = 0] = "AV_PKT_DATA_PALETTE", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_NEW_EXTRADATA = 1] = "AV_PKT_DATA_NEW_EXTRADATA", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_PARAM_CHANGE = 2] = "AV_PKT_DATA_PARAM_CHANGE", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_H263_MB_INFO = 3] = "AV_PKT_DATA_H263_MB_INFO", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_REPLAYGAIN = 4] = "AV_PKT_DATA_REPLAYGAIN", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_DISPLAYMATRIX = 5] = "AV_PKT_DATA_DISPLAYMATRIX", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_STEREO3D = 6] = "AV_PKT_DATA_STEREO3D", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7] = "AV_PKT_DATA_AUDIO_SERVICE_TYPE", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_QUALITY_STATS = 8] = "AV_PKT_DATA_QUALITY_STATS", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_FALLBACK_TRACK = 9] = "AV_PKT_DATA_FALLBACK_TRACK", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_CPB_PROPERTIES = 10] = "AV_PKT_DATA_CPB_PROPERTIES", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_SKIP_SAMPLES = 11] = "AV_PKT_DATA_SKIP_SAMPLES", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_JP_DUALMONO = 12] = "AV_PKT_DATA_JP_DUALMONO", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_STRINGS_METADATA = 13] = "AV_PKT_DATA_STRINGS_METADATA", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_SUBTITLE_POSITION = 14] = "AV_PKT_DATA_SUBTITLE_POSITION", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 15] = "AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_WEBVTT_IDENTIFIER = 16] = "AV_PKT_DATA_WEBVTT_IDENTIFIER", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_WEBVTT_SETTINGS = 17] = "AV_PKT_DATA_WEBVTT_SETTINGS", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_METADATA_UPDATE = 18] = "AV_PKT_DATA_METADATA_UPDATE", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_MPEGTS_STREAM_ID = 19] = "AV_PKT_DATA_MPEGTS_STREAM_ID", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 20] = "AV_PKT_DATA_MASTERING_DISPLAY_METADATA", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_SPHERICAL = 21] = "AV_PKT_DATA_SPHERICAL", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_CONTENT_LIGHT_LEVEL = 22] = "AV_PKT_DATA_CONTENT_LIGHT_LEVEL", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_A53_CC = 23] = "AV_PKT_DATA_A53_CC", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_ENCRYPTION_INIT_INFO = 24] = "AV_PKT_DATA_ENCRYPTION_INIT_INFO", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_ENCRYPTION_INFO = 25] = "AV_PKT_DATA_ENCRYPTION_INFO", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_AFD = 26] = "AV_PKT_DATA_AFD", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_PRFT = 27] = "AV_PKT_DATA_PRFT", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_ICC_PROFILE = 28] = "AV_PKT_DATA_ICC_PROFILE", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_DOVI_CONF = 29] = "AV_PKT_DATA_DOVI_CONF", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_S12M_TIMECODE = 30] = "AV_PKT_DATA_S12M_TIMECODE", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_DYNAMIC_HDR10_PLUS = 31] = "AV_PKT_DATA_DYNAMIC_HDR10_PLUS", AVPacketSideDataType2[AVPacketSideDataType2.AV_PKT_DATA_NB = 32] = "AV_PKT_DATA_NB";
      })(AVPacketSideDataType || (AVPacketSideDataType = {}));
      var AVDisposition;
      !(function(AVDisposition2) {
        AVDisposition2[AVDisposition2.NONE = 0] = "NONE", AVDisposition2[AVDisposition2.DEFAULT = 1] = "DEFAULT", AVDisposition2[AVDisposition2.DUB = 2] = "DUB", AVDisposition2[AVDisposition2.ORIGINAL = 4] = "ORIGINAL", AVDisposition2[AVDisposition2.COMMENT = 8] = "COMMENT", AVDisposition2[AVDisposition2.LYRICS = 16] = "LYRICS", AVDisposition2[AVDisposition2.KARAOKE = 32] = "KARAOKE", AVDisposition2[AVDisposition2.FORCED = 64] = "FORCED", AVDisposition2[AVDisposition2.HEARING_IMPAIRED = 128] = "HEARING_IMPAIRED", AVDisposition2[AVDisposition2.VISUAL_IMPAIRED = 256] = "VISUAL_IMPAIRED", AVDisposition2[AVDisposition2.CLEAN_EFFECTS = 512] = "CLEAN_EFFECTS", AVDisposition2[AVDisposition2.ATTACHED_PIC = 1024] = "ATTACHED_PIC", AVDisposition2[AVDisposition2.TIMED_THUMBNAILS = 2048] = "TIMED_THUMBNAILS", AVDisposition2[AVDisposition2.CAPTIONS = 65536] = "CAPTIONS", AVDisposition2[AVDisposition2.DESCRIPTIONS = 131072] = "DESCRIPTIONS", AVDisposition2[AVDisposition2.METADATA = 262144] = "METADATA", AVDisposition2[AVDisposition2.DEPENDENT = 524288] = "DEPENDENT", AVDisposition2[AVDisposition2.STILL_IMAGE = 1048576] = "STILL_IMAGE";
      })(AVDisposition || (AVDisposition = {}));
      var AVStreamMetadataKey;
      !(function(AVStreamMetadataKey2) {
        AVStreamMetadataKey2.ARTIST = "artist", AVStreamMetadataKey2.COMMENT = "comment", AVStreamMetadataKey2.COPYRIGHT = "copyright", AVStreamMetadataKey2.DATE = "date", AVStreamMetadataKey2.GENRE = "genre", AVStreamMetadataKey2.LANGUAGE = "language", AVStreamMetadataKey2.LANGUAGE_STRING = "languageString", AVStreamMetadataKey2.TITLE = "title", AVStreamMetadataKey2.ALBUM = "album", AVStreamMetadataKey2.TRACK = "track", AVStreamMetadataKey2.ENCODER = "encoder", AVStreamMetadataKey2.TIME_CODE = "timecode", AVStreamMetadataKey2.VENDOR = "vendor", AVStreamMetadataKey2.VENDOR_ID = "vendorId", AVStreamMetadataKey2.POSTER = "poster", AVStreamMetadataKey2.LYRICS = "lyrics", AVStreamMetadataKey2.ALBUM_ARTIST = "albumArtist", AVStreamMetadataKey2.DISC = "disc", AVStreamMetadataKey2.PERFORMER = "performer", AVStreamMetadataKey2.PUBLISHER = "publisher", AVStreamMetadataKey2.COMPOSER = "composer", AVStreamMetadataKey2.COMPILATION = "compilation", AVStreamMetadataKey2.CREATION_TIME = "creationTime", AVStreamMetadataKey2.MODIFICATION_TIME = "modificationTime", AVStreamMetadataKey2.ALBUM_SORT = "albumSort", AVStreamMetadataKey2.ARTIST_SORT = "artistSort", AVStreamMetadataKey2.TITLE_SORT = "titleSort", AVStreamMetadataKey2.GROUPING = "grouping", AVStreamMetadataKey2.DESCRIPTION = "description", AVStreamMetadataKey2.LICENSE = "license", AVStreamMetadataKey2.ISRC = "isrc", AVStreamMetadataKey2.MOOD = "mood", AVStreamMetadataKey2.ELST = "elst", AVStreamMetadataKey2.MATRIX = "matrix", AVStreamMetadataKey2.STYLES = "styles", AVStreamMetadataKey2.MIME = "mime", AVStreamMetadataKey2.HANDLER_NAME = "handlerName";
      })(AVStreamMetadataKey || (AVStreamMetadataKey = {}));
      var AVFormat;
      !(function(AVFormat2) {
        AVFormat2[AVFormat2.UNKNOWN = -1] = "UNKNOWN", AVFormat2[AVFormat2.FLV = 0] = "FLV", AVFormat2[AVFormat2.MOV = 1] = "MOV", AVFormat2[AVFormat2.MP4 = 1] = "MP4", AVFormat2[AVFormat2.M4A = 1] = "M4A", AVFormat2[AVFormat2.MPEGTS = 2] = "MPEGTS", AVFormat2[AVFormat2.MPEGPS = 3] = "MPEGPS", AVFormat2[AVFormat2.OGG = 4] = "OGG", AVFormat2[AVFormat2.IVF = 5] = "IVF", AVFormat2[AVFormat2.RTSP = 6] = "RTSP", AVFormat2[AVFormat2.RTMP = 7] = "RTMP", AVFormat2[AVFormat2.MATROSKA = 8] = "MATROSKA", AVFormat2[AVFormat2.WEBM = 9] = "WEBM", AVFormat2[AVFormat2.AVI = 10] = "AVI", AVFormat2[AVFormat2.H264 = 11] = "H264", AVFormat2[AVFormat2.HEVC = 12] = "HEVC", AVFormat2[AVFormat2.VVC = 13] = "VVC", AVFormat2[AVFormat2.MP3 = 14] = "MP3", AVFormat2[AVFormat2.AAC = 15] = "AAC", AVFormat2[AVFormat2.WAV = 16] = "WAV", AVFormat2[AVFormat2.FLAC = 17] = "FLAC", AVFormat2[AVFormat2.WEBVTT = 18] = "WEBVTT", AVFormat2[AVFormat2.SUBRIP = 19] = "SUBRIP", AVFormat2[AVFormat2.ASS = 20] = "ASS", AVFormat2[AVFormat2.TTML = 21] = "TTML";
      })(AVFormat || (AVFormat = {}));
      var AVSeekFlags;
      !(function(AVSeekFlags2) {
        AVSeekFlags2[AVSeekFlags2.NONE = 0] = "NONE", AVSeekFlags2[AVSeekFlags2.BACKWARD = 1] = "BACKWARD", AVSeekFlags2[AVSeekFlags2.BYTE = 2] = "BYTE", AVSeekFlags2[AVSeekFlags2.ANY = 4] = "ANY", AVSeekFlags2[AVSeekFlags2.FRAME = 8] = "FRAME", AVSeekFlags2[AVSeekFlags2.TIMESTAMP = 16] = "TIMESTAMP";
      })(AVSeekFlags || (AVSeekFlags = {}));
      var IOFlags;
      !(function(IOFlags2) {
        IOFlags2[IOFlags2.NONE = 0] = "NONE", IOFlags2[IOFlags2.SEEKABLE = 1] = "SEEKABLE", IOFlags2[IOFlags2.SLICE = 2] = "SLICE", IOFlags2[IOFlags2.NETWORK = 4] = "NETWORK", IOFlags2[IOFlags2.ABORT = 8] = "ABORT";
      })(IOFlags || (IOFlags = {}));
      var IOType;
      !(function(IOType2) {
        IOType2[IOType2.Fetch = 0] = "Fetch", IOType2[IOType2.File = 1] = "File", IOType2[IOType2.WEBSOCKET = 2] = "WEBSOCKET", IOType2[IOType2.WEBTRANSPORT = 3] = "WEBTRANSPORT", IOType2[IOType2.HLS = 4] = "HLS", IOType2[IOType2.DASH = 5] = "DASH", IOType2[IOType2.RTMP = 6] = "RTMP";
      })(IOType || (IOType = {}));
      var AVSampleFormat;
      !(function(AVSampleFormat2) {
        AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_NONE = -1] = "AV_SAMPLE_FMT_NONE", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_U8 = 0] = "AV_SAMPLE_FMT_U8", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_S16 = 1] = "AV_SAMPLE_FMT_S16", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_S32 = 2] = "AV_SAMPLE_FMT_S32", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_FLT = 3] = "AV_SAMPLE_FMT_FLT", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_DBL = 4] = "AV_SAMPLE_FMT_DBL", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_U8P = 5] = "AV_SAMPLE_FMT_U8P", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_S16P = 6] = "AV_SAMPLE_FMT_S16P", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_S32P = 7] = "AV_SAMPLE_FMT_S32P", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_FLTP = 8] = "AV_SAMPLE_FMT_FLTP", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_DBLP = 9] = "AV_SAMPLE_FMT_DBLP", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_S64 = 10] = "AV_SAMPLE_FMT_S64", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_S64P = 11] = "AV_SAMPLE_FMT_S64P", AVSampleFormat2[AVSampleFormat2.AV_SAMPLE_FMT_NB = 12] = "AV_SAMPLE_FMT_NB";
      })(AVSampleFormat || (AVSampleFormat = {}));
      var AVAudioServiceType;
      !(function(AVAudioServiceType2) {
        AVAudioServiceType2[AVAudioServiceType2.AV_AUDIO_SERVICE_TYPE_MAIN = 0] = "AV_AUDIO_SERVICE_TYPE_MAIN", AVAudioServiceType2[AVAudioServiceType2.AV_AUDIO_SERVICE_TYPE_EFFECTS = 1] = "AV_AUDIO_SERVICE_TYPE_EFFECTS", AVAudioServiceType2[AVAudioServiceType2.AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2] = "AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED", AVAudioServiceType2[AVAudioServiceType2.AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3] = "AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED", AVAudioServiceType2[AVAudioServiceType2.AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4] = "AV_AUDIO_SERVICE_TYPE_DIALOGUE", AVAudioServiceType2[AVAudioServiceType2.AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5] = "AV_AUDIO_SERVICE_TYPE_COMMENTARY", AVAudioServiceType2[AVAudioServiceType2.AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6] = "AV_AUDIO_SERVICE_TYPE_EMERGENCY", AVAudioServiceType2[AVAudioServiceType2.AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7] = "AV_AUDIO_SERVICE_TYPE_VOICE_OVER", AVAudioServiceType2[AVAudioServiceType2.AV_AUDIO_SERVICE_TYPE_KARAOKE = 8] = "AV_AUDIO_SERVICE_TYPE_KARAOKE", AVAudioServiceType2[AVAudioServiceType2.AV_AUDIO_SERVICE_TYPE_NB = 9] = "AV_AUDIO_SERVICE_TYPE_NB";
      })(AVAudioServiceType || (AVAudioServiceType = {}));
      var AVChannel;
      !(function(AVChannel2) {
        AVChannel2[AVChannel2.AV_CHANNEL_NONE = -1] = "AV_CHANNEL_NONE", AVChannel2[AVChannel2.AV_CHANNEL_FRONT_LEFT = 0] = "AV_CHANNEL_FRONT_LEFT", AVChannel2[AVChannel2.AV_CHANNEL_FRONT_RIGHT = 1] = "AV_CHANNEL_FRONT_RIGHT", AVChannel2[AVChannel2.AV_CHANNEL_FRONT_CENTER = 2] = "AV_CHANNEL_FRONT_CENTER", AVChannel2[AVChannel2.AV_CHANNEL_LOW_FREQUENCY = 3] = "AV_CHANNEL_LOW_FREQUENCY", AVChannel2[AVChannel2.AV_CHANNEL_BACK_LEFT = 4] = "AV_CHANNEL_BACK_LEFT", AVChannel2[AVChannel2.AV_CHANNEL_BACK_RIGHT = 5] = "AV_CHANNEL_BACK_RIGHT", AVChannel2[AVChannel2.AV_CHANNEL_FRONT_LEFT_OF_CENTER = 6] = "AV_CHANNEL_FRONT_LEFT_OF_CENTER", AVChannel2[AVChannel2.AV_CHANNEL_FRONT_RIGHT_OF_CENTER = 7] = "AV_CHANNEL_FRONT_RIGHT_OF_CENTER", AVChannel2[AVChannel2.AV_CHANNEL_BACK_CENTER = 8] = "AV_CHANNEL_BACK_CENTER", AVChannel2[AVChannel2.AV_CHANNEL_SIDE_LEFT = 9] = "AV_CHANNEL_SIDE_LEFT", AVChannel2[AVChannel2.AV_CHANNEL_SIDE_RIGHT = 10] = "AV_CHANNEL_SIDE_RIGHT", AVChannel2[AVChannel2.AV_CHANNEL_TOP_CENTER = 11] = "AV_CHANNEL_TOP_CENTER", AVChannel2[AVChannel2.AV_CHANNEL_TOP_FRONT_LEFT = 12] = "AV_CHANNEL_TOP_FRONT_LEFT", AVChannel2[AVChannel2.AV_CHANNEL_TOP_FRONT_CENTER = 13] = "AV_CHANNEL_TOP_FRONT_CENTER", AVChannel2[AVChannel2.AV_CHANNEL_TOP_FRONT_RIGHT = 14] = "AV_CHANNEL_TOP_FRONT_RIGHT", AVChannel2[AVChannel2.AV_CHANNEL_TOP_BACK_LEFT = 15] = "AV_CHANNEL_TOP_BACK_LEFT", AVChannel2[AVChannel2.AV_CHANNEL_TOP_BACK_CENTER = 16] = "AV_CHANNEL_TOP_BACK_CENTER", AVChannel2[AVChannel2.AV_CHANNEL_TOP_BACK_RIGHT = 17] = "AV_CHANNEL_TOP_BACK_RIGHT", AVChannel2[AVChannel2.AV_CHANNEL_STEREO_LEFT = 29] = "AV_CHANNEL_STEREO_LEFT", AVChannel2[AVChannel2.AV_CHANNEL_STEREO_RIGHT = 30] = "AV_CHANNEL_STEREO_RIGHT", AVChannel2[AVChannel2.AV_CHANNEL_WIDE_LEFT = 31] = "AV_CHANNEL_WIDE_LEFT", AVChannel2[AVChannel2.AV_CHANNEL_WIDE_RIGHT = 32] = "AV_CHANNEL_WIDE_RIGHT", AVChannel2[AVChannel2.AV_CHANNEL_SURROUND_DIRECT_LEFT = 33] = "AV_CHANNEL_SURROUND_DIRECT_LEFT", AVChannel2[AVChannel2.AV_CHANNEL_SURROUND_DIRECT_RIGHT = 34] = "AV_CHANNEL_SURROUND_DIRECT_RIGHT", AVChannel2[AVChannel2.AV_CHANNEL_LOW_FREQUENCY_2 = 35] = "AV_CHANNEL_LOW_FREQUENCY_2", AVChannel2[AVChannel2.AV_CHANNEL_TOP_SIDE_LEFT = 36] = "AV_CHANNEL_TOP_SIDE_LEFT", AVChannel2[AVChannel2.AV_CHANNEL_TOP_SIDE_RIGHT = 37] = "AV_CHANNEL_TOP_SIDE_RIGHT", AVChannel2[AVChannel2.AV_CHANNEL_BOTTOM_FRONT_CENTER = 38] = "AV_CHANNEL_BOTTOM_FRONT_CENTER", AVChannel2[AVChannel2.AV_CHANNEL_BOTTOM_FRONT_LEFT = 39] = "AV_CHANNEL_BOTTOM_FRONT_LEFT", AVChannel2[AVChannel2.AV_CHANNEL_BOTTOM_FRONT_RIGHT = 40] = "AV_CHANNEL_BOTTOM_FRONT_RIGHT", AVChannel2[AVChannel2.AV_CHANNEL_UNUSED = 512] = "AV_CHANNEL_UNUSED", AVChannel2[AVChannel2.AV_CHANNEL_UNKNOWN = 768] = "AV_CHANNEL_UNKNOWN", AVChannel2[AVChannel2.AV_CHANNEL_AMBISONIC_BASE = 1024] = "AV_CHANNEL_AMBISONIC_BASE", AVChannel2[AVChannel2.AV_CHANNEL_AMBISONIC_END = 2047] = "AV_CHANNEL_AMBISONIC_END";
      })(AVChannel || (AVChannel = {}));
      var AVChannelOrder;
      !(function(AVChannelOrder2) {
        AVChannelOrder2[AVChannelOrder2.AV_CHANNEL_ORDER_UNSPEC = 0] = "AV_CHANNEL_ORDER_UNSPEC", AVChannelOrder2[AVChannelOrder2.AV_CHANNEL_ORDER_NATIVE = 1] = "AV_CHANNEL_ORDER_NATIVE", AVChannelOrder2[AVChannelOrder2.AV_CHANNEL_ORDER_CUSTOM = 2] = "AV_CHANNEL_ORDER_CUSTOM", AVChannelOrder2[AVChannelOrder2.AV_CHANNEL_ORDER_AMBISONIC = 3] = "AV_CHANNEL_ORDER_AMBISONIC", AVChannelOrder2[AVChannelOrder2.FF_CHANNEL_ORDER_NB = 4] = "FF_CHANNEL_ORDER_NB";
      })(AVChannelOrder || (AVChannelOrder = {}));
      var AVChannelLayout;
      !(function(AVChannelLayout2) {
        AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_FRONT_LEFT = 1] = "AV_CHANNEL_LAYOUT_FRONT_LEFT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_FRONT_RIGHT = 2] = "AV_CHANNEL_LAYOUT_FRONT_RIGHT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_FRONT_CENTER = 4] = "AV_CHANNEL_LAYOUT_FRONT_CENTER", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_LOW_FREQUENCY = 8] = "AV_CHANNEL_LAYOUT_LOW_FREQUENCY", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_BACK_LEFT = 16] = "AV_CHANNEL_LAYOUT_BACK_LEFT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_BACK_RIGHT = 32] = "AV_CHANNEL_LAYOUT_BACK_RIGHT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_FRONT_LEFT_OF_CENTER = 64] = "AV_CHANNEL_LAYOUT_FRONT_LEFT_OF_CENTER", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_FRONT_RIGHT_OF_CENTER = 128] = "AV_CHANNEL_LAYOUT_FRONT_RIGHT_OF_CENTER", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_BACK_CENTER = 256] = "AV_CHANNEL_LAYOUT_BACK_CENTER", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_SIDE_LEFT = 512] = "AV_CHANNEL_LAYOUT_SIDE_LEFT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_SIDE_RIGHT = 1024] = "AV_CHANNEL_LAYOUT_SIDE_RIGHT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_TOP_CENTER = 2048] = "AV_CHANNEL_LAYOUT_TOP_CENTER", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_TOP_FRONT_LEFT = 4096] = "AV_CHANNEL_LAYOUT_TOP_FRONT_LEFT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_TOP_FRONT_CENTER = 8192] = "AV_CHANNEL_LAYOUT_TOP_FRONT_CENTER", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_TOP_FRONT_RIGHT = 16384] = "AV_CHANNEL_LAYOUT_TOP_FRONT_RIGHT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_TOP_BACK_LEFT = 32768] = "AV_CHANNEL_LAYOUT_TOP_BACK_LEFT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_TOP_BACK_CENTER = 65536] = "AV_CHANNEL_LAYOUT_TOP_BACK_CENTER", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_TOP_BACK_RIGHT = 131072] = "AV_CHANNEL_LAYOUT_TOP_BACK_RIGHT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_STEREO_LEFT = 536870912] = "AV_CHANNEL_LAYOUT_STEREO_LEFT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_STEREO_RIGHT = 1073741824] = "AV_CHANNEL_LAYOUT_STEREO_RIGHT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_WIDE_LEFT = 2147483648] = "AV_CHANNEL_LAYOUT_WIDE_LEFT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_WIDE_RIGHT = 4294967296] = "AV_CHANNEL_LAYOUT_WIDE_RIGHT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_SURROUND_DIRECT_LEFT = 8589934592] = "AV_CHANNEL_LAYOUT_SURROUND_DIRECT_LEFT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_SURROUND_DIRECT_RIGHT = 17179869184] = "AV_CHANNEL_LAYOUT_SURROUND_DIRECT_RIGHT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_LOW_FREQUENCY_2 = 34359738368] = "AV_CHANNEL_LAYOUT_LOW_FREQUENCY_2", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_TOP_SIDE_LEFT = 68719476736] = "AV_CHANNEL_LAYOUT_TOP_SIDE_LEFT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_TOP_SIDE_RIGHT = 137438953472] = "AV_CHANNEL_LAYOUT_TOP_SIDE_RIGHT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_BOTTOM_FRONT_CENTER = 274877906944] = "AV_CHANNEL_LAYOUT_BOTTOM_FRONT_CENTER", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_BOTTOM_FRONT_LEFT = 549755813888] = "AV_CHANNEL_LAYOUT_BOTTOM_FRONT_LEFT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_BOTTOM_FRONT_RIGHT = 1099511627776] = "AV_CHANNEL_LAYOUT_BOTTOM_FRONT_RIGHT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_MONO = 4] = "AV_CHANNEL_LAYOUT_MONO", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_STEREO = 3] = "AV_CHANNEL_LAYOUT_STEREO", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_2POINT1 = 11] = "AV_CHANNEL_LAYOUT_2POINT1", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_2_1 = 259] = "AV_CHANNEL_LAYOUT_2_1", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_SURROUND = 7] = "AV_CHANNEL_LAYOUT_SURROUND", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_3POINT1 = 15] = "AV_CHANNEL_LAYOUT_3POINT1", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_4POINT0 = 263] = "AV_CHANNEL_LAYOUT_4POINT0", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_4POINT1 = 271] = "AV_CHANNEL_LAYOUT_4POINT1", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_2_2 = 1539] = "AV_CHANNEL_LAYOUT_2_2", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_QUAD = 51] = "AV_CHANNEL_LAYOUT_QUAD", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_5POINT0 = 1543] = "AV_CHANNEL_LAYOUT_5POINT0", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_5POINT1 = 1551] = "AV_CHANNEL_LAYOUT_5POINT1", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_5POINT0_BACK = 55] = "AV_CHANNEL_LAYOUT_5POINT0_BACK", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_5POINT1_BACK = 63] = "AV_CHANNEL_LAYOUT_5POINT1_BACK", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_6POINT0 = 1799] = "AV_CHANNEL_LAYOUT_6POINT0", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_6POINT0_FRONT = 1731] = "AV_CHANNEL_LAYOUT_6POINT0_FRONT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_HEXAGONAL = 311] = "AV_CHANNEL_LAYOUT_HEXAGONAL", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_3POINT1POINT2 = 20495] = "AV_CHANNEL_LAYOUT_3POINT1POINT2", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_6POINT1 = 1807] = "AV_CHANNEL_LAYOUT_6POINT1", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_6POINT1_BACK = 319] = "AV_CHANNEL_LAYOUT_6POINT1_BACK", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_6POINT1_FRONT = 1739] = "AV_CHANNEL_LAYOUT_6POINT1_FRONT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_7POINT0 = 1591] = "AV_CHANNEL_LAYOUT_7POINT0", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_7POINT0_FRONT = 1735] = "AV_CHANNEL_LAYOUT_7POINT0_FRONT", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_7POINT1 = 1599] = "AV_CHANNEL_LAYOUT_7POINT1", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_7POINT1_WIDE = 1743] = "AV_CHANNEL_LAYOUT_7POINT1_WIDE", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_7POINT1_WIDE_BACK = 255] = "AV_CHANNEL_LAYOUT_7POINT1_WIDE_BACK", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_5POINT1POINT2_BACK = 20543] = "AV_CHANNEL_LAYOUT_5POINT1POINT2_BACK", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_OCTAGONAL = 1847] = "AV_CHANNEL_LAYOUT_OCTAGONAL", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_CUBE = 184371] = "AV_CHANNEL_LAYOUT_CUBE", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_5POINT1POINT4_BACK = 184383] = "AV_CHANNEL_LAYOUT_5POINT1POINT4_BACK", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_7POINT1POINT2 = 22079] = "AV_CHANNEL_LAYOUT_7POINT1POINT2", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_7POINT1POINT4_BACK = 185919] = "AV_CHANNEL_LAYOUT_7POINT1POINT4_BACK", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_7POINT2POINT3 = 34359825983] = "AV_CHANNEL_LAYOUT_7POINT2POINT3", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_9POINT1POINT4_BACK = 186111] = "AV_CHANNEL_LAYOUT_9POINT1POINT4_BACK", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_HEXADECAGONAL = 6442710839] = "AV_CHANNEL_LAYOUT_HEXADECAGONAL", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_STEREO_DOWNMIX = 1610612736] = "AV_CHANNEL_LAYOUT_STEREO_DOWNMIX", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_22POINT2 = 2164663779327] = "AV_CHANNEL_LAYOUT_22POINT2", AVChannelLayout2[AVChannelLayout2.AV_CHANNEL_LAYOUT_7POINT1_TOP_BACK = 20543] = "AV_CHANNEL_LAYOUT_7POINT1_TOP_BACK";
      })(AVChannelLayout || (AVChannelLayout = {}));
      var AVPixelFormatFlags;
      !(function(AVPixelFormatFlags2) {
        AVPixelFormatFlags2[AVPixelFormatFlags2.BIG_ENDIAN = 1] = "BIG_ENDIAN", AVPixelFormatFlags2[AVPixelFormatFlags2.PALETTE = 2] = "PALETTE", AVPixelFormatFlags2[AVPixelFormatFlags2.BIT_STREAM = 4] = "BIT_STREAM", AVPixelFormatFlags2[AVPixelFormatFlags2.PLANER = 16] = "PLANER", AVPixelFormatFlags2[AVPixelFormatFlags2.RGB = 32] = "RGB", AVPixelFormatFlags2[AVPixelFormatFlags2.ALPHA = 128] = "ALPHA", AVPixelFormatFlags2[AVPixelFormatFlags2.BAYER = 256] = "BAYER", AVPixelFormatFlags2[AVPixelFormatFlags2.FLOAT = 512] = "FLOAT";
      })(AVPixelFormatFlags || (AVPixelFormatFlags = {}));
      var AVChromaLocation;
      !(function(AVChromaLocation2) {
        AVChromaLocation2[AVChromaLocation2.AVCHROMA_LOC_UNSPECIFIED = 0] = "AVCHROMA_LOC_UNSPECIFIED", AVChromaLocation2[AVChromaLocation2.AVCHROMA_LOC_LEFT = 1] = "AVCHROMA_LOC_LEFT", AVChromaLocation2[AVChromaLocation2.AVCHROMA_LOC_CENTER = 2] = "AVCHROMA_LOC_CENTER", AVChromaLocation2[AVChromaLocation2.AVCHROMA_LOC_TOPLEFT = 3] = "AVCHROMA_LOC_TOPLEFT", AVChromaLocation2[AVChromaLocation2.AVCHROMA_LOC_TOP = 4] = "AVCHROMA_LOC_TOP", AVChromaLocation2[AVChromaLocation2.AVCHROMA_LOC_BOTTOMLEFT = 5] = "AVCHROMA_LOC_BOTTOMLEFT", AVChromaLocation2[AVChromaLocation2.AVCHROMA_LOC_BOTTOM = 6] = "AVCHROMA_LOC_BOTTOM", AVChromaLocation2[AVChromaLocation2.AVCHROMA_LOC_NB = 7] = "AVCHROMA_LOC_NB";
      })(AVChromaLocation || (AVChromaLocation = {}));
      var AVColorPrimaries;
      !(function(AVColorPrimaries2) {
        AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_RESERVED0 = 0] = "AVCOL_PRI_RESERVED0", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_BT709 = 1] = "AVCOL_PRI_BT709", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_UNSPECIFIED = 2] = "AVCOL_PRI_UNSPECIFIED", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_RESERVED = 3] = "AVCOL_PRI_RESERVED", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_BT470M = 4] = "AVCOL_PRI_BT470M", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_BT470BG = 5] = "AVCOL_PRI_BT470BG", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_SMPTE170M = 6] = "AVCOL_PRI_SMPTE170M", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_SMPTE240M = 7] = "AVCOL_PRI_SMPTE240M", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_FILM = 8] = "AVCOL_PRI_FILM", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_BT2020 = 9] = "AVCOL_PRI_BT2020", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_SMPTE428 = 10] = "AVCOL_PRI_SMPTE428", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_SMPTEST428_1 = 10] = "AVCOL_PRI_SMPTEST428_1", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_SMPTE431 = 11] = "AVCOL_PRI_SMPTE431", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_SMPTE432 = 12] = "AVCOL_PRI_SMPTE432", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_EBU3213 = 22] = "AVCOL_PRI_EBU3213", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_JEDEC_P22 = 22] = "AVCOL_PRI_JEDEC_P22", AVColorPrimaries2[AVColorPrimaries2.AVCOL_PRI_NB = 23] = "AVCOL_PRI_NB";
      })(AVColorPrimaries || (AVColorPrimaries = {}));
      var AVColorRange;
      !(function(AVColorRange2) {
        AVColorRange2[AVColorRange2.AVCOL_RANGE_UNSPECIFIED = 0] = "AVCOL_RANGE_UNSPECIFIED", AVColorRange2[AVColorRange2.AVCOL_RANGE_MPEG = 1] = "AVCOL_RANGE_MPEG", AVColorRange2[AVColorRange2.AVCOL_RANGE_JPEG = 2] = "AVCOL_RANGE_JPEG", AVColorRange2[AVColorRange2.AVCOL_RANGE_NB = 3] = "AVCOL_RANGE_NB";
      })(AVColorRange || (AVColorRange = {}));
      var AVColorSpace;
      !(function(AVColorSpace2) {
        AVColorSpace2[AVColorSpace2.AVCOL_SPC_RGB = 0] = "AVCOL_SPC_RGB", AVColorSpace2[AVColorSpace2.AVCOL_SPC_BT709 = 1] = "AVCOL_SPC_BT709", AVColorSpace2[AVColorSpace2.AVCOL_SPC_UNSPECIFIED = 2] = "AVCOL_SPC_UNSPECIFIED", AVColorSpace2[AVColorSpace2.AVCOL_SPC_RESERVED = 3] = "AVCOL_SPC_RESERVED", AVColorSpace2[AVColorSpace2.AVCOL_SPC_FCC = 4] = "AVCOL_SPC_FCC", AVColorSpace2[AVColorSpace2.AVCOL_SPC_BT470BG = 5] = "AVCOL_SPC_BT470BG", AVColorSpace2[AVColorSpace2.AVCOL_SPC_SMPTE170M = 6] = "AVCOL_SPC_SMPTE170M", AVColorSpace2[AVColorSpace2.AVCOL_SPC_SMPTE240M = 7] = "AVCOL_SPC_SMPTE240M", AVColorSpace2[AVColorSpace2.AVCOL_SPC_YCGCO = 8] = "AVCOL_SPC_YCGCO", AVColorSpace2[AVColorSpace2.AVCOL_SPC_YCOCG = 8] = "AVCOL_SPC_YCOCG", AVColorSpace2[AVColorSpace2.AVCOL_SPC_BT2020_NCL = 9] = "AVCOL_SPC_BT2020_NCL", AVColorSpace2[AVColorSpace2.AVCOL_SPC_BT2020_CL = 10] = "AVCOL_SPC_BT2020_CL", AVColorSpace2[AVColorSpace2.AVCOL_SPC_SMPTE2085 = 11] = "AVCOL_SPC_SMPTE2085", AVColorSpace2[AVColorSpace2.AVCOL_SPC_CHROMA_DERIVED_NCL = 12] = "AVCOL_SPC_CHROMA_DERIVED_NCL", AVColorSpace2[AVColorSpace2.AVCOL_SPC_CHROMA_DERIVED_CL = 13] = "AVCOL_SPC_CHROMA_DERIVED_CL", AVColorSpace2[AVColorSpace2.AVCOL_SPC_ICTCP = 14] = "AVCOL_SPC_ICTCP", AVColorSpace2[AVColorSpace2.AVCOL_SPC_NB = 15] = "AVCOL_SPC_NB";
      })(AVColorSpace || (AVColorSpace = {}));
      var AVColorTransferCharacteristic;
      !(function(AVColorTransferCharacteristic2) {
        AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_RESERVED0 = 0] = "AVCOL_TRC_RESERVED0", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_BT709 = 1] = "AVCOL_TRC_BT709", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_UNSPECIFIED = 2] = "AVCOL_TRC_UNSPECIFIED", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_RESERVED = 3] = "AVCOL_TRC_RESERVED", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_GAMMA22 = 4] = "AVCOL_TRC_GAMMA22", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_GAMMA28 = 5] = "AVCOL_TRC_GAMMA28", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_SMPTE170M = 6] = "AVCOL_TRC_SMPTE170M", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_SMPTE240M = 7] = "AVCOL_TRC_SMPTE240M", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_LINEAR = 8] = "AVCOL_TRC_LINEAR", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_LOG = 9] = "AVCOL_TRC_LOG", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_LOG_SQRT = 10] = "AVCOL_TRC_LOG_SQRT", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_IEC61966_2_4 = 11] = "AVCOL_TRC_IEC61966_2_4", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_BT1361_ECG = 12] = "AVCOL_TRC_BT1361_ECG", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_IEC61966_2_1 = 13] = "AVCOL_TRC_IEC61966_2_1", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_BT2020_10 = 14] = "AVCOL_TRC_BT2020_10", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_BT2020_12 = 15] = "AVCOL_TRC_BT2020_12", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_SMPTE2084 = 16] = "AVCOL_TRC_SMPTE2084", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_SMPTEST2084 = 16] = "AVCOL_TRC_SMPTEST2084", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_SMPTE428 = 17] = "AVCOL_TRC_SMPTE428", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_SMPTEST428_1 = 17] = "AVCOL_TRC_SMPTEST428_1", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_ARIB_STD_B67 = 18] = "AVCOL_TRC_ARIB_STD_B67", AVColorTransferCharacteristic2[AVColorTransferCharacteristic2.AVCOL_TRC_NB = 19] = "AVCOL_TRC_NB";
      })(AVColorTransferCharacteristic || (AVColorTransferCharacteristic = {}));
      var AVFieldOrder;
      !(function(AVFieldOrder2) {
        AVFieldOrder2[AVFieldOrder2.AV_FIELD_UNKNOWN = 0] = "AV_FIELD_UNKNOWN", AVFieldOrder2[AVFieldOrder2.AV_FIELD_PROGRESSIVE = 1] = "AV_FIELD_PROGRESSIVE", AVFieldOrder2[AVFieldOrder2.AV_FIELD_TT = 2] = "AV_FIELD_TT", AVFieldOrder2[AVFieldOrder2.AV_FIELD_BB = 3] = "AV_FIELD_BB", AVFieldOrder2[AVFieldOrder2.AV_FIELD_TB = 4] = "AV_FIELD_TB", AVFieldOrder2[AVFieldOrder2.AV_FIELD_BT = 5] = "AV_FIELD_BT";
      })(AVFieldOrder || (AVFieldOrder = {}));
      var AVPixelFormat;
      !(function(AVPixelFormat2) {
        AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_NONE = -1] = "AV_PIX_FMT_NONE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV420P = 0] = "AV_PIX_FMT_YUV420P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUYV422 = 1] = "AV_PIX_FMT_YUYV422", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB24 = 2] = "AV_PIX_FMT_RGB24", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR24 = 3] = "AV_PIX_FMT_BGR24", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV422P = 4] = "AV_PIX_FMT_YUV422P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV444P = 5] = "AV_PIX_FMT_YUV444P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV410P = 6] = "AV_PIX_FMT_YUV410P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV411P = 7] = "AV_PIX_FMT_YUV411P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY8 = 8] = "AV_PIX_FMT_GRAY8", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_MONOWHITE = 9] = "AV_PIX_FMT_MONOWHITE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_MONOBLACK = 10] = "AV_PIX_FMT_MONOBLACK", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_PAL8 = 11] = "AV_PIX_FMT_PAL8", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVJ420P = 12] = "AV_PIX_FMT_YUVJ420P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVJ422P = 13] = "AV_PIX_FMT_YUVJ422P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVJ444P = 14] = "AV_PIX_FMT_YUVJ444P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_UYVY422 = 15] = "AV_PIX_FMT_UYVY422", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_UYYVYY411 = 16] = "AV_PIX_FMT_UYYVYY411", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR8 = 17] = "AV_PIX_FMT_BGR8", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR4 = 18] = "AV_PIX_FMT_BGR4", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR4_BYTE = 19] = "AV_PIX_FMT_BGR4_BYTE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB8 = 20] = "AV_PIX_FMT_RGB8", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB4 = 21] = "AV_PIX_FMT_RGB4", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB4_BYTE = 22] = "AV_PIX_FMT_RGB4_BYTE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_NV12 = 23] = "AV_PIX_FMT_NV12", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_NV21 = 24] = "AV_PIX_FMT_NV21", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_ARGB = 25] = "AV_PIX_FMT_ARGB", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGBA = 26] = "AV_PIX_FMT_RGBA", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_ABGR = 27] = "AV_PIX_FMT_ABGR", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGRA = 28] = "AV_PIX_FMT_BGRA", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY16BE = 29] = "AV_PIX_FMT_GRAY16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY16LE = 30] = "AV_PIX_FMT_GRAY16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV440P = 31] = "AV_PIX_FMT_YUV440P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVJ440P = 32] = "AV_PIX_FMT_YUVJ440P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA420P = 33] = "AV_PIX_FMT_YUVA420P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB48BE = 34] = "AV_PIX_FMT_RGB48BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB48LE = 35] = "AV_PIX_FMT_RGB48LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB565BE = 36] = "AV_PIX_FMT_RGB565BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB565LE = 37] = "AV_PIX_FMT_RGB565LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB555BE = 38] = "AV_PIX_FMT_RGB555BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB555LE = 39] = "AV_PIX_FMT_RGB555LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR565BE = 40] = "AV_PIX_FMT_BGR565BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR565LE = 41] = "AV_PIX_FMT_BGR565LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR555BE = 42] = "AV_PIX_FMT_BGR555BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR555LE = 43] = "AV_PIX_FMT_BGR555LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_VAAPI = 44] = "AV_PIX_FMT_VAAPI", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV420P16LE = 45] = "AV_PIX_FMT_YUV420P16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV420P16BE = 46] = "AV_PIX_FMT_YUV420P16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV422P16LE = 47] = "AV_PIX_FMT_YUV422P16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV422P16BE = 48] = "AV_PIX_FMT_YUV422P16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV444P16LE = 49] = "AV_PIX_FMT_YUV444P16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV444P16BE = 50] = "AV_PIX_FMT_YUV444P16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_DXVA2_VLD = 51] = "AV_PIX_FMT_DXVA2_VLD", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB444LE = 52] = "AV_PIX_FMT_RGB444LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB444BE = 53] = "AV_PIX_FMT_RGB444BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR444LE = 54] = "AV_PIX_FMT_BGR444LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR444BE = 55] = "AV_PIX_FMT_BGR444BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YA8 = 56] = "AV_PIX_FMT_YA8", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_Y400A = 56] = "AV_PIX_FMT_Y400A", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY8A = 56] = "AV_PIX_FMT_GRAY8A", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR48BE = 57] = "AV_PIX_FMT_BGR48BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR48LE = 58] = "AV_PIX_FMT_BGR48LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV420P9BE = 59] = "AV_PIX_FMT_YUV420P9BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV420P9LE = 60] = "AV_PIX_FMT_YUV420P9LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV420P10BE = 61] = "AV_PIX_FMT_YUV420P10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV420P10LE = 62] = "AV_PIX_FMT_YUV420P10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV422P10BE = 63] = "AV_PIX_FMT_YUV422P10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV422P10LE = 64] = "AV_PIX_FMT_YUV422P10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV444P9BE = 65] = "AV_PIX_FMT_YUV444P9BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV444P9LE = 66] = "AV_PIX_FMT_YUV444P9LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV444P10BE = 67] = "AV_PIX_FMT_YUV444P10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV444P10LE = 68] = "AV_PIX_FMT_YUV444P10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV422P9BE = 69] = "AV_PIX_FMT_YUV422P9BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV422P9LE = 70] = "AV_PIX_FMT_YUV422P9LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRP = 71] = "AV_PIX_FMT_GBRP", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBR24P = 71] = "AV_PIX_FMT_GBR24P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRP9BE = 72] = "AV_PIX_FMT_GBRP9BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRP9LE = 73] = "AV_PIX_FMT_GBRP9LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRP10BE = 74] = "AV_PIX_FMT_GBRP10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRP10LE = 75] = "AV_PIX_FMT_GBRP10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRP16BE = 76] = "AV_PIX_FMT_GBRP16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRP16LE = 77] = "AV_PIX_FMT_GBRP16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA422P = 78] = "AV_PIX_FMT_YUVA422P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA444P = 79] = "AV_PIX_FMT_YUVA444P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA420P9BE = 80] = "AV_PIX_FMT_YUVA420P9BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA420P9LE = 81] = "AV_PIX_FMT_YUVA420P9LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA422P9BE = 82] = "AV_PIX_FMT_YUVA422P9BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA422P9LE = 83] = "AV_PIX_FMT_YUVA422P9LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA444P9BE = 84] = "AV_PIX_FMT_YUVA444P9BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA444P9LE = 85] = "AV_PIX_FMT_YUVA444P9LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA420P10BE = 86] = "AV_PIX_FMT_YUVA420P10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA420P10LE = 87] = "AV_PIX_FMT_YUVA420P10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA422P10BE = 88] = "AV_PIX_FMT_YUVA422P10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA422P10LE = 89] = "AV_PIX_FMT_YUVA422P10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA444P10BE = 90] = "AV_PIX_FMT_YUVA444P10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA444P10LE = 91] = "AV_PIX_FMT_YUVA444P10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA420P16BE = 92] = "AV_PIX_FMT_YUVA420P16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA420P16LE = 93] = "AV_PIX_FMT_YUVA420P16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA422P16BE = 94] = "AV_PIX_FMT_YUVA422P16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA422P16LE = 95] = "AV_PIX_FMT_YUVA422P16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA444P16BE = 96] = "AV_PIX_FMT_YUVA444P16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA444P16LE = 97] = "AV_PIX_FMT_YUVA444P16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_VDPAU = 98] = "AV_PIX_FMT_VDPAU", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_XYZ12LE = 99] = "AV_PIX_FMT_XYZ12LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_XYZ12BE = 100] = "AV_PIX_FMT_XYZ12BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_NV16 = 101] = "AV_PIX_FMT_NV16", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_NV20LE = 102] = "AV_PIX_FMT_NV20LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_NV20BE = 103] = "AV_PIX_FMT_NV20BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGBA64BE = 104] = "AV_PIX_FMT_RGBA64BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGBA64LE = 105] = "AV_PIX_FMT_RGBA64LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGRA64BE = 106] = "AV_PIX_FMT_BGRA64BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGRA64LE = 107] = "AV_PIX_FMT_BGRA64LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YVYU422 = 108] = "AV_PIX_FMT_YVYU422", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YA16BE = 109] = "AV_PIX_FMT_YA16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YA16LE = 110] = "AV_PIX_FMT_YA16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRAP = 111] = "AV_PIX_FMT_GBRAP", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRAP16BE = 112] = "AV_PIX_FMT_GBRAP16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRAP16LE = 113] = "AV_PIX_FMT_GBRAP16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_QSV = 114] = "AV_PIX_FMT_QSV", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_MMAL = 115] = "AV_PIX_FMT_MMAL", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_D3D11VA_VLD = 116] = "AV_PIX_FMT_D3D11VA_VLD", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_CUDA = 117] = "AV_PIX_FMT_CUDA", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_0RGB = 118] = "AV_PIX_FMT_0RGB", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGB0 = 119] = "AV_PIX_FMT_RGB0", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_0BGR = 120] = "AV_PIX_FMT_0BGR", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BGR0 = 121] = "AV_PIX_FMT_BGR0", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV420P12BE = 122] = "AV_PIX_FMT_YUV420P12BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV420P12LE = 123] = "AV_PIX_FMT_YUV420P12LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV420P14BE = 124] = "AV_PIX_FMT_YUV420P14BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV420P14LE = 125] = "AV_PIX_FMT_YUV420P14LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV422P12BE = 126] = "AV_PIX_FMT_YUV422P12BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV422P12LE = 127] = "AV_PIX_FMT_YUV422P12LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV422P14BE = 128] = "AV_PIX_FMT_YUV422P14BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV422P14LE = 129] = "AV_PIX_FMT_YUV422P14LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV444P12BE = 130] = "AV_PIX_FMT_YUV444P12BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV444P12LE = 131] = "AV_PIX_FMT_YUV444P12LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV444P14BE = 132] = "AV_PIX_FMT_YUV444P14BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV444P14LE = 133] = "AV_PIX_FMT_YUV444P14LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRP12BE = 134] = "AV_PIX_FMT_GBRP12BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRP12LE = 135] = "AV_PIX_FMT_GBRP12LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRP14BE = 136] = "AV_PIX_FMT_GBRP14BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRP14LE = 137] = "AV_PIX_FMT_GBRP14LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVJ411P = 138] = "AV_PIX_FMT_YUVJ411P", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_BGGR8 = 139] = "AV_PIX_FMT_BAYER_BGGR8", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_RGGB8 = 140] = "AV_PIX_FMT_BAYER_RGGB8", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_GBRG8 = 141] = "AV_PIX_FMT_BAYER_GBRG8", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_GRBG8 = 142] = "AV_PIX_FMT_BAYER_GRBG8", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_BGGR16LE = 143] = "AV_PIX_FMT_BAYER_BGGR16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_BGGR16BE = 144] = "AV_PIX_FMT_BAYER_BGGR16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_RGGB16LE = 145] = "AV_PIX_FMT_BAYER_RGGB16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_RGGB16BE = 146] = "AV_PIX_FMT_BAYER_RGGB16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_GBRG16LE = 147] = "AV_PIX_FMT_BAYER_GBRG16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_GBRG16BE = 148] = "AV_PIX_FMT_BAYER_GBRG16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_GRBG16LE = 149] = "AV_PIX_FMT_BAYER_GRBG16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_BAYER_GRBG16BE = 150] = "AV_PIX_FMT_BAYER_GRBG16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV440P10LE = 151] = "AV_PIX_FMT_YUV440P10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV440P10BE = 152] = "AV_PIX_FMT_YUV440P10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV440P12LE = 153] = "AV_PIX_FMT_YUV440P12LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUV440P12BE = 154] = "AV_PIX_FMT_YUV440P12BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_AYUV64LE = 155] = "AV_PIX_FMT_AYUV64LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_AYUV64BE = 156] = "AV_PIX_FMT_AYUV64BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_VIDEOTOOLBOX = 157] = "AV_PIX_FMT_VIDEOTOOLBOX", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P010LE = 158] = "AV_PIX_FMT_P010LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P010BE = 159] = "AV_PIX_FMT_P010BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRAP12BE = 160] = "AV_PIX_FMT_GBRAP12BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRAP12LE = 161] = "AV_PIX_FMT_GBRAP12LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRAP10BE = 162] = "AV_PIX_FMT_GBRAP10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRAP10LE = 163] = "AV_PIX_FMT_GBRAP10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_MEDIACODEC = 164] = "AV_PIX_FMT_MEDIACODEC", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY12BE = 165] = "AV_PIX_FMT_GRAY12BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY12LE = 166] = "AV_PIX_FMT_GRAY12LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY10BE = 167] = "AV_PIX_FMT_GRAY10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY10LE = 168] = "AV_PIX_FMT_GRAY10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P016LE = 169] = "AV_PIX_FMT_P016LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P016BE = 170] = "AV_PIX_FMT_P016BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_D3D11 = 171] = "AV_PIX_FMT_D3D11", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY9BE = 172] = "AV_PIX_FMT_GRAY9BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY9LE = 173] = "AV_PIX_FMT_GRAY9LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRPF32BE = 174] = "AV_PIX_FMT_GBRPF32BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRPF32LE = 175] = "AV_PIX_FMT_GBRPF32LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRAPF32BE = 176] = "AV_PIX_FMT_GBRAPF32BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRAPF32LE = 177] = "AV_PIX_FMT_GBRAPF32LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_DRM_PRIME = 178] = "AV_PIX_FMT_DRM_PRIME", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_OPENCL = 179] = "AV_PIX_FMT_OPENCL", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY14BE = 180] = "AV_PIX_FMT_GRAY14BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAY14LE = 181] = "AV_PIX_FMT_GRAY14LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAYF32BE = 182] = "AV_PIX_FMT_GRAYF32BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GRAYF32LE = 183] = "AV_PIX_FMT_GRAYF32LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA422P12BE = 184] = "AV_PIX_FMT_YUVA422P12BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA422P12LE = 185] = "AV_PIX_FMT_YUVA422P12LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA444P12BE = 186] = "AV_PIX_FMT_YUVA444P12BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_YUVA444P12LE = 187] = "AV_PIX_FMT_YUVA444P12LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_NV24 = 188] = "AV_PIX_FMT_NV24", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_NV42 = 189] = "AV_PIX_FMT_NV42", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_VULKAN = 190] = "AV_PIX_FMT_VULKAN", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_Y210BE = 191] = "AV_PIX_FMT_Y210BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_Y210LE = 192] = "AV_PIX_FMT_Y210LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_X2RGB10LE = 193] = "AV_PIX_FMT_X2RGB10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_X2RGB10BE = 194] = "AV_PIX_FMT_X2RGB10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_X2BGR10LE = 195] = "AV_PIX_FMT_X2BGR10LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_X2BGR10BE = 196] = "AV_PIX_FMT_X2BGR10BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P210BE = 197] = "AV_PIX_FMT_P210BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P210LE = 198] = "AV_PIX_FMT_P210LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P410BE = 199] = "AV_PIX_FMT_P410BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P410LE = 200] = "AV_PIX_FMT_P410LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P216BE = 201] = "AV_PIX_FMT_P216BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P216LE = 202] = "AV_PIX_FMT_P216LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P416BE = 203] = "AV_PIX_FMT_P416BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P416LE = 204] = "AV_PIX_FMT_P416LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_VUYA = 205] = "AV_PIX_FMT_VUYA", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGBAF16BE = 206] = "AV_PIX_FMT_RGBAF16BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGBAF16LE = 207] = "AV_PIX_FMT_RGBAF16LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_VUYX = 208] = "AV_PIX_FMT_VUYX", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P012LE = 209] = "AV_PIX_FMT_P012LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P012BE = 210] = "AV_PIX_FMT_P012BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_Y212BE = 211] = "AV_PIX_FMT_Y212BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_Y212LE = 212] = "AV_PIX_FMT_Y212LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_XV30BE = 213] = "AV_PIX_FMT_XV30BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_XV30LE = 214] = "AV_PIX_FMT_XV30LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_XV36BE = 215] = "AV_PIX_FMT_XV36BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_XV36LE = 216] = "AV_PIX_FMT_XV36LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGBF32BE = 217] = "AV_PIX_FMT_RGBF32BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGBF32LE = 218] = "AV_PIX_FMT_RGBF32LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGBAF32BE = 219] = "AV_PIX_FMT_RGBAF32BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_RGBAF32LE = 220] = "AV_PIX_FMT_RGBAF32LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P212BE = 221] = "AV_PIX_FMT_P212BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P212LE = 222] = "AV_PIX_FMT_P212LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P412BE = 223] = "AV_PIX_FMT_P412BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_P412LE = 224] = "AV_PIX_FMT_P412LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRAP14BE = 225] = "AV_PIX_FMT_GBRAP14BE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_GBRAP14LE = 226] = "AV_PIX_FMT_GBRAP14LE", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_D3D12 = 227] = "AV_PIX_FMT_D3D12", AVPixelFormat2[AVPixelFormat2.AV_PIX_FMT_NB = 228] = "AV_PIX_FMT_NB";
      })(AVPixelFormat || (AVPixelFormat = {}));
      var AV1Profile;
      !(function(AV1Profile2) {
        AV1Profile2[AV1Profile2.Main = 0] = "Main", AV1Profile2[AV1Profile2.High = 1] = "High", AV1Profile2[AV1Profile2.Professional = 2] = "Professional";
      })(AV1Profile || (AV1Profile = {}));
      var VP9Profile;
      !(function(VP9Profile2) {
        VP9Profile2[VP9Profile2.Profile0 = 0] = "Profile0", VP9Profile2[VP9Profile2.Profile1 = 1] = "Profile1", VP9Profile2[VP9Profile2.Profile2 = 2] = "Profile2", VP9Profile2[VP9Profile2.Profile3 = 3] = "Profile3";
      })(VP9Profile || (VP9Profile = {}));
      var H264NaluType;
      !(function(H264NaluType2) {
        H264NaluType2[H264NaluType2.kUnspecified = 0] = "kUnspecified", H264NaluType2[H264NaluType2.kSliceNonIDR = 1] = "kSliceNonIDR", H264NaluType2[H264NaluType2.kSliceDPA = 2] = "kSliceDPA", H264NaluType2[H264NaluType2.kSliceDPB = 3] = "kSliceDPB", H264NaluType2[H264NaluType2.kSliceDPC = 4] = "kSliceDPC", H264NaluType2[H264NaluType2.kSliceIDR = 5] = "kSliceIDR", H264NaluType2[H264NaluType2.kSliceSEI = 6] = "kSliceSEI", H264NaluType2[H264NaluType2.kSliceSPS = 7] = "kSliceSPS", H264NaluType2[H264NaluType2.kSlicePPS = 8] = "kSlicePPS", H264NaluType2[H264NaluType2.kSliceAUD = 9] = "kSliceAUD", H264NaluType2[H264NaluType2.kEndOfSequence = 10] = "kEndOfSequence", H264NaluType2[H264NaluType2.kEndOfStream = 11] = "kEndOfStream", H264NaluType2[H264NaluType2.kFiller = 12] = "kFiller", H264NaluType2[H264NaluType2.kSPSExt = 13] = "kSPSExt", H264NaluType2[H264NaluType2.kReserved0 = 14] = "kReserved0";
      })(H264NaluType || (H264NaluType = {}));
      var H264Profile;
      !(function(H264Profile2) {
        H264Profile2[H264Profile2.kBaseline = 66] = "kBaseline", H264Profile2[H264Profile2.kMain = 77] = "kMain", H264Profile2[H264Profile2.kHigh = 100] = "kHigh", H264Profile2[H264Profile2.kConstrained = 66] = "kConstrained", H264Profile2[H264Profile2.kHigh10 = 110] = "kHigh10", H264Profile2[H264Profile2.kHigh422 = 122] = "kHigh422", H264Profile2[H264Profile2.kHigh444 = 244] = "kHigh444";
      })(H264Profile || (H264Profile = {}));
      var H264SliceType;
      !(function(H264SliceType2) {
        H264SliceType2[H264SliceType2.kSliceNone = -1] = "kSliceNone", H264SliceType2[H264SliceType2.kSliceP = 0] = "kSliceP", H264SliceType2[H264SliceType2.kSliceB = 1] = "kSliceB", H264SliceType2[H264SliceType2.kSliceI = 2] = "kSliceI", H264SliceType2[H264SliceType2.kSliceSP = 5] = "kSliceSP", H264SliceType2[H264SliceType2.kSliceSB = 6] = "kSliceSB", H264SliceType2[H264SliceType2.kSliceSI = 7] = "kSliceSI";
      })(H264SliceType || (H264SliceType = {}));
      var BitFormat;
      !(function(BitFormat2) {
        BitFormat2[BitFormat2.AVCC = 1] = "AVCC", BitFormat2[BitFormat2.ANNEXB = 2] = "ANNEXB";
      })(BitFormat || (BitFormat = {}));
      var HEVCNaluType;
      !(function(HEVCNaluType2) {
        HEVCNaluType2[HEVCNaluType2.kSliceTRAIL_N = 0] = "kSliceTRAIL_N", HEVCNaluType2[HEVCNaluType2.kSliceTRAIL_R = 1] = "kSliceTRAIL_R", HEVCNaluType2[HEVCNaluType2.kSliceTSA_N = 2] = "kSliceTSA_N", HEVCNaluType2[HEVCNaluType2.kSliceTSA_R = 3] = "kSliceTSA_R", HEVCNaluType2[HEVCNaluType2.kSliceSTSA_N = 4] = "kSliceSTSA_N", HEVCNaluType2[HEVCNaluType2.kSliceSTSA_R = 5] = "kSliceSTSA_R", HEVCNaluType2[HEVCNaluType2.kSliceRADL_N = 6] = "kSliceRADL_N", HEVCNaluType2[HEVCNaluType2.kSliceRADL_R = 7] = "kSliceRADL_R", HEVCNaluType2[HEVCNaluType2.kSliceRASL_N = 8] = "kSliceRASL_N", HEVCNaluType2[HEVCNaluType2.kSliceRASL_R = 9] = "kSliceRASL_R", HEVCNaluType2[HEVCNaluType2.kSliceBLA_W_LP = 16] = "kSliceBLA_W_LP", HEVCNaluType2[HEVCNaluType2.kSliceBLA_W_RADL = 17] = "kSliceBLA_W_RADL", HEVCNaluType2[HEVCNaluType2.kSliceBLA_N_LP = 18] = "kSliceBLA_N_LP", HEVCNaluType2[HEVCNaluType2.kSliceIDR_W_RADL = 19] = "kSliceIDR_W_RADL", HEVCNaluType2[HEVCNaluType2.kSliceIDR_N_LP = 20] = "kSliceIDR_N_LP", HEVCNaluType2[HEVCNaluType2.kSliceCRA_NUT = 21] = "kSliceCRA_NUT", HEVCNaluType2[HEVCNaluType2.kSliceVPS = 32] = "kSliceVPS", HEVCNaluType2[HEVCNaluType2.kSliceSPS = 33] = "kSliceSPS", HEVCNaluType2[HEVCNaluType2.kSlicePPS = 34] = "kSlicePPS", HEVCNaluType2[HEVCNaluType2.kSliceAUD = 35] = "kSliceAUD", HEVCNaluType2[HEVCNaluType2.kSliceEOS_NUT = 36] = "kSliceEOS_NUT", HEVCNaluType2[HEVCNaluType2.kSliceEOB_NUT = 37] = "kSliceEOB_NUT", HEVCNaluType2[HEVCNaluType2.kSliceFD_NUT = 38] = "kSliceFD_NUT", HEVCNaluType2[HEVCNaluType2.kSliceSEI_PREFIX = 39] = "kSliceSEI_PREFIX", HEVCNaluType2[HEVCNaluType2.kSliceSEI_SUFFIX = 40] = "kSliceSEI_SUFFIX";
      })(HEVCNaluType || (HEVCNaluType = {}));
      var HEVCProfile;
      !(function(HEVCProfile2) {
        HEVCProfile2[HEVCProfile2.Main = 1] = "Main", HEVCProfile2[HEVCProfile2.Main10 = 2] = "Main10", HEVCProfile2[HEVCProfile2.MainStillPicture = 3] = "MainStillPicture", HEVCProfile2[HEVCProfile2.Main444 = 4] = "Main444";
      })(HEVCProfile || (HEVCProfile = {}));
      var HEVCSliceType;
      !(function(HEVCSliceType2) {
        HEVCSliceType2[HEVCSliceType2.kSliceNone = -1] = "kSliceNone", HEVCSliceType2[HEVCSliceType2.kSliceB = 0] = "kSliceB", HEVCSliceType2[HEVCSliceType2.kSliceP = 1] = "kSliceP", HEVCSliceType2[HEVCSliceType2.kSliceI = 2] = "kSliceI";
      })(HEVCSliceType || (HEVCSliceType = {}));
      var VVCNaluType;
      !(function(VVCNaluType2) {
        VVCNaluType2[VVCNaluType2.kTRAIL_NUT = 0] = "kTRAIL_NUT", VVCNaluType2[VVCNaluType2.kSTSA_NUT = 1] = "kSTSA_NUT", VVCNaluType2[VVCNaluType2.kRADL_NUT = 2] = "kRADL_NUT", VVCNaluType2[VVCNaluType2.kRASL_NUT = 3] = "kRASL_NUT", VVCNaluType2[VVCNaluType2.kRSV_VCL_4 = 4] = "kRSV_VCL_4", VVCNaluType2[VVCNaluType2.kRSV_VCL_5 = 5] = "kRSV_VCL_5", VVCNaluType2[VVCNaluType2.kRSV_VCL_6 = 6] = "kRSV_VCL_6", VVCNaluType2[VVCNaluType2.kIDR_W_RADL = 7] = "kIDR_W_RADL", VVCNaluType2[VVCNaluType2.kIDR_N_LP = 8] = "kIDR_N_LP", VVCNaluType2[VVCNaluType2.kCRA_NUT = 9] = "kCRA_NUT", VVCNaluType2[VVCNaluType2.kGDR_NUT = 10] = "kGDR_NUT", VVCNaluType2[VVCNaluType2.kRSV_IRAP_11 = 11] = "kRSV_IRAP_11", VVCNaluType2[VVCNaluType2.kOPI_NUT = 12] = "kOPI_NUT", VVCNaluType2[VVCNaluType2.kDCI_NUT = 13] = "kDCI_NUT", VVCNaluType2[VVCNaluType2.kVPS_NUT = 14] = "kVPS_NUT", VVCNaluType2[VVCNaluType2.kSPS_NUT = 15] = "kSPS_NUT", VVCNaluType2[VVCNaluType2.kPPS_NUT = 16] = "kPPS_NUT", VVCNaluType2[VVCNaluType2.kPREFIX_APS_NUT = 17] = "kPREFIX_APS_NUT", VVCNaluType2[VVCNaluType2.kSUFFIX_APS_NUT = 18] = "kSUFFIX_APS_NUT", VVCNaluType2[VVCNaluType2.kPH_NUT = 19] = "kPH_NUT", VVCNaluType2[VVCNaluType2.kAUD_NUT = 20] = "kAUD_NUT", VVCNaluType2[VVCNaluType2.kEOS_NUT = 21] = "kEOS_NUT", VVCNaluType2[VVCNaluType2.kEOB_NUT = 22] = "kEOB_NUT", VVCNaluType2[VVCNaluType2.kPREFIX_SEI_NUT = 23] = "kPREFIX_SEI_NUT", VVCNaluType2[VVCNaluType2.kSUFFIX_SEI_NUT = 24] = "kSUFFIX_SEI_NUT", VVCNaluType2[VVCNaluType2.kFD_NUT = 25] = "kFD_NUT", VVCNaluType2[VVCNaluType2.kRSV_NVCL_26 = 26] = "kRSV_NVCL_26", VVCNaluType2[VVCNaluType2.kRSV_NVCL_27 = 27] = "kRSV_NVCL_27", VVCNaluType2[VVCNaluType2.kUNSPEC_28 = 28] = "kUNSPEC_28", VVCNaluType2[VVCNaluType2.kUNSPEC_29 = 29] = "kUNSPEC_29", VVCNaluType2[VVCNaluType2.kUNSPEC_30 = 30] = "kUNSPEC_30", VVCNaluType2[VVCNaluType2.kUNSPEC_31 = 31] = "kUNSPEC_31";
      })(VVCNaluType || (VVCNaluType = {}));
      var VVCSliceType;
      !(function(VVCSliceType2) {
        VVCSliceType2[VVCSliceType2.kSliceNone = -1] = "kSliceNone", VVCSliceType2[VVCSliceType2.kSliceB = 0] = "kSliceB", VVCSliceType2[VVCSliceType2.kSliceP = 1] = "kSliceP", VVCSliceType2[VVCSliceType2.kSliceI = 2] = "kSliceI";
      })(VVCSliceType || (VVCSliceType = {}));
      var MP3Profile;
      !(function(MP3Profile2) {
        MP3Profile2[MP3Profile2.Layer1 = 32] = "Layer1", MP3Profile2[MP3Profile2.Layer2 = 33] = "Layer2", MP3Profile2[MP3Profile2.Layer3 = 34] = "Layer3";
      })(MP3Profile || (MP3Profile = {}));
      var AVBufferFlags;
      !(function(AVBufferFlags2) {
        AVBufferFlags2[AVBufferFlags2.NONE = 0] = "NONE", AVBufferFlags2[AVBufferFlags2.READONLY = 1] = "READONLY";
      })(AVBufferFlags || (AVBufferFlags = {}));
      var AVDictFlags;
      !(function(AVDictFlags2) {
        AVDictFlags2[AVDictFlags2.MATCH_CASE = 1] = "MATCH_CASE", AVDictFlags2[AVDictFlags2.IGNORE_SUFFIX = 2] = "IGNORE_SUFFIX", AVDictFlags2[AVDictFlags2.DONT_OVERWRITE = 16] = "DONT_OVERWRITE", AVDictFlags2[AVDictFlags2.APPEND = 32] = "APPEND", AVDictFlags2[AVDictFlags2.MULTIKEY = 64] = "MULTIKEY";
      })(AVDictFlags || (AVDictFlags = {}));
      var AVFrameFlags;
      !(function(AVFrameFlags2) {
        AVFrameFlags2[AVFrameFlags2.AV_FRAME_FLAG_NONE = 0] = "AV_FRAME_FLAG_NONE", AVFrameFlags2[AVFrameFlags2.AV_FRAME_FLAG_CORRUPT = 1] = "AV_FRAME_FLAG_CORRUPT", AVFrameFlags2[AVFrameFlags2.AV_FRAME_FLAG_KEY = 2] = "AV_FRAME_FLAG_KEY", AVFrameFlags2[AVFrameFlags2.AV_FRAME_FLAG_DISCARD = 4] = "AV_FRAME_FLAG_DISCARD", AVFrameFlags2[AVFrameFlags2.AV_FRAME_FLAG_INTERLACED = 8] = "AV_FRAME_FLAG_INTERLACED", AVFrameFlags2[AVFrameFlags2.AV_FRAME_FLAG_TOP_FIELD_FIRST = 16] = "AV_FRAME_FLAG_TOP_FIELD_FIRST";
      })(AVFrameFlags || (AVFrameFlags = {}));
      var FFDecodeError;
      !(function(FFDecodeError2) {
        FFDecodeError2[FFDecodeError2.NONE = 0] = "NONE", FFDecodeError2[FFDecodeError2.INVALID_BITSTREAM = 1] = "INVALID_BITSTREAM", FFDecodeError2[FFDecodeError2.MISSING_REFERENCE = 2] = "MISSING_REFERENCE", FFDecodeError2[FFDecodeError2.CONCEALMENT_ACTIVE = 4] = "CONCEALMENT_ACTIVE", FFDecodeError2[FFDecodeError2.DECODE_SLICES = 8] = "DECODE_SLICES";
      })(FFDecodeError || (FFDecodeError = {}));
      var AVPictureType;
      !(function(AVPictureType2) {
        AVPictureType2[AVPictureType2.AV_PICTURE_TYPE_NONE = 0] = "AV_PICTURE_TYPE_NONE", AVPictureType2[AVPictureType2.AV_PICTURE_TYPE_I = 1] = "AV_PICTURE_TYPE_I", AVPictureType2[AVPictureType2.AV_PICTURE_TYPE_P = 2] = "AV_PICTURE_TYPE_P", AVPictureType2[AVPictureType2.AV_PICTURE_TYPE_B = 3] = "AV_PICTURE_TYPE_B", AVPictureType2[AVPictureType2.AV_PICTURE_TYPE_S = 4] = "AV_PICTURE_TYPE_S", AVPictureType2[AVPictureType2.AV_PICTURE_TYPE_SI = 5] = "AV_PICTURE_TYPE_SI", AVPictureType2[AVPictureType2.AV_PICTURE_TYPE_SP = 6] = "AV_PICTURE_TYPE_SP", AVPictureType2[AVPictureType2.AV_PICTURE_TYPE_BI = 7] = "AV_PICTURE_TYPE_BI";
      })(AVPictureType || (AVPictureType = {}));
      var AVFrameSideDataType;
      !(function(AVFrameSideDataType2) {
        AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_PANSCAN = 0] = "AV_FRAME_DATA_PANSCAN", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_A53_CC = 1] = "AV_FRAME_DATA_A53_CC", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_STEREO3D = 2] = "AV_FRAME_DATA_STEREO3D", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_MATRIXENCODING = 3] = "AV_FRAME_DATA_MATRIXENCODING", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_DOWNMIX_INFO = 4] = "AV_FRAME_DATA_DOWNMIX_INFO", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_REPLAYGAIN = 5] = "AV_FRAME_DATA_REPLAYGAIN", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_DISPLAYMATRIX = 6] = "AV_FRAME_DATA_DISPLAYMATRIX", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_AFD = 7] = "AV_FRAME_DATA_AFD", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_MOTION_VECTORS = 8] = "AV_FRAME_DATA_MOTION_VECTORS", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_SKIP_SAMPLES = 9] = "AV_FRAME_DATA_SKIP_SAMPLES", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10] = "AV_FRAME_DATA_AUDIO_SERVICE_TYPE", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11] = "AV_FRAME_DATA_MASTERING_DISPLAY_METADATA", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_GOP_TIMECODE = 12] = "AV_FRAME_DATA_GOP_TIMECODE", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_SPHERICAL = 13] = "AV_FRAME_DATA_SPHERICAL", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14] = "AV_FRAME_DATA_CONTENT_LIGHT_LEVEL", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_ICC_PROFILE = 15] = "AV_FRAME_DATA_ICC_PROFILE", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_S12M_TIMECODE = 16] = "AV_FRAME_DATA_S12M_TIMECODE", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 17] = "AV_FRAME_DATA_DYNAMIC_HDR_PLUS", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_REGIONS_OF_INTEREST = 18] = "AV_FRAME_DATA_REGIONS_OF_INTEREST", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_VIDEO_ENC_PARAMS = 19] = "AV_FRAME_DATA_VIDEO_ENC_PARAMS", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_SEI_UNREGISTERED = 20] = "AV_FRAME_DATA_SEI_UNREGISTERED", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_FILM_GRAIN_PARAMS = 21] = "AV_FRAME_DATA_FILM_GRAIN_PARAMS", AVFrameSideDataType2[AVFrameSideDataType2.AV_FRAME_DATA_DETECTION_BBOXES = 22] = "AV_FRAME_DATA_DETECTION_BBOXES";
      })(AVFrameSideDataType || (AVFrameSideDataType = {}));
      var AVPacketType;
      !(function(AVPacketType2) {
        AVPacketType2[AVPacketType2.AUDIO = 0] = "AUDIO", AVPacketType2[AVPacketType2.VIDEO = 1] = "VIDEO";
      })(AVPacketType || (AVPacketType = {}));
      var AVPacketFlags;
      !(function(AVPacketFlags2) {
        AVPacketFlags2[AVPacketFlags2.AV_PKT_FLAG_KEY = 1] = "AV_PKT_FLAG_KEY", AVPacketFlags2[AVPacketFlags2.AV_PKT_FLAG_CORRUPT = 2] = "AV_PKT_FLAG_CORRUPT", AVPacketFlags2[AVPacketFlags2.AV_PKT_FLAG_DISCARD = 4] = "AV_PKT_FLAG_DISCARD", AVPacketFlags2[AVPacketFlags2.AV_PKT_FLAG_TRUSTED = 8] = "AV_PKT_FLAG_TRUSTED", AVPacketFlags2[AVPacketFlags2.AV_PKT_FLAG_DISPOSABLE = 16] = "AV_PKT_FLAG_DISPOSABLE", AVPacketFlags2[AVPacketFlags2.AV_PKT_FLAG_END = 32] = "AV_PKT_FLAG_END";
      })(AVPacketFlags || (AVPacketFlags = {}));
      var AVSubtitleType;
      !(function(AVSubtitleType2) {
        AVSubtitleType2[AVSubtitleType2.SUBTITLE_NONE = 0] = "SUBTITLE_NONE", AVSubtitleType2[AVSubtitleType2.SUBTITLE_TEXT = 1] = "SUBTITLE_TEXT", AVSubtitleType2[AVSubtitleType2.SUBTITLE_WEBVTT = 2] = "SUBTITLE_WEBVTT", AVSubtitleType2[AVSubtitleType2.SUBTITLE_ASS = 3] = "SUBTITLE_ASS";
      })(AVSubtitleType || (AVSubtitleType = {}));
      var IOError;
      !(function(IOError2) {
        IOError2[IOError2.END = -1048576] = "END", IOError2[IOError2.AGAIN = -1048575] = "AGAIN", IOError2[IOError2.INVALID_OPERATION = -1048574] = "INVALID_OPERATION", IOError2[IOError2.NETWORK_ERROR = -1048573] = "NETWORK_ERROR";
      })(IOError || (IOError = {}));
      var RenderMode;
      !(function(RenderMode2) {
        RenderMode2[RenderMode2.FIT = 0] = "FIT", RenderMode2[RenderMode2.FILL = 1] = "FILL";
      })(RenderMode || (RenderMode = {}));
      var AVDiscard;
      !(function(AVDiscard2) {
        AVDiscard2[AVDiscard2.AVDISCARD_NONE = -16] = "AVDISCARD_NONE", AVDiscard2[AVDiscard2.AVDISCARD_DEFAULT = 0] = "AVDISCARD_DEFAULT", AVDiscard2[AVDiscard2.AVDISCARD_NONREF = 8] = "AVDISCARD_NONREF", AVDiscard2[AVDiscard2.AVDISCARD_BIDIR = 16] = "AVDISCARD_BIDIR", AVDiscard2[AVDiscard2.AVDISCARD_NONINTRA = 24] = "AVDISCARD_NONINTRA", AVDiscard2[AVDiscard2.AVDISCARD_NONKEY = 32] = "AVDISCARD_NONKEY", AVDiscard2[AVDiscard2.AVDISCARD_ALL = 48] = "AVDISCARD_ALL";
      })(AVDiscard || (AVDiscard = {}));
      var AVPlayerStatus;
      !(function(AVPlayerStatus2) {
        AVPlayerStatus2[AVPlayerStatus2.STOPPED = 0] = "STOPPED", AVPlayerStatus2[AVPlayerStatus2.DESTROYING = 1] = "DESTROYING", AVPlayerStatus2[AVPlayerStatus2.DESTROYED = 2] = "DESTROYED", AVPlayerStatus2[AVPlayerStatus2.LOADING = 3] = "LOADING", AVPlayerStatus2[AVPlayerStatus2.LOADED = 4] = "LOADED", AVPlayerStatus2[AVPlayerStatus2.PLAYING = 5] = "PLAYING", AVPlayerStatus2[AVPlayerStatus2.PLAYED = 6] = "PLAYED", AVPlayerStatus2[AVPlayerStatus2.PAUSED = 7] = "PAUSED", AVPlayerStatus2[AVPlayerStatus2.SEEKING = 8] = "SEEKING", AVPlayerStatus2[AVPlayerStatus2.CHANGING = 9] = "CHANGING";
      })(AVPlayerStatus || (AVPlayerStatus = {}));
      var AVPlayerProgress;
      !(function(AVPlayerProgress2) {
        AVPlayerProgress2[AVPlayerProgress2.OPEN_FILE = 0] = "OPEN_FILE", AVPlayerProgress2[AVPlayerProgress2.ANALYZE_FILE = 1] = "ANALYZE_FILE", AVPlayerProgress2[AVPlayerProgress2.LOAD_AUDIO_DECODER = 2] = "LOAD_AUDIO_DECODER", AVPlayerProgress2[AVPlayerProgress2.LOAD_VIDEO_DECODER = 3] = "LOAD_VIDEO_DECODER";
      })(AVPlayerProgress || (AVPlayerProgress = {}));
      var IOLoaderStatus;
      !(function(IOLoaderStatus2) {
        IOLoaderStatus2[IOLoaderStatus2.IDLE = 0] = "IDLE", IOLoaderStatus2[IOLoaderStatus2.CONNECTING = 1] = "CONNECTING", IOLoaderStatus2[IOLoaderStatus2.BUFFERING = 2] = "BUFFERING", IOLoaderStatus2[IOLoaderStatus2.ERROR = 3] = "ERROR", IOLoaderStatus2[IOLoaderStatus2.COMPLETE = 4] = "COMPLETE";
      })(IOLoaderStatus || (IOLoaderStatus = {}));
      var eventEmitter = { exports: {} };
      var d = { exports: {} };
      var is$4;
      var hasRequiredIs$4;
      function requireIs$4() {
        if (hasRequiredIs$4) return is$4;
        hasRequiredIs$4 = 1;
        var _undefined = void 0;
        is$4 = function(value) {
          return value !== _undefined && value !== null;
        };
        return is$4;
      }
      var is$3;
      var hasRequiredIs$3;
      function requireIs$3() {
        if (hasRequiredIs$3) return is$3;
        hasRequiredIs$3 = 1;
        var isValue2 = requireIs$4();
        var possibleTypes = {
          "object": true,
          "function": true,
          "undefined": true
          /* document.all */
        };
        is$3 = function(value) {
          if (!isValue2(value)) return false;
          return hasOwnProperty.call(possibleTypes, typeof value);
        };
        return is$3;
      }
      var is$2;
      var hasRequiredIs$2;
      function requireIs$2() {
        if (hasRequiredIs$2) return is$2;
        hasRequiredIs$2 = 1;
        var isObject = requireIs$3();
        is$2 = function(value) {
          if (!isObject(value)) return false;
          try {
            if (!value.constructor) return false;
            return value.constructor.prototype === value;
          } catch (error) {
            return false;
          }
        };
        return is$2;
      }
      var is$1;
      var hasRequiredIs$1;
      function requireIs$1() {
        if (hasRequiredIs$1) return is$1;
        hasRequiredIs$1 = 1;
        var isPrototype = requireIs$2();
        is$1 = function(value) {
          if (typeof value !== "function") return false;
          if (!hasOwnProperty.call(value, "length")) return false;
          try {
            if (typeof value.length !== "number") return false;
            if (typeof value.call !== "function") return false;
            if (typeof value.apply !== "function") return false;
          } catch (error) {
            return false;
          }
          return !isPrototype(value);
        };
        return is$1;
      }
      var is;
      var hasRequiredIs;
      function requireIs() {
        if (hasRequiredIs) return is;
        hasRequiredIs = 1;
        var isFunction = requireIs$1();
        var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;
        is = function(value) {
          if (!isFunction(value)) return false;
          if (classRe.test(functionToString.call(value))) return false;
          return true;
        };
        return is;
      }
      var isImplemented$2;
      var hasRequiredIsImplemented$2;
      function requireIsImplemented$2() {
        if (hasRequiredIsImplemented$2) return isImplemented$2;
        hasRequiredIsImplemented$2 = 1;
        isImplemented$2 = function() {
          var assign2 = Object.assign, obj;
          if (typeof assign2 !== "function") return false;
          obj = { foo: "raz" };
          assign2(obj, { bar: "dwa" }, { trzy: "trzy" });
          return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
        };
        return isImplemented$2;
      }
      var isImplemented$1;
      var hasRequiredIsImplemented$1;
      function requireIsImplemented$1() {
        if (hasRequiredIsImplemented$1) return isImplemented$1;
        hasRequiredIsImplemented$1 = 1;
        isImplemented$1 = function() {
          try {
            Object.keys("primitive");
            return true;
          } catch (e) {
            return false;
          }
        };
        return isImplemented$1;
      }
      var noop;
      var hasRequiredNoop;
      function requireNoop() {
        if (hasRequiredNoop) return noop;
        hasRequiredNoop = 1;
        noop = function() {
        };
        return noop;
      }
      var isValue;
      var hasRequiredIsValue;
      function requireIsValue() {
        if (hasRequiredIsValue) return isValue;
        hasRequiredIsValue = 1;
        var _undefined = requireNoop()();
        isValue = function(val) {
          return val !== _undefined && val !== null;
        };
        return isValue;
      }
      var shim$2;
      var hasRequiredShim$2;
      function requireShim$2() {
        if (hasRequiredShim$2) return shim$2;
        hasRequiredShim$2 = 1;
        var isValue2 = requireIsValue();
        var keys2 = Object.keys;
        shim$2 = function(object) {
          return keys2(isValue2(object) ? Object(object) : object);
        };
        return shim$2;
      }
      var keys;
      var hasRequiredKeys;
      function requireKeys() {
        if (hasRequiredKeys) return keys;
        hasRequiredKeys = 1;
        keys = requireIsImplemented$1()() ? Object.keys : requireShim$2();
        return keys;
      }
      var validValue;
      var hasRequiredValidValue;
      function requireValidValue() {
        if (hasRequiredValidValue) return validValue;
        hasRequiredValidValue = 1;
        var isValue2 = requireIsValue();
        validValue = function(value) {
          if (!isValue2(value)) throw new TypeError("Cannot use null or undefined");
          return value;
        };
        return validValue;
      }
      var shim$1;
      var hasRequiredShim$1;
      function requireShim$1() {
        if (hasRequiredShim$1) return shim$1;
        hasRequiredShim$1 = 1;
        var keys2 = requireKeys(), value = requireValidValue(), max = Math.max;
        shim$1 = function(dest, src) {
          var error, i, length = max(arguments.length, 2), assign2;
          dest = Object(value(dest));
          assign2 = function(key) {
            try {
              dest[key] = src[key];
            } catch (e) {
              if (!error) error = e;
            }
          };
          for (i = 1; i < length; ++i) {
            src = arguments[i];
            keys2(src).forEach(assign2);
          }
          if (error !== void 0) throw error;
          return dest;
        };
        return shim$1;
      }
      var assign;
      var hasRequiredAssign;
      function requireAssign() {
        if (hasRequiredAssign) return assign;
        hasRequiredAssign = 1;
        assign = requireIsImplemented$2()() ? Object.assign : requireShim$1();
        return assign;
      }
      var normalizeOptions;
      var hasRequiredNormalizeOptions;
      function requireNormalizeOptions() {
        if (hasRequiredNormalizeOptions) return normalizeOptions;
        hasRequiredNormalizeOptions = 1;
        var isValue2 = requireIsValue();
        var forEach = Array.prototype.forEach, create = Object.create;
        var process = function(src, obj) {
          var key;
          for (key in src) obj[key] = src[key];
        };
        normalizeOptions = function(opts1) {
          var result = create(null);
          forEach.call(arguments, function(options) {
            if (!isValue2(options)) return;
            process(Object(options), result);
          });
          return result;
        };
        return normalizeOptions;
      }
      var isImplemented;
      var hasRequiredIsImplemented;
      function requireIsImplemented() {
        if (hasRequiredIsImplemented) return isImplemented;
        hasRequiredIsImplemented = 1;
        var str = "razdwatrzy";
        isImplemented = function() {
          if (typeof str.contains !== "function") return false;
          return str.contains("dwa") === true && str.contains("foo") === false;
        };
        return isImplemented;
      }
      var shim;
      var hasRequiredShim;
      function requireShim() {
        if (hasRequiredShim) return shim;
        hasRequiredShim = 1;
        var indexOf = String.prototype.indexOf;
        shim = function(searchString) {
          return indexOf.call(this, searchString, arguments[1]) > -1;
        };
        return shim;
      }
      var contains;
      var hasRequiredContains;
      function requireContains() {
        if (hasRequiredContains) return contains;
        hasRequiredContains = 1;
        contains = requireIsImplemented()() ? String.prototype.contains : requireShim();
        return contains;
      }
      var hasRequiredD;
      function requireD() {
        if (hasRequiredD) return d.exports;
        hasRequiredD = 1;
        var isValue2 = requireIs$4(), isPlainFunction = requireIs(), assign2 = requireAssign(), normalizeOpts = requireNormalizeOptions(), contains2 = requireContains();
        var d$1 = d.exports = function(dscr, value) {
          var c, e, w, options, desc;
          if (arguments.length < 2 || typeof dscr !== "string") {
            options = value;
            value = dscr;
            dscr = null;
          } else {
            options = arguments[2];
          }
          if (isValue2(dscr)) {
            c = contains2.call(dscr, "c");
            e = contains2.call(dscr, "e");
            w = contains2.call(dscr, "w");
          } else {
            c = w = true;
            e = false;
          }
          desc = { value, configurable: c, enumerable: e, writable: w };
          return !options ? desc : assign2(normalizeOpts(options), desc);
        };
        d$1.gs = function(dscr, get2, set) {
          var c, e, options, desc;
          if (typeof dscr !== "string") {
            options = set;
            set = get2;
            get2 = dscr;
            dscr = null;
          } else {
            options = arguments[3];
          }
          if (!isValue2(get2)) {
            get2 = void 0;
          } else if (!isPlainFunction(get2)) {
            options = get2;
            get2 = set = void 0;
          } else if (!isValue2(set)) {
            set = void 0;
          } else if (!isPlainFunction(set)) {
            options = set;
            set = void 0;
          }
          if (isValue2(dscr)) {
            c = contains2.call(dscr, "c");
            e = contains2.call(dscr, "e");
          } else {
            c = true;
            e = false;
          }
          desc = { get: get2, set, configurable: c, enumerable: e };
          return !options ? desc : assign2(normalizeOpts(options), desc);
        };
        return d.exports;
      }
      var validCallable;
      var hasRequiredValidCallable;
      function requireValidCallable() {
        if (hasRequiredValidCallable) return validCallable;
        hasRequiredValidCallable = 1;
        validCallable = function(fn) {
          if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
          return fn;
        };
        return validCallable;
      }
      var hasRequiredEventEmitter;
      function requireEventEmitter() {
        if (hasRequiredEventEmitter) return eventEmitter.exports;
        hasRequiredEventEmitter = 1;
        (function(module, exports) {
          var d2 = requireD(), callable = requireValidCallable(), apply = Function.prototype.apply, call = Function.prototype.call, create = Object.create, defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, hasOwnProperty2 = Object.prototype.hasOwnProperty, descriptor = { configurable: true, enumerable: false, writable: true }, on, once, off, emit, methods, descriptors, base;
          on = function(type, listener) {
            var data;
            callable(listener);
            if (!hasOwnProperty2.call(this, "__ee__")) {
              data = descriptor.value = create(null);
              defineProperty(this, "__ee__", descriptor);
              descriptor.value = null;
            } else {
              data = this.__ee__;
            }
            if (!data[type]) data[type] = listener;
            else if (typeof data[type] === "object") data[type].push(listener);
            else data[type] = [data[type], listener];
            return this;
          };
          once = function(type, listener) {
            var once2, self;
            callable(listener);
            self = this;
            on.call(this, type, once2 = function() {
              off.call(self, type, once2);
              apply.call(listener, this, arguments);
            });
            once2.__eeOnceListener__ = listener;
            return this;
          };
          off = function(type, listener) {
            var data, listeners, candidate, i;
            callable(listener);
            if (!hasOwnProperty2.call(this, "__ee__")) return this;
            data = this.__ee__;
            if (!data[type]) return this;
            listeners = data[type];
            if (typeof listeners === "object") {
              for (i = 0; candidate = listeners[i]; ++i) {
                if (candidate === listener || candidate.__eeOnceListener__ === listener) {
                  if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
                  else listeners.splice(i, 1);
                }
              }
            } else {
              if (listeners === listener || listeners.__eeOnceListener__ === listener) {
                delete data[type];
              }
            }
            return this;
          };
          emit = function(type) {
            var i, l, listener, listeners, args;
            if (!hasOwnProperty2.call(this, "__ee__")) return;
            listeners = this.__ee__[type];
            if (!listeners) return;
            if (typeof listeners === "object") {
              l = arguments.length;
              args = new Array(l - 1);
              for (i = 1; i < l; ++i) args[i - 1] = arguments[i];
              listeners = listeners.slice();
              for (i = 0; listener = listeners[i]; ++i) {
                apply.call(listener, this, args);
              }
            } else {
              switch (arguments.length) {
                case 1:
                  call.call(listeners, this);
                  break;
                case 2:
                  call.call(listeners, this, arguments[1]);
                  break;
                case 3:
                  call.call(listeners, this, arguments[1], arguments[2]);
                  break;
                default:
                  l = arguments.length;
                  args = new Array(l - 1);
                  for (i = 1; i < l; ++i) {
                    args[i - 1] = arguments[i];
                  }
                  apply.call(listeners, this, args);
              }
            }
          };
          methods = {
            on,
            once,
            off,
            emit
          };
          descriptors = {
            on: d2(on),
            once: d2(once),
            off: d2(off),
            emit: d2(emit)
          };
          base = defineProperties({}, descriptors);
          module.exports = exports = function(o) {
            return o == null ? create(base) : defineProperties(Object(o), descriptors);
          };
          exports.methods = methods;
        })(eventEmitter, eventEmitter.exports);
        return eventEmitter.exports;
      }
      var eventEmitterExports = requireEventEmitter();
      const ee = /* @__PURE__ */ getDefaultExportFromCjs(eventEmitterExports);
      const dependencies = { "@cbingbing/demuxer": "^2.4.1", "@iconify/vue": "^5.0.0", "@libmedia/avcodec": "^0.8.1", "@libmedia/avformat": "^0.8.1", "@libmedia/avnetwork": "^0.8.1", "@libmedia/avplayer": "^0.8.2", "@libmedia/avutil": "^0.8.1", "@libmedia/common": "^1.4.0", "@material-symbols/svg-400": "^0.28.2", "@tailwindcss/vite": "^4.1.7", "@types/event-emitter": "^0.3.5", "@types/eventemitter3": "^2.0.4", "@vueuse/core": "^12.7.0", "big-integer": "^1.6.52", "blueimp-md5": "^2.19.0", "dayjs": "^1.11.13", "event-emitter": "^0.3.5", "eventemitter3": "^5.0.1", "glob-to-regexp": "^0.4.1", "hls.js": "^1.5.20", "iconify-icon": "^3.0.0", "localforage": "^1.10.0", "lodash": "^4.17.21", "m3u8-parser": "^7.2.0", "photoswipe": "^5.4.4", "tailwindcss": "^4.1.7", "vue": "^3.5.13" };
      const pkg = {
        dependencies
      };
      async function loadESM({ pkgName, version, path, varName }) {
        if (!version) {
          if (pkgName in pkg.dependencies) {
            version = pkg.dependencies[pkgName];
          } else {
            version = "latest";
          }
        }
        const importScript = `
      import ${varName} from "${CDN_BASE_URL}/npm/${pkgName}@${version}/${path}";
      window.${varName} = ${varName};
  `;
        const blob = new Blob([importScript], { type: "text/javascript" });
        const scriptURL = URL.createObjectURL(blob);
        return new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.type = "module";
          script.src = scriptURL;
          script.onload = () => {
            const checkModule = () => {
              const unsafeWindowVar = _unsafeWindow[varName];
              if (unsafeWindowVar) {
                resolve(unsafeWindowVar);
                URL.revokeObjectURL(scriptURL);
              } else {
                setTimeout(checkModule, 50);
              }
            };
            checkModule();
          };
          script.onerror = (err) => {
            URL.revokeObjectURL(scriptURL);
            reject(new Error(`加载 ${pkgName} 模块失败: ${err}`));
          };
          document.head.appendChild(script);
        });
      }
      function usePlayerCoreState() {
        const currentTime = shallowRef(0);
        const duration2 = shallowRef(0);
        const paused = shallowRef(true);
        const playbackRate = shallowRef(1);
        const volume = shallowRef(100);
        const muted = shallowRef(false);
        const isLoading = shallowRef(true);
        const autoPlay = shallowRef(true);
        const canplay = shallowRef(false);
        const loadError = shallowRef(void 0);
        const loaded = shallowRef(false);
        const videoWidth = shallowRef(0);
        const videoHeight = shallowRef(0);
        const isSuspended = shallowRef(false);
        return {
          currentTime,
          duration: duration2,
          paused,
          playbackRate,
          volume,
          muted,
          isLoading,
          loaded,
          autoPlay,
          canplay,
          loadError,
          videoWidth,
          videoHeight,
          isSuspended,
          reset: () => {
            currentTime.value = 0;
            duration2.value = 0;
            paused.value = true;
            playbackRate.value = 1;
            volume.value = 100;
            muted.value = false;
            autoPlay.value = true;
            canplay.value = false;
            isLoading.value = true;
            loaded.value = false;
            loadError.value = void 0;
            videoWidth.value = 0;
            videoHeight.value = 0;
            isSuspended.value = false;
          }
        };
      }
      const CDN_URL_WASM = `${CDN_BASE_URL}/gh/cbingb666/libmedia@latest/dist`;
      const DEFAULT_OPTIONS = {
        /** 是否为直播 */
        isLive: false,
        /** 是否启用硬件加速 */
        enableHardware: true,
        /** 是否启用 WebCodecs */
        enableWebCodecs: true,
        /** 是否启用 WebGPU */
        enableWebGPU: true,
        /** 是否启用 worker */
        enableWorker: true,
        /** 缓冲时间 */
        preLoadTime: 60
      };
      const PICK_STATS_KEYS = [
        /** 音频编码器 */
        "audiocodec",
        /** 视频编码器 */
        "videocodec",
        /** 音频当前时间 */
        "audioCurrentTime",
        /** 视频当前时间 */
        "videoCurrentTime",
        /** 宽度 */
        "width",
        /** 高度 */
        "height",
        /** 通道 */
        "channels",
        /** 采样率 */
        "sampleRate",
        /** 带宽 */
        "bandwidth",
        /** 音频比特率 */
        "audioBitrate",
        /** 视频比特率 */
        "videoBitrate",
        /** 音频包队列长度 */
        "audioPacketQueueLength",
        /** 视频包队列长度 */
        "videoPacketQueueLength",
        /** 视频编码帧率 */
        "videoEncodeFramerate",
        /** 视频解码帧率 */
        "videoDecodeFramerate",
        /** 视频渲染帧率 */
        "videoRenderFramerate",
        /** 关键帧间隔 */
        "keyFrameInterval",
        /** 音频编码帧率 */
        "audioEncodeFramerate",
        /** 音频解码帧率 */
        "audioDecodeFramerate",
        /** 音频渲染帧率 */
        "audioRenderFramerate",
        /** 音频帧解码间隔最大值 */
        "audioFrameDecodeIntervalMax",
        /** 音频帧渲染间隔最大值 */
        "audioFrameRenderIntervalMax",
        /** 视频帧解码间隔最大值 */
        "videoFrameDecodeIntervalMax",
        /** 视频帧渲染间隔最大值 */
        "videoFrameRenderIntervalMax",
        /** 抖动 */
        "jitter",
        /** 音频卡顿次数 */
        "audioStutter",
        /** 视频卡顿次数 */
        "videoStutter"
      ];
      function getWasmUrl(...args) {
        const [type, codecId, mediaType] = args;
        const DECODE_BASE_URL = `${CDN_URL_WASM}/decode`;
        const RESAMPLE_BASE_URL = `${CDN_URL_WASM}/resample`;
        const STRETCHPITCH_BASE_URL = `${CDN_URL_WASM}/stretchpitch`;
        switch (type) {
          case "decoder":
            if (!codecId) {
              return new Error(`Missing codecId for decoder`);
            }
            if (codecId >= 65536 && codecId <= 65572) {
              return `${DECODE_BASE_URL}/pcm-simd.wasm`;
            }
            switch (codecId) {
              // -- 视频解码器 --
              // H264
              case AVCodecID.AV_CODEC_ID_H264:
                return `${DECODE_BASE_URL}/h264-simd.wasm`;
              // HEVC
              case AVCodecID.AV_CODEC_ID_HEVC:
                return `${DECODE_BASE_URL}/hevc-simd.wasm`;
              // MPEG4
              case AVCodecID.AV_CODEC_ID_MPEG4:
                return `${DECODE_BASE_URL}/mpeg4-simd.wasm`;
              // VVC
              case AVCodecID.AV_CODEC_ID_VVC:
                return `${DECODE_BASE_URL}/vvc-simd.wasm`;
              // AV1
              case AVCodecID.AV_CODEC_ID_AV1:
                return `${DECODE_BASE_URL}/av1-simd.wasm`;
              // VP8
              case AVCodecID.AV_CODEC_ID_VP8:
                return `${DECODE_BASE_URL}/vp8-simd.wasm`;
              // VP9
              case AVCodecID.AV_CODEC_ID_VP9:
                return `${DECODE_BASE_URL}/vp9-simd.wasm`;
              // THEORA
              case AVCodecID.AV_CODEC_ID_THEORA:
                return `${DECODE_BASE_URL}/theora-simd.wasm`;
              // MPEG1/2
              case AVCodecID.AV_CODEC_ID_MPEG2VIDEO:
                return `${DECODE_BASE_URL}/mpeg2video-simd.wasm`;
              // -- 音频解码器 --
              // AAC
              case AVCodecID.AV_CODEC_ID_AAC:
                return `${DECODE_BASE_URL}/aac-simd.wasm`;
              // MP3
              case AVCodecID.AV_CODEC_ID_MP3:
                return `${DECODE_BASE_URL}/mp3-simd.wasm`;
              // OPUS
              case AVCodecID.AV_CODEC_ID_OPUS:
                return `${DECODE_BASE_URL}/opus-simd.wasm`;
              // FLAC
              case AVCodecID.AV_CODEC_ID_FLAC:
                return `${DECODE_BASE_URL}/flac-simd.wasm`;
              // SPEEX
              case AVCodecID.AV_CODEC_ID_SPEEX:
                return `${DECODE_BASE_URL}/speex-simd.wasm`;
              // VORBIS
              case AVCodecID.AV_CODEC_ID_VORBIS:
                return `${DECODE_BASE_URL}/vorbis-simd.wasm`;
              // AC3
              case AVCodecID.AV_CODEC_ID_AC3:
                return `${DECODE_BASE_URL}/ac3-simd.wasm`;
              // EAC3
              case AVCodecID.AV_CODEC_ID_EAC3:
                return `${DECODE_BASE_URL}/eac3-simd.wasm`;
              // DTS (很多会出现部分声音缺失)
              case AVCodecID.AV_CODEC_ID_DTS:
                return `${DECODE_BASE_URL}/dca-simd.wasm`;
              default:
                return new Error(`Unsupported decoder: ${type} ${codecId} ${mediaType}`);
            }
          case "resampler":
            return `${RESAMPLE_BASE_URL}/resample-simd.wasm`;
          case "stretchpitcher":
            return `${STRETCHPITCH_BASE_URL}/stretchpitch-simd.wasm`;
          default:
            return new Error(`Unsupported wasm: ${type} ${codecId} ${mediaType}`);
        }
      }
      function collectUnsupportWasm(collect, getWasmFn) {
        return (...args) => {
          const result = getWasmFn(...args);
          if (result instanceof Error) {
            collect.push(args);
            return "";
          }
          return result;
        };
      }
      function useAvPlayerCore(ctx) {
        let seeking = false;
        const playerRef = shallowRef(null);
        const containerRef = shallowRef(null);
        const state = usePlayerCoreState();
        const stats = ref();
        const unsupportWasm = shallowRef([]);
        const streams = ref([]);
        const audioStreamId = ref(null);
        const videoStreamId = ref(null);
        const subtitleStreamId = ref(null);
        const audioStreams = computed(() => {
          return streams.value.filter((stream) => stream.mediaType === "Audio");
        });
        const videoStreams = computed(() => {
          return streams.value.filter((stream) => stream.mediaType === "Video");
        });
        const currentVideoStream = computed(() => {
          return videoStreams.value.find((stream) => stream.id === videoStreamId.value);
        });
        const customEmitter = ee();
        const isFirstPlay = ref(true);
        const lastTime = ref(null);
        const checkPlayer = () => {
          if (!playerRef.value) {
            throw new Error("playerRef is not found");
          }
          return playerRef.value;
        };
        watch(currentVideoStream, (stream) => {
          if (stream) {
            state.videoWidth.value = stream.codecparProxy.width;
            state.videoHeight.value = stream.codecparProxy.height;
          }
        });
        const { pause: pauseCollectStats, resume: resumeCollectStats } = useIntervalFn(() => {
          var _a;
          const statsKeys = PICK_STATS_KEYS;
          const _stats = (_a = playerRef.value) == null ? void 0 : _a.getStats();
          if (!_stats) {
            return;
          }
          stats.value = Object.fromEntries(statsKeys.map((key) => [key, get(_stats, key)]));
        }, 1e3, {
          immediate: false
        });
        const isSupportStream = (stream) => {
          return !unsupportWasm.value.find(([type, codecId]) => type === "decoder" && codecId === stream.codecparProxy.codecId);
        };
        const getPreferredAudioStream = (streams2) => {
          return streams2.find((stream) => {
            return stream.mediaType === "Audio" && stream.codecparProxy.chLayout.nbChannels <= 8 && stream.metadata.language === "eng";
          });
        };
        const destoryListeners = () => {
          var _a, _b;
          for (const [key, events] of Object.entries(((_a = playerRef.value) == null ? void 0 : _a.listeners) ?? {})) {
            for (const event of events) {
              (_b = playerRef.value) == null ? void 0 : _b.off(key, event.fn);
            }
          }
        };
        const setAudioStream = async (id) => {
          const player = checkPlayer();
          audioStreamId.value = id;
          await player.selectAudio(id);
        };
        const methods = {
          init: async (container) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            try {
              const AVPlayer = await loadESM({
                pkgName: "@libmedia/avplayer",
                path: "dist/esm/avplayer.js",
                varName: "AVPlayer"
              });
              const player = new AVPlayer({
                ...DEFAULT_OPTIONS,
                ...ctx.rootProps.avPlayerConfig,
                container,
                getWasm: collectUnsupportWasm(unsupportWasm.value, getWasmUrl)
              });
              containerRef.value = container;
              playerRef.value = player;
              (_a = playerRef.value) == null ? void 0 : _a.on("playing", () => {
                state.paused.value = false;
              });
              (_b = playerRef.value) == null ? void 0 : _b.on("paused", () => {
                state.paused.value = true;
              });
              (_c = playerRef.value) == null ? void 0 : _c.on("loaded", () => {
                state.isLoading.value = false;
                state.loaded.value = true;
              });
              (_d = playerRef.value) == null ? void 0 : _d.on("error", (error) => {
                console.error(error);
              });
              (_e = playerRef.value) == null ? void 0 : _e.on("seeking", () => {
                state.isLoading.value = true;
              });
              (_f = playerRef.value) == null ? void 0 : _f.on("seeked", () => {
                state.isLoading.value = false;
              });
              (_g = playerRef.value) == null ? void 0 : _g.on("timeout", () => {
                console.warn("avplayer timeout");
              });
              (_h = playerRef.value) == null ? void 0 : _h.on("time", (pts) => {
                if (seeking) {
                  return;
                }
                state.currentTime.value = Number(pts) / 1e3;
              });
            } catch (error) {
              console.error("初始化 AVPlayer 失败:", error);
              state.loadError.value = error;
            }
          },
          load: async (url, _lastTime) => {
            lastTime.value = _lastTime ?? null;
            const player = checkPlayer();
            await player.load(url, {
              http: {
                // 必须包含凭证, 否则 115 浏览器无法播放
                credentials: "include"
              }
            }).then(async () => {
              streams.value = await player.getStreams();
              console.log(videoStreams.value);
              const preferredAudioStream = getPreferredAudioStream(streams.value);
              if (preferredAudioStream) {
                await player.selectAudio(preferredAudioStream.id);
                audioStreamId.value = preferredAudioStream.id;
              }
              resumeCollectStats();
              methods.setVolume(state.volume.value);
              methods.setMute(state.muted.value);
              methods.setPlaybackRate(state.playbackRate.value);
              if (state.autoPlay.value) {
                await methods.play().then(async () => {
                  state.canplay.value = true;
                  customEmitter.emit("canplay");
                  state.isSuspended.value = !state.muted.value && player.isSuspended();
                }).catch((error) => {
                  console.error("播放失败", error);
                  state.loadError.value = error;
                });
              } else {
                state.canplay.value = true;
                customEmitter.emit("canplay");
              }
            }).catch((error) => {
              state.loadError.value = error;
              pauseCollectStats();
              throw error;
            });
            state.duration.value = Number(player.getDuration()) / 1e3;
            const { width, height } = useElementSize(containerRef.value);
            const resizeDebounced = useDebounceFn(() => {
              if (playerRef.value) {
                playerRef.value.resize(width.value, height.value);
              }
            }, 30);
            watch([width, height], resizeDebounced);
          },
          getRenderElement: () => {
            var _a, _b;
            return ((_a = containerRef.value) == null ? void 0 : _a.querySelector("canvas")) ?? ((_b = containerRef.value) == null ? void 0 : _b.querySelector("video")) ?? null;
          },
          play: () => {
            const player = checkPlayer();
            state.paused.value = false;
            return player.play({
              subtitle: false
            }).then(async () => {
              if (isFirstPlay.value) {
                await methods.seek(lastTime.value ?? state.currentTime.value);
                isFirstPlay.value = false;
              }
              videoStreamId.value = player.getSelectedVideoStreamId();
              subtitleStreamId.value = player.getSelectedSubtitleStreamId();
            });
          },
          pause: () => {
            const player = checkPlayer();
            state.paused.value = true;
            return player.pause();
          },
          togglePlay: () => {
            if (state.paused.value) {
              return methods.play();
            }
            return methods.pause();
          },
          setPlaybackRate: (rate) => {
            const player = checkPlayer();
            state.playbackRate.value = rate;
            player.setPlaybackRate(Math.min(rate, 2));
          },
          setVolume: (volume) => {
            const player = checkPlayer();
            state.volume.value = volume;
            player.setVolume(volume / 100 * 3);
          },
          setMute: (muted) => {
            const player = checkPlayer();
            state.muted.value = muted;
            player.setVolume(muted ? 0 : 100);
            if (!muted) {
              methods.resumeSuspended();
            }
          },
          toggleMute: () => {
            methods.setMute(!state.muted.value);
          },
          resumeSuspended: async () => {
            const player = checkPlayer();
            await player.resume();
            state.isSuspended.value = false;
          },
          setAutoPlay: (autoPlay) => {
            state.autoPlay.value = autoPlay;
          },
          seek: async (time) => {
            seeking = true;
            const player = checkPlayer();
            state.currentTime.value = time;
            await player.seek(BigInt(Math.floor(time * 1e3)));
            await nextTick();
            seeking = false;
          },
          on: (event, callback) => {
            watch(playerRef, (player) => {
              if (player) {
                switch (event) {
                  case "canplay":
                    customEmitter.on("canplay", callback);
                    break;
                  case "timeupdate":
                    player.on("time", () => {
                      callback(state.currentTime.value);
                    });
                    break;
                  case "seeking":
                    player.on("seeking", () => {
                      callback(state.currentTime.value);
                    });
                    break;
                  case "seeked":
                    player.on("seeked", () => {
                      callback(state.currentTime.value);
                    });
                    break;
                  default:
                    player.on(event, callback);
                }
              }
            }, {
              once: true
            });
          },
          /** 销毁 */
          destroy: async () => {
            destoryListeners();
            pauseCollectStats();
            state.reset();
            if (playerRef.value) {
              playerRef.value.pause();
              await playerRef.value.destroy();
            }
            playerRef.value = null;
            return Promise.resolve();
          }
        };
        return {
          ...state,
          ...methods,
          stats,
          streams,
          audioStreams,
          videoStreams,
          audioStreamId,
          videoStreamId,
          subtitleStreamId,
          isSupportStream,
          setAudioStream,
          type: PlayerCoreType.AvPlayer
        };
      }
      function useNativePlayerCore(_ctx) {
        const renderElementRef = shallowRef();
        const state = usePlayerCoreState();
        const getVideoElementRef = () => {
          if (!renderElementRef.value) {
            throw new Error("videoElementRef is not found");
          }
          return renderElementRef.value;
        };
        const methods = {
          init: async (container) => {
            const videoElement = document.createElement("video");
            container.appendChild(videoElement);
            videoElement.style.width = "100%";
            videoElement.style.height = "100%";
            videoElement.style.objectFit = "contain";
            renderElementRef.value = videoElement;
            useEventListener(renderElementRef, "play", () => {
              state.paused.value = false;
            });
            useEventListener(renderElementRef, "pause", () => {
              state.paused.value = true;
            });
            useEventListener(renderElementRef, "playing", () => {
              state.paused.value = false;
            });
            useEventListener(renderElementRef, "ended", () => {
              state.paused.value = true;
            });
            useEventListener(renderElementRef, "waiting", () => {
              state.isLoading.value = true;
            });
            useEventListener(renderElementRef, "canplay", () => {
              state.isLoading.value = false;
              state.canplay.value = true;
            });
            useEventListener(renderElementRef, "seeking", () => {
              state.isLoading.value = true;
            });
            useEventListener(renderElementRef, "seeked", () => {
              state.isLoading.value = false;
            });
            useEventListener(renderElementRef, "timeupdate", () => {
              var _a;
              state.currentTime.value = ((_a = renderElementRef.value) == null ? void 0 : _a.currentTime) ?? 0;
            });
            return Promise.resolve();
          },
          load: async (url, lastTime) => {
            const videoElement = getVideoElementRef();
            methods.setVolume(state.volume.value);
            methods.setMute(state.muted.value);
            methods.setAutoPlay(state.autoPlay.value);
            videoElement.currentTime = lastTime ?? state.currentTime.value;
            videoElement.src = url;
            methods.setPlaybackRate(state.playbackRate.value);
            return new Promise((resolve, reject) => {
              useEventListener(renderElementRef, "loadedmetadata", () => {
                state.duration.value = videoElement.duration;
                state.videoWidth.value = videoElement.videoWidth;
                state.videoHeight.value = videoElement.videoHeight;
                resolve();
                if (state.autoPlay.value) {
                  methods.play();
                }
              });
              useEventListener(renderElementRef, "error", (_event) => {
                var _a;
                if (_event.target instanceof HTMLVideoElement) {
                  const error = new Error((_a = _event.target.error) == null ? void 0 : _a.message);
                  error.name = "Media Error";
                  state.loadError.value = error;
                } else {
                  state.loadError.value = new Error("Video element unknown error");
                }
                reject(state.loadError.value);
              });
            });
          },
          getRenderElement: () => {
            return getVideoElementRef();
          },
          play: () => {
            const videoElement = getVideoElementRef();
            return videoElement.play().then(() => {
              state.paused.value = false;
            }).catch((error) => {
              if (error.name === "NotAllowedError" && videoElement.error === null) {
                console.warn(error);
                state.isSuspended.value = true;
                const videoElement2 = getVideoElementRef();
                videoElement2.muted = true;
                return methods.play();
              }
              if (error.name === "AbortError") {
                console.warn(error);
                throw error;
              }
              console.error("native player play error", error);
              state.loadError.value = error;
              throw error;
            });
          },
          pause: () => {
            const videoElement = getVideoElementRef();
            state.paused.value = true;
            videoElement.pause();
            return Promise.resolve();
          },
          togglePlay: () => {
            if (state.paused.value) {
              return methods.play();
            }
            return methods.pause();
          },
          setPlaybackRate: (rate) => {
            const videoElement = getVideoElementRef();
            state.playbackRate.value = rate;
            videoElement.playbackRate = rate;
          },
          setVolume: (volume) => {
            const videoElement = getVideoElementRef();
            state.volume.value = volume;
            videoElement.volume = volume / 100;
          },
          setMute: (muted) => {
            const videoElement = getVideoElementRef();
            state.muted.value = muted;
            videoElement.muted = muted;
          },
          toggleMute: () => {
            methods.setMute(!state.muted.value);
            if (state.isSuspended.value) {
              state.isSuspended.value = false;
            }
          },
          resumeSuspended: async () => {
            const videoElement = getVideoElementRef();
            videoElement.muted = false;
            state.isSuspended.value = false;
          },
          setAutoPlay: (autoPlay) => {
            const videoElement = getVideoElementRef();
            state.autoPlay.value = autoPlay;
            videoElement.autoplay = autoPlay;
          },
          seek: async (time) => {
            return new Promise((resolve) => {
              const videoElement = getVideoElementRef();
              videoElement.currentTime = time;
              state.currentTime.value = time;
              if (videoElement.src) {
                useEventListener(videoElement, "seeked", () => {
                  resolve();
                });
              } else {
                resolve();
              }
            });
          },
          on: (event, callback) => {
            watch(renderElementRef, (videoElement) => {
              if (videoElement) {
                switch (event) {
                  case "canplay":
                    videoElement.addEventListener("canplay", callback);
                    break;
                  case "timeupdate":
                    videoElement.addEventListener("timeupdate", () => {
                      callback(videoElement.currentTime);
                    });
                    break;
                  case "seeking":
                    videoElement.addEventListener("seeking", () => {
                      callback(videoElement.currentTime);
                    });
                    break;
                  case "seeked":
                    videoElement.addEventListener("seeked", () => {
                      callback(videoElement.currentTime);
                    });
                    break;
                  default:
                    videoElement.addEventListener(event, callback);
                }
              }
            }, {
              once: true
            });
          },
          destroy: () => {
            const videoElement = renderElementRef.value;
            if (!videoElement)
              return Promise.resolve();
            videoElement.pause();
            videoElement.currentTime = 0;
            videoElement.src = "";
            videoElement.load();
            videoElement.remove();
            state.reset();
            renderElementRef.value = void 0;
            return Promise.resolve();
          }
        };
        return {
          ...state,
          ...methods,
          renderElementRef,
          type: PlayerCoreType.Native
        };
      }
      const DEFAULT_CONFIG = {
        // 自动开始加载
        autoStartLoad: true,
        // 最大缓冲区长度
        maxBufferLength: 1200,
        // 低延迟模式
        lowLatencyMode: true,
        // 开始位置
        startPosition: -1,
        // 调试
        debug: false
      };
      function useHlsPlayerCore(ctx) {
        const hlsRef = shallowRef(null);
        const videoNative = useNativePlayerCore();
        const getHlsRef = () => {
          if (!hlsRef.value) {
            throw new Error("Hls is not initialized");
          }
          return hlsRef.value;
        };
        const methods = {
          ...videoNative,
          init: async (container, config = {}) => {
            await videoNative.init(container);
            hlsRef.value = new Hls({
              ...DEFAULT_CONFIG,
              ...ctx.rootProps.hlsConfig,
              ...config
            });
          },
          load: (url) => {
            const videoElement = videoNative.getRenderElement();
            const hls = getHlsRef();
            hls.loadSource(url);
            hls.attachMedia(videoElement);
            videoElement.muted = videoNative.muted.value;
            videoElement.playbackRate = videoNative.playbackRate.value;
            videoElement.volume = videoNative.volume.value / 100;
            return new Promise((resolve, reject) => {
              useEventListener(videoElement, "loadedmetadata", () => {
                videoNative.duration.value = videoElement.duration;
                resolve();
                if (videoNative.autoPlay.value) {
                  videoNative.play();
                }
              });
              useEventListener(videoElement, "error", (_event) => {
                videoNative.loadError.value = new Error("NotSupportedError");
                reject(videoNative.loadError.value);
              });
            });
          },
          destroy: () => {
            if (hlsRef.value) {
              hlsRef.value.destroy();
              hlsRef.value = null;
            }
            return videoNative.destroy();
          }
        };
        return {
          ...videoNative,
          ...methods,
          type: PlayerCoreType.Hls
        };
      }
      function usePlayerCoreDecorator(usePlayerCore, ctx) {
        const player = usePlayerCore(ctx);
        const noop2 = () => {
        };
        player.on("canplay", ctx.rootProps.onCanplay ?? noop2);
        player.on("timeupdate", ctx.rootProps.onTimeupdate ?? noop2);
        player.on("seeking", ctx.rootProps.onSeeking ?? noop2);
        player.on("seeked", ctx.rootProps.onSeeked ?? noop2);
        const { handlePlayEnd } = usePlayEndHandler(ctx);
        player.on("ended", () => {
          const playMode = ctx.rootProps.currentPlayMode ?? PlayMode.STOP;
          handlePlayEnd(playMode);
        });
        const syncRefList = [
          syncRef(ctx.rootPropsVm.muted, player.muted),
          syncRef(ctx.rootPropsVm.playbackRate, player.playbackRate),
          syncRef(ctx.rootPropsVm.volume, player.volume),
          syncRef(ctx.rootPropsVm.autoPlay, player.autoPlay)
        ];
        const unSyncRefList = () => {
          syncRefList.forEach((unSyncRef) => {
            unSyncRef();
          });
        };
        return toReactive({
          ...player,
          /** 调整音量 (相对当前音量) */
          adjustVolume: (delta) => {
            const newVolume = Math.min(Math.max(0, player.volume.value + delta), 100);
            player.setVolume(newVolume);
          },
          /** 快进快退 (秒数或百分比浮点数) */
          skip: (value, isPercent = false) => {
            const newTime = isPercent ? value * player.duration.value : player.currentTime.value + value;
            const clampedTime = Math.min(Math.max(0, newTime), player.duration.value);
            player.seek(clampedTime);
          },
          /** 销毁 */
          destroy: async () => {
            unSyncRefList();
            await player.destroy();
          }
        });
      }
      function useSwitchPlayerCore(ctx) {
        let isSwitching = false;
        const switchDriver = async (videoType) => {
          if (isSwitching) {
            console.warn("播放器核心正在切换中，忽略此次请求");
            return;
          }
          isSwitching = true;
          try {
            if (ctx.playerCore.value) {
              console.log("正在销毁现有播放器核心:", ctx.playerCore.value.type);
              await ctx.playerCore.value.destroy();
              ctx.playerCore.value = void 0;
            }
            await new Promise((resolve) => setTimeout(resolve, 0));
            console.log("正在创建新的播放器核心:", videoType);
            switch (videoType) {
              case PlayerCoreType.Native:
                ctx.playerCore.value = usePlayerCoreDecorator(useNativePlayerCore, ctx);
                break;
              case PlayerCoreType.Hls:
                ctx.playerCore.value = usePlayerCoreDecorator(useHlsPlayerCore, ctx);
                break;
              case PlayerCoreType.AvPlayer:
                ctx.playerCore.value = usePlayerCoreDecorator(useAvPlayerCore, ctx);
                break;
              default:
                throw new Error(`Unsupported video type: ${videoType}`);
            }
          } catch (error) {
            console.error("切换视频驱动失败:", error);
            throw error;
          } finally {
            isSwitching = false;
          }
        };
        return {
          switchDriver
        };
      }
      const DELAY_HIDE_CONTROLS_TIME = 1e3;
      const ROOT_MOUSE_MOVE_THROTTLE_TIME = 200;
      const ROOT_MOUSE_LEAVE_DEBOUNCE_TIME = 30;
      const LOCK_CONTROLS_TIMEOUT = 1e3;
      function useControls(ctx) {
        const mainRef = shallowRef(null);
        const visible = shallowRef(true);
        const disabledAutoHideCount = shallowRef(0);
        const disabledAutoHide = computed(() => disabledAutoHideCount.value > 0);
        const disabledHideOnMouseLeave = shallowRef(false);
        let hideControlsTimer = null;
        let hideControlsLeaveLockTimer = null;
        const controlsMainHeight = computed(() => {
          var _a;
          return (_a = mainRef.value) == null ? void 0 : _a.offsetHeight;
        });
        const show = () => {
          visible.value = true;
        };
        const hide = () => {
          visible.value = false;
        };
        const stopAutoHideTimer = () => {
          if (hideControlsTimer) {
            clearTimeout(hideControlsTimer);
            hideControlsTimer = null;
          }
        };
        const handleAutoHide = () => {
          if (disabledAutoHide.value) {
            return;
          }
          hide();
        };
        const startAutoHideTimer = () => {
          if (disabledAutoHide.value) {
            return;
          }
          stopAutoHideTimer();
          hideControlsTimer = window.setTimeout(handleAutoHide, DELAY_HIDE_CONTROLS_TIME);
        };
        const addDisabledAutoHide = () => {
          disabledAutoHideCount.value++;
          if (disabledAutoHideCount.value === 1) {
            stopAutoHideTimer();
          }
        };
        const removeDisabledAutoHide = () => {
          disabledAutoHideCount.value = Math.max(0, disabledAutoHideCount.value - 1);
        };
        const setDisabledAutoHide = (value) => {
          if (value) {
            addDisabledAutoHide();
          } else {
            removeDisabledAutoHide();
          }
        };
        const setDisabledHideOnMouseLeave = (value) => {
          disabledHideOnMouseLeave.value = value;
        };
        const lockControlsWithTimeoutUnlock = (timeout = LOCK_CONTROLS_TIMEOUT) => {
          if (hideControlsLeaveLockTimer) {
            clearTimeout(hideControlsLeaveLockTimer);
          }
          disabledHideOnMouseLeave.value = true;
          stopAutoHideTimer();
          hideControlsLeaveLockTimer = window.setTimeout(() => {
            disabledHideOnMouseLeave.value = false;
            startAutoHideTimer();
          }, timeout);
        };
        const handleRootMouseMove = useThrottleFn(() => {
          show();
          startAutoHideTimer();
        }, ROOT_MOUSE_MOVE_THROTTLE_TIME);
        const handleRootMouseLeave = useDebounceFn(() => {
          if (disabledHideOnMouseLeave.value) {
            return;
          }
          stopAutoHideTimer();
          hide();
        }, ROOT_MOUSE_LEAVE_DEBOUNCE_TIME);
        watch([visible, controlsMainHeight], () => {
          if (!ctx.cssVar) {
            return;
          }
          if (visible.value) {
            ctx.cssVar.safeAreaBottom.value = `${controlsMainHeight.value}px`;
          } else {
            ctx.cssVar.safeAreaBottom.value = "0px";
          }
        });
        useEventListener(ctx.refs.rootRef, "mousemove", handleRootMouseMove);
        useEventListener(ctx.refs.rootRef, "mouseleave", handleRootMouseLeave);
        onUnmounted(() => {
          stopAutoHideTimer();
        });
        return {
          visible,
          mainRef,
          disabledHideOnMouseLeave,
          disabledAutoHide,
          setDisabledAutoHide,
          setDisabledHideOnMouseLeave,
          lockControlsWithTimeoutUnlock,
          addDisabledAutoHide,
          removeDisabledAutoHide,
          startAutoHideTimer,
          stopAutoHideTimer
        };
      }
      function useCssVar(ctx) {
        const prefix = "--x-player";
        const keys2 = {
          safeAreaBottom: `${prefix}-safe-area-bottom`
        };
        const safeAreaBottom = useCssVar$1(keys2.safeAreaBottom, ctx.refs.rootRef, {
          initialValue: "0px"
        });
        return {
          safeAreaBottom,
          keys: keys2
        };
      }
      function useFullscreen(ctx) {
        const showPlaylist = ctx.rootPropsVm.showPlaylist;
        const isFullscreen = shallowRef(false);
        const prevShowPlaylist = shallowRef(false);
        const handleFullscreenChange = () => {
          isFullscreen.value = !!document.fullscreenElement;
        };
        const toggleFullscreen = async () => {
          ctx.controls.lockControlsWithTimeoutUnlock();
          try {
            if (!document.fullscreenElement) {
              window.scrollTo(0, 0);
              await document.documentElement.requestFullscreen();
              prevShowPlaylist.value = showPlaylist.value;
              if (showPlaylist.value) {
                showPlaylist.value = false;
              }
            } else {
              await document.exitFullscreen();
              if (prevShowPlaylist.value) {
                showPlaylist.value = true;
              }
            }
          } catch (error) {
            console.error("Failed to toggle fullscreen:", error);
          }
        };
        const toggleShowSider = async () => {
          const newValue = !showPlaylist.value;
          showPlaylist.value = newValue;
        };
        useEventListener(document, "fullscreenchange", handleFullscreenChange);
        useEventListener(document, "webkitfullscreenchange", handleFullscreenChange);
        useEventListener(document, "mozfullscreenchange", handleFullscreenChange);
        useEventListener(document, "MSFullscreenChange", handleFullscreenChange);
        return {
          showPlaylist,
          isFullscreen,
          toggleFullscreen,
          toggleShowSider
        };
      }
      const MODIFIERS = {
        Shift: "Shift",
        Alt: "Alt",
        Control: "Control",
        Meta: "Meta"
      };
      const KEYS = {
        "sapce": " ",
        "arrowLeft": "ArrowLeft",
        "arrowRight": "ArrowRight",
        "arrowUp": "ArrowUp",
        "arrowDown": "ArrowDown",
        "w": "w",
        "a": "a",
        "b": "b",
        "s": "s",
        "d": "d",
        "f": "f",
        "m": "m",
        "W": "W",
        "A": "A",
        "B": "B",
        "S": "S",
        "D": "D",
        "F": "F",
        "0": "0",
        "1": "1",
        "2": "2",
        "3": "3",
        "4": "4",
        "5": "5",
        "6": "6",
        "7": "7",
        "8": "8",
        "9": "9",
        "-": "-",
        "=": "=",
        "[": "[",
        "]": "]",
        "\\": "\\",
        "h": "h",
        "j": "j",
        "l": "l",
        "H": "H",
        "J": "J",
        "L": "L",
        "r": "r",
        "R": "R"
      };
      const HOT_KEYS_CONFIG = {
        /**
         * 按下 0-9 进度跳转
         */
        progress: {
          keys: [
            KEYS["0"],
            KEYS["1"],
            KEYS["2"],
            KEYS["3"],
            KEYS["4"],
            KEYS["5"],
            KEYS["6"],
            KEYS["7"],
            KEYS["8"],
            KEYS["9"]
          ],
          name: "进度跳转",
          keydown: (ctx, event) => {
            var _a;
            const key = event.key;
            const digit = Number(key);
            const percentage = digit / 10;
            (_a = ctx.playerCore.value) == null ? void 0 : _a.skip(percentage, true);
            if (ctx.hud) {
              ctx.hud.showProgressJump(digit);
            }
          }
        },
        /**
         * 按下 ← a 快退
         */
        fastBackward: {
          keys: [KEYS.arrowLeft, KEYS.a, KEYS.A],
          name: "快退",
          allowRepeat: true,
          keydown: (ctx) => {
            var _a, _b;
            (_a = ctx.playerCore.value) == null ? void 0 : _a.skip(-5);
            (_b = ctx.hud) == null ? void 0 : _b.showFastJumpHud(-1);
          }
        },
        /**
         * 按下 → d 快进
         */
        fastForward: {
          keys: [KEYS.arrowRight, KEYS.d, KEYS.D],
          name: "快进",
          allowRepeat: true,
          keydown: async (ctx, event) => {
            var _a, _b, _c, _d, _e;
            if (event.repeat) {
              if (!((_a = ctx.playbackRate) == null ? void 0 : _a.fastForward.value)) {
                (_b = ctx.playbackRate) == null ? void 0 : _b.startLongPressFastForward();
              }
              (_c = ctx.hud) == null ? void 0 : _c.showLongPressFastForward();
              return;
            }
            (_d = ctx.playerCore.value) == null ? void 0 : _d.skip(5);
            (_e = ctx.hud) == null ? void 0 : _e.showFastJumpHud(1);
          },
          keyup: async (ctx) => {
            var _a, _b, _c;
            if ((_a = ctx.playbackRate) == null ? void 0 : _a.fastForward.value) {
              (_b = ctx.playbackRate) == null ? void 0 : _b.stopLongPressFastForward();
              (_c = ctx.hud) == null ? void 0 : _c.clear();
            }
          }
        },
        /**
         * 按下 ↑ w 播放速度增大
         */
        playbackRateUp: {
          keys: [KEYS.arrowUp, KEYS.w, KEYS.W],
          name: "播放速度增大",
          allowRepeat: true,
          keydown: async (ctx) => {
            var _a, _b;
            (_a = ctx.playbackRate) == null ? void 0 : _a.up();
            (_b = ctx.hud) == null ? void 0 : _b.showPlaybackRate();
          }
        },
        /**
         * 按下 ↓ s 播放速度减小
         */
        playbackRateDown: {
          keys: [KEYS.arrowDown, KEYS.s, KEYS.S],
          name: "播放速度减小",
          allowRepeat: true,
          keydown: (ctx, event) => {
            var _a, _b, _c, _d;
            if (event.repeat) {
              (_a = ctx.playbackRate) == null ? void 0 : _a.downWithLowerLimit();
              (_b = ctx.hud) == null ? void 0 : _b.showPlaybackRate();
            } else {
              (_c = ctx.playbackRate) == null ? void 0 : _c.down();
              (_d = ctx.hud) == null ? void 0 : _d.showPlaybackRate();
            }
          }
        },
        /**
         * 按下 = 音量增大
         */
        volumeUp: {
          keys: [KEYS["="]],
          name: "音量增大",
          allowRepeat: true,
          keydown: (ctx) => {
            var _a, _b;
            (_a = ctx.playerCore.value) == null ? void 0 : _a.adjustVolume(5);
            (_b = ctx.hud) == null ? void 0 : _b.showVolume();
          }
        },
        /**
         * 按下 - 音量减小
         */
        volumeDown: {
          keys: [KEYS["-"]],
          name: "音量减小",
          allowRepeat: true,
          keydown: (ctx) => {
            var _a, _b;
            (_a = ctx.playerCore.value) == null ? void 0 : _a.adjustVolume(-5);
            (_b = ctx.hud) == null ? void 0 : _b.showVolume();
          }
        },
        /**
         * 按下 空格 播放/暂停
         */
        togglePlay: {
          keys: [KEYS.sapce],
          name: "播放/暂停",
          keydown: (ctx) => {
            var _a;
            (_a = ctx.playerCore.value) == null ? void 0 : _a.togglePlay();
          }
        },
        /**
         * 按下 m 切换静音
         */
        toggleMute: {
          keys: [KEYS.m],
          name: "切换静音",
          keydown: (ctx) => {
            var _a, _b, _c, _d, _e;
            if ((_a = ctx.playerCore.value) == null ? void 0 : _a.isSuspended) {
              (_b = ctx.playerCore.value) == null ? void 0 : _b.resumeSuspended();
              (_c = ctx.hud) == null ? void 0 : _c.showResumeSuspended();
              return;
            }
            (_d = ctx.playerCore.value) == null ? void 0 : _d.toggleMute();
            (_e = ctx.hud) == null ? void 0 : _e.showMute();
          }
        },
        /**
         * 按下 f 切换全屏
         */
        toggleFullscreen: {
          keys: [KEYS.f, KEYS.F],
          name: "切换全屏",
          keydown: (ctx) => {
            var _a;
            (_a = ctx.fullscreen) == null ? void 0 : _a.toggleFullscreen();
          }
        },
        /**
         * 按下 b 切换播放列表
         */
        toggleShowSider: {
          keys: [KEYS.b, KEYS.B],
          name: "切换播放列表",
          keydown: (ctx) => {
            var _a;
            (_a = ctx.fullscreen) == null ? void 0 : _a.toggleShowSider();
          }
        },
        /**
         * 按下 [ 向左旋转
         */
        rotateLeft: {
          keys: [KEYS["["], KEYS.l, KEYS.L],
          name: "向左旋转",
          keydown: (ctx) => {
            var _a;
            (_a = ctx.transform) == null ? void 0 : _a.left();
          }
        },
        /**
         * 按下 ] 向右旋转
         */
        rotateRight: {
          keys: [KEYS["]"], KEYS.r, KEYS.R],
          name: "向右旋转",
          keydown: (ctx) => {
            var _a;
            (_a = ctx.transform) == null ? void 0 : _a.right();
          }
        },
        /**
         * 上一集 ←
         */
        previousVideo: {
          keys: [KEYS.arrowLeft],
          name: "上一集",
          keydown: (ctx) => {
            const onPreviousVideo = ctx.rootProps.onPreviousVideo;
            if (onPreviousVideo) {
              onPreviousVideo();
            }
          }
        },
        /**
         * 下一集 →
         */
        nextVideo: {
          keys: [KEYS.arrowRight],
          name: "下一集",
          keydown: (ctx) => {
            const onNextVideo = ctx.rootProps.onNextVideo;
            if (onNextVideo) {
              onNextVideo();
            }
          }
        },
        /**
         * 按下 \ 重置旋转
         */
        resetRotation: {
          keys: [KEYS["\\"]],
          name: "重置旋转",
          keydown: (ctx) => {
            var _a;
            (_a = ctx.transform) == null ? void 0 : _a.normal();
          }
        },
        /**
         * 按下 h 水平翻转
         */
        toggleFlipX: {
          keys: [KEYS.h, KEYS.H],
          name: "水平翻转",
          keydown: (ctx) => {
            var _a;
            (_a = ctx.transform) == null ? void 0 : _a.toggleFlipX();
          }
        },
        /**
         * 按下 j 垂直翻转
         */
        toggleFlipY: {
          keys: [KEYS.j, KEYS.J],
          name: "垂直翻转",
          keydown: (ctx) => {
            var _a;
            (_a = ctx.transform) == null ? void 0 : _a.toggleFlipY();
          }
        }
      };
      function parseKeyConfig(key) {
        return new Set(key.split("+").filter((item) => item !== ""));
      }
      function preseKeyEvent(event) {
        const modifiers = [
          event.altKey ? MODIFIERS.Alt : null,
          event.shiftKey ? MODIFIERS.Shift : null,
          event.ctrlKey ? MODIFIERS.Control : null,
          event.metaKey ? MODIFIERS.Meta : null
        ].filter((item) => !!item);
        return /* @__PURE__ */ new Set([...modifiers, event.key]);
      }
      function isSame(eventSet, configSet) {
        return eventSet.size === configSet.size && Array.from(configSet).every((key) => eventSet.has(key));
      }
      function matchKey(event) {
        const eventSet = preseKeyEvent(event);
        for (const config of Object.values(HOT_KEYS_CONFIG)) {
          for (const key of config.keys) {
            const configSet = parseKeyConfig(key);
            if (isSame(eventSet, configSet)) {
              return { key, config };
            }
          }
        }
        return null;
      }
      function useHotKey(ctx) {
        const handleKeydown = (event) => {
          const match = matchKey(event);
          if (match == null ? void 0 : match.key) {
            event.preventDefault();
            if (event.repeat && !match.config.allowRepeat) {
              return;
            }
            match.config.keydown(ctx, event, match);
          }
        };
        const handleKeyup = (event) => {
          var _a, _b;
          const match = matchKey(event);
          if (match == null ? void 0 : match.key) {
            event.preventDefault();
            (_b = (_a = match.config).keyup) == null ? void 0 : _b.call(_a, ctx, event, match);
          }
        };
        useEventListener("keydown", handleKeydown);
        useEventListener("keyup", handleKeyup);
      }
      const ICON_SETTINGS = "material-symbols:settings-rounded";
      const ICON_PASUE = "material-symbols:pause-rounded";
      const ICON_PLAY = "material-symbols:play-arrow-rounded";
      const ICON_PLAYER_CORE = "lucide:atom";
      const ICON_AUDIO_TRACK = "material-symbols:audio-file";
      const ICON_FAST_FORWARD = "material-symbols:fast-forward-rounded";
      const ICON_FAST_REWIND = "material-symbols:fast-rewind-rounded";
      const ICON_ROTATE_LEFT = "material-symbols:rotate-left-rounded";
      const ICON_ROTATE_RIGHT = "material-symbols:rotate-right-rounded";
      const ICON_ROTATE_NORMAL = "material-symbols:block";
      const ICON_FLIP_X = "gis:flip-h";
      const ICON_FLIP_Y = "gis:flip-v";
      const ICON_LOCATION_ON = "material-symbols:location-on-rounded";
      const ICON_ROCKET_LAUNCH = "material-symbols:rocket-launch-rounded";
      const ICON_ROTATE = "material-symbols:rotate-right-rounded";
      const ICON_TIMER = "material-symbols:timer-rounded";
      const ICON_VOLUME_OFF = "material-symbols:volume-off-rounded";
      const ICON_VOLUME_MUTE = "material-symbols:volume-mute-rounded";
      const ICON_VOLUME_DOWN = "material-symbols:volume-down-rounded";
      const ICON_VOLUME_UP = "material-symbols:volume-up-rounded";
      function getVolumeIcon(volume = 0, muted = false) {
        if (muted) {
          return ICON_VOLUME_OFF;
        }
        if (volume === 0) {
          return ICON_VOLUME_MUTE;
        }
        if (volume < 50) {
          return ICON_VOLUME_DOWN;
        }
        return ICON_VOLUME_UP;
      }
      function fillZero(value) {
        return value.toString().padStart(2, "0");
      }
      function formatTime(seconds) {
        if (Number.isNaN(seconds) || seconds === void 0) {
          return "--:--";
        }
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor(seconds % 3600 / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${hours > 0 ? `${fillZero(hours)}:` : ""}${fillZero(minutes)}:${fillZero(remainingSeconds)}`;
      }
      const DurationOptions = {
        // 快速
        Fast: 500,
        // 正常
        Normal: 1500
      };
      function useHud(ctx) {
        const currentMessage = shallowRef(null);
        let timeoutId = null;
        const messages = computed(() => {
          return currentMessage.value ? [currentMessage.value] : [];
        });
        const show = (message) => {
          const timestamp = Date.now();
          const duration2 = message.duration || DurationOptions.Normal;
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          currentMessage.value = {
            ...message,
            timestamp
          };
          timeoutId = window.setTimeout(() => {
            currentMessage.value = null;
            timeoutId = null;
          }, duration2);
        };
        const clear = () => {
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          currentMessage.value = null;
        };
        const getCurrentProgressPercentage = () => {
          if (!ctx.playerCore.value)
            return 0;
          return ctx.playerCore.value.duration > 0 ? ctx.playerCore.value.currentTime / ctx.playerCore.value.duration * 100 : 0;
        };
        const showProgressJump = (digit) => {
          var _a;
          const percentage = digit / 10;
          const targetTime = percentage * (((_a = ctx.playerCore.value) == null ? void 0 : _a.duration) || 0);
          const minutes = Math.floor(targetTime / 60);
          const seconds = Math.floor(targetTime % 60);
          const timeString = `${minutes}:${seconds.toString().padStart(2, "0")}`;
          show({
            title: digit === 0 ? "跳转到开头" : `跳转到 ${digit}0%`,
            icon: ICON_LOCATION_ON,
            value: timeString,
            progress: {
              max: 100,
              min: 0,
              value: percentage * 100
            }
          });
        };
        const showVolume = () => {
          var _a, _b, _c;
          const value = (_a = ctx.playerCore.value) == null ? void 0 : _a.volume;
          const icon = getVolumeIcon(((_b = ctx.playerCore.value) == null ? void 0 : _b.volume) ?? 0, ((_c = ctx.playerCore.value) == null ? void 0 : _c.muted) ?? false);
          show({
            title: "音量",
            icon,
            value: `${value}`,
            progress: {
              value,
              max: 100,
              min: 0
            }
          });
        };
        const showMute = () => {
          var _a, _b;
          const muted = (_a = ctx.playerCore.value) == null ? void 0 : _a.muted;
          const icon = getVolumeIcon(((_b = ctx.playerCore.value) == null ? void 0 : _b.volume) ?? 0, muted ?? false);
          const value = muted ? "静音" : "取消静音";
          show({
            icon,
            value
          });
        };
        const showResumeSuspended = () => {
          var _a, _b;
          const icon = getVolumeIcon(((_a = ctx.playerCore.value) == null ? void 0 : _a.volume) ?? 0, ((_b = ctx.playerCore.value) == null ? void 0 : _b.muted) ?? false);
          show({
            icon,
            value: "音频已恢复"
          });
        };
        const showPlaybackRate = () => {
          var _a;
          const playbackRate = (_a = ctx.playerCore.value) == null ? void 0 : _a.playbackRate;
          if (!playbackRate)
            return;
          show({
            title: "播放速度",
            icon: ICON_TIMER,
            value: playbackRate
          });
        };
        if (ctx.transform) {
          const { rotate, flipX, flipY } = ctx.transform;
          watch(rotate, (newRotate, oldRotate) => {
            if (oldRotate === void 0)
              return;
            show({
              title: "旋转",
              icon: ICON_ROTATE,
              value: `${newRotate}°`
            });
          });
          watch(flipX, (newFlipX) => {
            show({
              title: "水平翻转",
              icon: ICON_FLIP_X,
              value: newFlipX ? "开启" : "关闭",
              iconClass: newFlipX ? "text-base-content" : "text-base-content/70"
            });
          });
          watch(flipY, (newFlipY) => {
            show({
              title: "垂直翻转",
              icon: ICON_FLIP_Y,
              value: newFlipY ? "开启" : "关闭",
              iconClass: newFlipY ? "text-base-content" : "text-base-content/70"
            });
          });
        }
        const showFastJumpHud = (dir) => {
          var _a;
          const currentProgress = getCurrentProgressPercentage();
          const title = dir === 1 ? "快进" : "快退";
          show({
            title,
            value: formatTime(((_a = ctx.playerCore.value) == null ? void 0 : _a.currentTime) || 0),
            icon: dir === 1 ? ICON_FAST_FORWARD : ICON_FAST_REWIND,
            progress: {
              max: 100,
              min: 0,
              value: currentProgress
            },
            duration: DurationOptions.Fast
          });
        };
        const showLongPressFastForward = () => {
          var _a;
          const currentProgress = getCurrentProgressPercentage();
          show({
            title: "快速播放",
            icon: ICON_ROCKET_LAUNCH,
            value: `${formatTime(((_a = ctx.playerCore.value) == null ? void 0 : _a.currentTime) || 0)}`,
            progress: {
              max: 100,
              min: 0,
              value: currentProgress
            }
          });
        };
        onUnmounted(() => {
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
        });
        return {
          messages,
          show,
          clear,
          showProgressJump,
          showFastJumpHud,
          showMute,
          showPlaybackRate,
          showVolume,
          showLongPressFastForward,
          showResumeSuspended
        };
      }
      function usePlaybackRate(ctx) {
        const NORMAL_RATE = 1;
        const MIN_RATE = 0.3;
        const MAX_RATE = 15;
        const rateOptions = shallowRef([
          MIN_RATE,
          0.5,
          0.7,
          NORMAL_RATE,
          1.3,
          1.5,
          1.7,
          2,
          3,
          5,
          10,
          MAX_RATE
        ]);
        const current = ctx.rootPropsVm.playbackRate;
        const currentRateIndex = computed(() => rateOptions.value.findIndex((r) => r === current.value) ?? -1);
        const fastForward = shallowRef(false);
        const set = (rate) => {
          var _a;
          (_a = ctx.playerCore.value) == null ? void 0 : _a.setPlaybackRate(rate);
        };
        const setByIndex = (index) => {
          if (index < 0 || index >= rateOptions.value.length)
            return;
          const newRate = rateOptions.value[index];
          set(newRate);
        };
        const up = () => {
          setByIndex(currentRateIndex.value + 1);
        };
        const down = () => {
          setByIndex(currentRateIndex.value - 1);
        };
        const downWithLowerLimit = () => {
          if (current.value <= NORMAL_RATE)
            return;
          setByIndex(currentRateIndex.value - 1);
        };
        const holdPlaybackRate = shallowRef(1);
        const startLongPressFastForward = () => {
          if (!ctx.playerCore.value || fastForward.value)
            return;
          fastForward.value = true;
          set(MAX_RATE);
          holdPlaybackRate.value = current.value;
          if (ctx.playerCore.value.paused) {
            ctx.playerCore.value.play();
          }
        };
        const stopLongPressFastForward = () => {
          if (!ctx.playerCore.value)
            return;
          fastForward.value = false;
          set(holdPlaybackRate.value);
        };
        return {
          MIN_RATE,
          MAX_RATE,
          NORMAL_RATE,
          current,
          rateOptions,
          fastForward,
          set,
          up,
          down,
          downWithLowerLimit,
          startLongPressFastForward,
          stopLongPressFastForward
        };
      }
      function usePopupManager(ctx) {
        const popups = reactive(/* @__PURE__ */ new Map());
        const disabledBubblingElements = /* @__PURE__ */ new Set();
        const registerPopup = (id, popup) => {
          popups.set(id, popup);
        };
        const unregisterPopup = (id) => {
          popups.delete(id);
        };
        const setPopupVisible = (id, visible) => {
          const popup = popups.get(id);
          if (popup) {
            popup.visible = visible;
          }
        };
        const hasOpenPopup = computed(() => Array.from(popups.values()).some((popup) => popup.visible && popup.allowPreventControlsClose));
        const addDisabledBubblingElement = (element) => {
          disabledBubblingElements.add(element);
        };
        const removeDisabledBubblingElement = (element) => {
          disabledBubblingElements.delete(element);
        };
        watch(hasOpenPopup, (value) => {
          if (value) {
            ctx.controls.addDisabledAutoHide();
            ctx.controls.setDisabledHideOnMouseLeave(true);
          } else {
            ctx.controls.removeDisabledAutoHide();
            ctx.controls.setDisabledHideOnMouseLeave(false);
          }
        });
        return {
          hasOpenPopup,
          disabledBubblingElements,
          registerPopup,
          unregisterPopup,
          setPopupVisible,
          addDisabledBubblingElement,
          removeDisabledBubblingElement
        };
      }
      function useProgressBar(_ctx) {
        const isDragging = shallowRef(false);
        const isLongPressDragging = shallowRef(false);
        let longPressTimer = null;
        const LONG_PRESS_THRESHOLD = 300;
        watch(isDragging, (newValue, oldValue) => {
          if (newValue && !oldValue) {
            longPressTimer = setTimeout(() => {
              isLongPressDragging.value = true;
            }, LONG_PRESS_THRESHOLD);
          } else if (!newValue && oldValue) {
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
            isLongPressDragging.value = false;
          }
        });
        const waitDragEnd = () => {
          return new Promise((resolve) => {
            const unwatch = watch(isDragging, (value) => {
              if (!value) {
                resolve(true);
                unwatch();
              }
            });
          });
        };
        return {
          isDragging,
          isLongPressDragging,
          waitDragEnd
        };
      }
      const VideoSourceExtension = {
        m3u8: "m3u8",
        mkv: "mkv",
        unknown: "unknown"
      };
      function useSources(ctx) {
        const playerElementRef = ctx.refs.playerElementRef;
        const playerCore = ctx == null ? void 0 : ctx.playerCore;
        const list = ctx.rootProps.sources;
        const current = ref(null);
        const isInterrupt = shallowRef(false);
        const isSwitching = shallowRef(false);
        const getHlsSource = () => {
          return list.value.find((item) => item.type === "hls");
        };
        const getPreferredVideoSource = async () => {
          if (list.value.length === 0) {
            return null;
          }
          const videoId = ctx.rootProps.videoId;
          if (!videoId) {
            return list.value[0];
          }
          try {
            const preference = await qualityPreferenceCache.getPreference(videoId);
            if (!preference) {
              return list.value[0];
            }
            const preferredSource = list.value.find((source) => source.quality === preference.quality);
            if (preferredSource) {
              console.log(`🎞️ 使用保存的画质偏好: ${preference.quality}P (${preference.displayQuality || preference.quality})`);
              return preferredSource;
            } else {
              console.warn(`⚠️ 保存的画质偏好 ${preference.quality}P 不存在，使用默认最高画质`);
              return list.value[0];
            }
          } catch (error) {
            console.error("获取画质偏好失败，使用默认最高画质:", error);
            return list.value[0];
          }
        };
        const getDefaultPlayerCore = (source) => {
          if (source.type === "hls") {
            return PlayerCoreType.Hls;
          }
          if ([VideoSourceExtension.mkv].includes(source.extension)) {
            return PlayerCoreType.AvPlayer;
          }
          return PlayerCoreType.Native;
        };
        const initializeVideo = async (source, playerCoreType, lastTime) => {
          var _a, _b;
          if (!ctx.driver) {
            throw new Error("videoDriver is not found");
          }
          current.value = source;
          try {
            await ((_a = ctx.driver) == null ? void 0 : _a.switchDriver(playerCoreType ?? getDefaultPlayerCore(source)));
            if (!playerCore.value) {
              throw new Error("player is not found");
            }
            if (!playerElementRef.value) {
              throw new Error("playerElementRef is not found");
            }
            await playerCore.value.init(playerElementRef.value);
            await playerCore.value.load(source.url, lastTime ?? 0);
          } catch (error) {
            if (error instanceof DOMException && error.name === "AbortError") {
              return;
            }
            if (error instanceof Error) {
              const hlsSource = getHlsSource();
              if (hlsSource && ((_b = playerCore == null ? void 0 : playerCore.value) == null ? void 0 : _b.type) !== PlayerCoreType.Hls) {
                await initializeVideo(hlsSource, void 0, lastTime ?? 0);
              }
              return;
            }
            throw error;
          }
        };
        const changeQuality = async (source) => {
          if (!playerCore.value) {
            throw new Error("player is not found");
          }
          const currentTime = playerCore.value.currentTime || 0;
          const videoId = ctx.rootProps.videoId;
          if (videoId) {
            try {
              await qualityPreferenceCache.setPreference(videoId, source.quality, source.displayQuality);
              console.log(`💾 画质偏好已保存: ${source.quality}P (${source.displayQuality || source.quality})`);
            } catch (error) {
              console.error("保存画质偏好失败:", error);
            }
          }
          await initializeVideo(source);
          playerCore.value.seek(currentTime);
        };
        const interruptSource = () => {
          isInterrupt.value = true;
          if (playerCore.value) {
            playerCore.value.destroy().catch((e) => console.error("销毁播放器失败:", e));
          }
        };
        const resumeSource = () => {
          isInterrupt.value = false;
          initializeVideo(current.value);
        };
        const switchPlayerCoreImpl = async (type) => {
          var _a, _b;
          if (isSwitching.value) {
            console.warn("正在切换播放器核心，忽略此次操作");
            return;
          }
          if (!current.value) {
            throw new Error("当前没有视频源");
          }
          isSwitching.value = true;
          try {
            const currentTime = ((_a = playerCore.value) == null ? void 0 : _a.currentTime) || 0;
            const wasPaused = ((_b = playerCore.value) == null ? void 0 : _b.paused) ?? true;
            if (playerCore.value && !playerCore.value.paused) {
              await playerCore.value.pause();
            }
            await initializeVideo(current.value, type);
            if (playerCore.value) {
              await playerCore.value.seek(currentTime);
              if (!wasPaused) {
                await playerCore.value.play();
              }
            }
          } finally {
            isSwitching.value = false;
          }
        };
        const switchPlayerCore = useDebounceFn(switchPlayerCoreImpl, 300);
        watch(list, async () => {
          var _a;
          isInterrupt.value = false;
          if (list.value.length === 0) {
            await ((_a = ctx.playerCore.value) == null ? void 0 : _a.destroy());
            return;
          }
          const preferredSource = await getPreferredVideoSource();
          if (preferredSource) {
            await initializeVideo(preferredSource, void 0, toValue(ctx.rootProps.lastTime));
          }
        }, { immediate: true, deep: true });
        return {
          list,
          current,
          changeQuality,
          interruptSource,
          resumeSource,
          isInterrupt,
          isSwitching,
          switchPlayerCore
        };
      }
      function useThumbnailSettings(ctx) {
        const toggleAutoLoad = () => {
          ctx.rootPropsVm.autoLoadThumbnails.value = !ctx.rootPropsVm.autoLoadThumbnails.value;
        };
        const setSamplingInterval = (interval) => {
          ctx.rootPropsVm.thumbnailsSamplingInterval.value = interval;
        };
        return {
          // 状态
          autoLoadThumbnails: ctx.rootPropsVm.autoLoadThumbnails,
          samplingInterval: ctx.rootPropsVm.thumbnailsSamplingInterval,
          // 方法
          toggleAutoLoad,
          setSamplingInterval
        };
      }
      function calculateScale(videoWidth, videoHeight, containerWidth, containerHeight, angle) {
        const ratio = videoWidth / videoHeight;
        const radians = angle * Math.PI / 180;
        const cos = Math.abs(Math.cos(radians));
        const sin = Math.abs(Math.sin(radians));
        const rotatedWidth = containerWidth * cos + containerHeight * sin;
        const rotatedHeight = containerWidth * sin + containerHeight * cos;
        const scaleW = containerWidth / rotatedWidth;
        const scaleH = containerHeight / rotatedHeight;
        return ratio > 1 ? Math.min(scaleW, scaleH) : Math.max(scaleW, scaleH);
      }
      function useTransform(_ctx) {
        const ROTATE_ANGLE = 90;
        const MAX_ROTATE_ANGLE = 270;
        const rotate = shallowRef(0);
        const flipX = shallowRef(false);
        const flipY = shallowRef(false);
        const playerSize = useElementSize(_ctx.refs.playerElementRef);
        const scale = computed(() => {
          var _a, _b;
          return calculateScale(((_a = _ctx.playerCore.value) == null ? void 0 : _a.videoWidth) ?? 16, ((_b = _ctx.playerCore.value) == null ? void 0 : _b.videoHeight) ?? 9, playerSize.width.value, playerSize.height.value, rotate.value);
        });
        const style = computed(() => {
          const transforms = [
            `rotate(${rotate.value}deg)`,
            `scale(${scale.value * (flipX.value ? -1 : 1)}, ${scale.value * (flipY.value ? -1 : 1)})`,
            "translateZ(0)"
          ];
          return {
            transform: transforms.join(" ")
          };
        });
        const isLeftDisabled = computed(() => {
          return rotate.value === -MAX_ROTATE_ANGLE;
        });
        const isRightDisabled = computed(() => {
          return rotate.value === MAX_ROTATE_ANGLE;
        });
        const savePreference = async () => {
          const videoId = _ctx.rootProps.videoId;
          if (videoId) {
            try {
              await transformPreferenceCache.setPreference(videoId, rotate.value, flipX.value, flipY.value);
              console.log(`💾 旋转翻转偏好已保存: 旋转 ${rotate.value}°，水平翻转 ${flipX.value}，垂直翻转 ${flipY.value}`);
            } catch (error) {
              console.error("保存旋转翻转偏好失败:", error);
            }
          }
        };
        const loadPreference = async () => {
          const videoId = _ctx.rootProps.videoId;
          if (videoId) {
            try {
              const preference = await transformPreferenceCache.getPreference(videoId);
              if (preference) {
                rotate.value = preference.rotate;
                flipX.value = preference.flipX;
                flipY.value = preference.flipY;
                console.log(`🎞️ 使用保存的旋转翻转偏好: 旋转 ${preference.rotate}°，水平翻转 ${preference.flipX}，垂直翻转 ${preference.flipY}`);
              }
            } catch (error) {
              console.error("加载旋转翻转偏好失败:", error);
            }
          }
        };
        const left = () => {
          if (rotate.value <= -MAX_ROTATE_ANGLE)
            return;
          const newAngle = rotate.value - ROTATE_ANGLE;
          rotate.value = Math.max(newAngle, -MAX_ROTATE_ANGLE);
        };
        const right = () => {
          if (rotate.value >= MAX_ROTATE_ANGLE)
            return;
          const newAngle = rotate.value + ROTATE_ANGLE;
          rotate.value = Math.min(newAngle, MAX_ROTATE_ANGLE);
        };
        const normal = () => {
          rotate.value = 0;
          flipX.value = false;
          flipY.value = false;
        };
        const toggleFlipX = () => {
          flipX.value = !flipX.value;
        };
        const toggleFlipY = () => {
          flipY.value = !flipY.value;
        };
        watchEffect(() => {
          const videoId = _ctx.rootProps.videoId;
          if (videoId) {
            loadPreference();
          }
        });
        watch([rotate, flipX, flipY], () => {
          setTimeout(() => {
            savePreference();
          }, 100);
        });
        return {
          rotate,
          flipX,
          flipY,
          left,
          right,
          normal,
          toggleFlipX,
          toggleFlipY,
          isLeftDisabled,
          isRightDisabled,
          transformStyle: style
        };
      }
      const PlayerSymbol = Symbol("XPlayer");
      function usePlayerProvide(refs, rootProps, rootEmit) {
        const context = {
          refs: {
            rootRef: refs.rootRef,
            playerElementRef: refs.playerElementRef
          },
          rootEmit,
          rootProps,
          rootPropsVm: useVModels(rootProps, rootEmit),
          playerCore: ref()
        };
        context.driver = useSwitchPlayerCore(context);
        const popupManager = usePopupManager(context);
        context.popupManager = popupManager;
        const playbackRate = usePlaybackRate(context);
        context.playbackRate = playbackRate;
        const fullscreen = useFullscreen(context);
        context.fullscreen = fullscreen;
        const progressBar = useProgressBar();
        context.progressBar = progressBar;
        const controls = useControls(context);
        context.controls = controls;
        const source = useSources(context);
        context.source = source;
        const hotKey = useHotKey(context);
        context.hotKey = hotKey;
        const transform = useTransform(context);
        context.transform = transform;
        const thumbnailSettings = useThumbnailSettings(context);
        context.thumbnailSettings = thumbnailSettings;
        const hud = useHud(context);
        context.hud = hud;
        const cssVar = useCssVar(context);
        context.cssVar = cssVar;
        provide(PlayerSymbol, context);
        return context;
      }
      function usePlayerContext() {
        const context = inject(PlayerSymbol);
        if (!context) {
          throw new Error("usePlayerContext must be used within a VideoPlayer component");
        }
        return context;
      }
      const PortalSymbol = Symbol("XPlayerPortal");
      function usePortalProvider() {
        const container = ref();
        const context = {
          container
        };
        provide(PortalSymbol, context);
        return context;
      }
      function usePortal() {
        const context = inject(PortalSymbol);
        if (!context) {
          throw new Error("usePortal must be used within a XPlayer component");
        }
        return context;
      }
      const triggerSet = /* @__PURE__ */ new Set();
      function isInContainsTrigger(event, elm) {
        if (!elm)
          return false;
        return elm.contains(event.target);
      }
      const _sfc_main$r = /* @__PURE__ */ defineComponent({
        ...{
          inheritAttrs: false
        },
        __name: "index",
        props: {
          visible: { type: Boolean },
          x: { default: 0 },
          y: { default: 0 },
          trigger: {},
          placement: {},
          offset: {},
          outsideStopPropagation: { type: Boolean, default: false },
          allowPreventControlsClose: { type: Boolean, default: true }
        },
        emits: ["update:visible", "after-leave"],
        setup(__props, { emit: __emit }) {
          const props = __props;
          const emit = __emit;
          const styles = {
            popup: "x-popup bg-base-100/90 rounded-2xl p-2 border border-neutral-950 relative overflow-hidden"
          };
          const { container } = usePortal();
          const { popupManager } = usePlayerContext();
          const visibleModel = useVModel(props, "visible", emit);
          const popupRef = shallowRef();
          const position = shallowRef({
            x: 0,
            y: 0
          });
          const portalContainer = computed(() => container.value || "body");
          const portalContainerEl = computed(() => {
            if (typeof portalContainer.value === "string") {
              return document.querySelector(portalContainer.value) ?? void 0;
            }
            return portalContainer.value;
          });
          const style = computed(() => ({
            left: `${position.value.x}px`,
            top: `${position.value.y}px`,
            position: container.value ? "absolute" : "fixed"
          }));
          const portalContainerBounding = useElementBounding(portalContainerEl);
          const popupId = `popup-${Math.random().toString(36).substr(2, 9)}`;
          watch(visibleModel, (newVisible) => {
            popupManager == null ? void 0 : popupManager.setPopupVisible(popupId, newVisible);
          });
          onMounted(() => {
            popupManager == null ? void 0 : popupManager.registerPopup(popupId, {
              visible: visibleModel.value,
              trigger: props.trigger,
              container: popupRef.value,
              portalContainer: portalContainerEl.value,
              allowPreventControlsClose: props.allowPreventControlsClose
            });
          });
          onUnmounted(() => {
            popupManager == null ? void 0 : popupManager.unregisterPopup(popupId);
          });
          function getPosition(trigger, popup, portal) {
            if (!trigger) {
              return {
                x: props.x,
                y: props.y
              };
            }
            if (!popup || !portal)
              return { x: 0, y: 0 };
            const triggerRect = trigger.getBoundingClientRect();
            const popupRect = popup.getBoundingClientRect();
            const portalRect = portal.getBoundingClientRect();
            const triggerLeft = triggerRect.left - portalRect.left;
            const triggerWidth = triggerRect.width;
            const triggerTop = triggerRect.top - portalRect.top;
            const triggerBottom = triggerRect.bottom - portalRect.top;
            const spaceBelow = portalRect.height - triggerBottom;
            const spaceAbove = triggerTop;
            const offset = props.offset ?? 8;
            let y;
            if (props.placement === "top" || props.placement !== "bottom" && spaceBelow < popupRect.height && spaceAbove >= popupRect.height) {
              y = triggerTop - popupRect.height - offset;
            } else {
              y = triggerBottom + offset;
            }
            let x = triggerLeft + triggerWidth / 2 - popupRect.width / 2;
            x = Math.max(16, x);
            x = Math.min(x, portalRect.width - popupRect.width - 16);
            return { x, y };
          }
          function updatePosition() {
            const positionNew = getPosition(
              props.trigger,
              popupRef.value,
              portalContainerEl.value
            );
            position.value = positionNew;
          }
          const onEnter = () => {
            updatePosition();
          };
          watch(
            () => portalContainerBounding,
            () => {
              visibleModel.value && updatePosition();
            },
            {
              deep: true
            }
          );
          watch(
            () => props.trigger,
            (newVal, oldVal) => {
              if (newVal && !triggerSet.has(newVal)) {
                triggerSet.add(newVal);
              }
              if (!newVal && oldVal && triggerSet.has(oldVal)) {
                triggerSet.delete(oldVal);
              }
            }
          );
          onClickOutside(popupRef, (event) => {
            if (visibleModel.value) {
              if (props.trigger && isInContainsTrigger(event, props.trigger)) {
                event.stopPropagation();
              }
              if (props.outsideStopPropagation) {
                event.stopPropagation();
              }
              if (popupManager == null ? void 0 : popupManager.disabledBubblingElements.has(event.target)) {
                event.stopPropagation();
              }
              visibleModel.value = false;
            }
          });
          const onAfterLeave = () => {
            emit("after-leave");
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: portalContainer.value,
              disabled: !portalContainer.value
            }, [
              createVNode(Transition, {
                "enter-active-class": "transition-opacity duration-200",
                "leave-active-class": "transition-opacity duration-200",
                "enter-from-class": "opacity-0",
                "leave-to-class": "opacity-0",
                onEnter,
                onAfterLeave
              }, {
                default: withCtx(() => [
                  withDirectives(createElementVNode("div", mergeProps({
                    ref_key: "popupRef",
                    ref: popupRef,
                    class: styles.popup,
                    style: style.value
                  }, _ctx.$attrs), [
                    renderSlot(_ctx.$slots, "default", {}, void 0, true)
                  ], 16), [
                    [vShow, unref(visibleModel)]
                  ])
                ]),
                _: 3
              })
            ], 8, ["to", "disabled"]);
          };
        }
      });
      const _export_sfc = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const Popup = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__scopeId", "data-v-935c5311"]]);
      const _hoisted_1$c = ["value", "min", "max"];
      const _sfc_main$q = /* @__PURE__ */ defineComponent({
        __name: "index",
        setup(__props) {
          const styles = {
            popup: "left-4! top-4! shadow-xs/90",
            wrap: "flex items-center gap-2 px-2",
            content: "flex flex-col gap-1 flex-1 px-1",
            icon: "size-6",
            title: "text-sm font-semibold",
            progress: "progress progress-primary h-1 w-35",
            value: "text-sm font-semibold text-base-content/70"
          };
          const { hud } = usePlayerContext();
          const showMessage = ref(false);
          const displayMessage = ref(null);
          const message = computed(() => {
            return (hud == null ? void 0 : hud.messages.value[0]) || null;
          });
          watch(message, (newMessage) => {
            if (newMessage) {
              displayMessage.value = newMessage;
              showMessage.value = true;
            } else {
              showMessage.value = false;
            }
          });
          function onPopupAfterLeave() {
            displayMessage.value = null;
          }
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Popup, {
              class: normalizeClass(styles.popup),
              visible: showMessage.value,
              x: 0,
              y: 0,
              "allow-prevent-controls-close": false,
              onAfterLeave: onPopupAfterLeave
            }, {
              default: withCtx(() => [
                displayMessage.value ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(styles.wrap)
                }, [
                  displayMessage.value.icon ? (openBlock(), createBlock(unref(Icon), {
                    key: 0,
                    class: normalizeClass([styles.icon, displayMessage.value.iconClass]),
                    icon: displayMessage.value.icon
                  }, null, 8, ["class", "icon"])) : createCommentVNode("", true),
                  createElementVNode("div", {
                    class: normalizeClass(styles.content)
                  }, [
                    displayMessage.value.title ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(styles.title)
                    }, toDisplayString(displayMessage.value.title ?? ""), 3)) : createCommentVNode("", true),
                    displayMessage.value && displayMessage.value.progress ? (openBlock(), createElementBlock("progress", {
                      key: 1,
                      class: normalizeClass(styles.progress),
                      value: displayMessage.value.progress.value,
                      min: displayMessage.value.progress.min,
                      max: displayMessage.value.progress.max
                    }, null, 10, _hoisted_1$c)) : createCommentVNode("", true),
                    displayMessage.value.value ? (openBlock(), createElementBlock("div", {
                      key: 2,
                      class: normalizeClass(styles.value)
                    }, toDisplayString(displayMessage.value.value), 3)) : createCommentVNode("", true)
                  ], 2)
                ], 2)) : createCommentVNode("", true)
              ]),
              _: 1
            }, 8, ["class", "visible"]);
          };
        }
      });
      const _sfc_main$p = /* @__PURE__ */ defineComponent({
        __name: "index",
        setup(__props) {
          const styles = {
            container: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex flex-col items-center gap-2 drop-shadow-xl/30",
            animation: {
              wrapper: "inline-flex items-center justify-between gap-2.5",
              dot: ["w-2.5 h-2.5 bg-white rounded-full", "loading-dot-bounce"],
              dot1: "loading-dot-delay-1",
              dot2: "loading-dot-delay-2",
              dot3: "loading-dot-delay-3"
            },
            speed: "text-sm font-semibold text-base-content"
          };
          const { playerCore } = usePlayerContext();
          return (_ctx, _cache) => {
            var _a, _b, _c;
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(styles.container)
            }, [
              createElementVNode("div", {
                class: normalizeClass(styles.animation.wrapper)
              }, [
                createElementVNode("span", {
                  class: normalizeClass([styles.animation.dot, styles.animation.dot1])
                }, null, 2),
                createElementVNode("span", {
                  class: normalizeClass([styles.animation.dot, styles.animation.dot2])
                }, null, 2),
                createElementVNode("span", {
                  class: normalizeClass([styles.animation.dot, styles.animation.dot3])
                }, null, 2)
              ], 2),
              ((_a = unref(playerCore)) == null ? void 0 : _a.type) === unref(PlayerCoreType).AvPlayer && (((_b = unref(playerCore).stats) == null ? void 0 : _b.bandwidth) ?? 0) > 0 ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(styles.speed)
              }, toDisplayString(Math.round((((_c = unref(playerCore).stats) == null ? void 0 : _c.bandwidth) ?? 0) / 1024 / 1024 * 100) / 100) + " Mbps/s ", 3)) : createCommentVNode("", true)
            ], 2);
          };
        }
      });
      const Loading = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-c8313f62"]]);
      const _sfc_main$o = /* @__PURE__ */ defineComponent({
        __name: "index",
        setup(__props) {
          const styles = {
            container: [
              "absolute inset-0 m-auto",
              "flex items-center justify-center",
              "size-20 bg-black/30 rounded-full drop-shadow-xs/60"
            ],
            icon: "size-[61.8%]"
          };
          const { playerCore } = usePlayerContext();
          const visible = shallowRef(false);
          const isShowPause = shallowRef(false);
          const shouldAnimate = shallowRef(false);
          const animationClass = computed(() => {
            if (shouldAnimate.value) {
              return "animate-[fadeOut_350ms_linear_forwards]";
            }
            return "";
          });
          function showPlayButton() {
            visible.value = true;
            isShowPause.value = false;
            shouldAnimate.value = false;
          }
          function showAnimationButton(paused) {
            visible.value = true;
            isShowPause.value = paused;
            shouldAnimate.value = true;
            setTimeout(() => {
              visible.value = false;
              shouldAnimate.value = false;
            }, 300);
          }
          function hideButton() {
            visible.value = false;
            shouldAnimate.value = false;
          }
          watch(
            () => {
              var _a;
              return (_a = playerCore.value) == null ? void 0 : _a.canplay;
            },
            (value) => {
              var _a;
              if (value) {
                if ((_a = playerCore == null ? void 0 : playerCore.value) == null ? void 0 : _a.paused) {
                  showPlayButton();
                }
              } else {
                hideButton();
              }
            }
          );
          watch(
            () => {
              var _a;
              return (_a = playerCore == null ? void 0 : playerCore.value) == null ? void 0 : _a.paused;
            },
            (value) => {
              var _a;
              if (!((_a = playerCore == null ? void 0 : playerCore.value) == null ? void 0 : _a.canplay)) {
                return;
              }
              showAnimationButton(!!value);
            }
          );
          return (_ctx, _cache) => {
            return visible.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass([styles.container, animationClass.value])
            }, [
              createVNode(unref(Icon), {
                icon: isShowPause.value ? unref(ICON_PASUE) : unref(ICON_PLAY),
                class: normalizeClass(styles.icon)
              }, null, 8, ["icon", "class"])
            ], 2)) : createCommentVNode("", true);
          };
        }
      });
      function useControlsMouseDetection(elementRef) {
        const { controls } = usePlayerContext();
        const { isOutside } = useMouseInElement(elementRef);
        const hasAddedDisabled = shallowRef(false);
        const stop = watchEffect(() => {
          if (!isOutside.value) {
            if (!hasAddedDisabled.value) {
              controls.addDisabledAutoHide();
              hasAddedDisabled.value = true;
            }
            return () => {
              if (hasAddedDisabled.value) {
                controls.removeDisabledAutoHide();
                hasAddedDisabled.value = false;
              }
            };
          }
          if (hasAddedDisabled.value) {
            controls.removeDisabledAutoHide();
            hasAddedDisabled.value = false;
          }
          return () => {
          };
        });
        onUnmounted(() => {
          stop();
          if (hasAddedDisabled.value) {
            controls.removeDisabledAutoHide();
            hasAddedDisabled.value = false;
          }
        });
        return {
          isOutside
        };
      }
      const _hoisted_1$b = ["disabled"];
      const _hoisted_2$8 = ["disabled", "onClick"];
      const _sfc_main$n = /* @__PURE__ */ defineComponent({
        __name: "AudioTrackButton",
        setup(__props) {
          const styles = {
            ...controlStyles
          };
          const { playerCore } = usePlayerContext();
          const menuVisible = shallowRef(false);
          const buttonRef = shallowRef();
          function toggleVisible() {
            menuVisible.value = !menuVisible.value;
          }
          return (_ctx, _cache) => {
            var _a, _b, _c;
            return openBlock(), createElementBlock(Fragment, null, [
              createElementVNode("button", {
                ref_key: "buttonRef",
                ref: buttonRef,
                class: normalizeClass([styles.btn.root]),
                disabled: !((_a = unref(playerCore)) == null ? void 0 : _a.canplay) || ((_b = unref(playerCore)) == null ? void 0 : _b.type) !== unref(PlayerCoreType).AvPlayer,
                "data-tip": "音频轨道",
                onClick: toggleVisible
              }, [
                createVNode(unref(Icon), {
                  class: normalizeClass([styles.btn.icon]),
                  icon: unref(ICON_AUDIO_TRACK)
                }, null, 8, ["class", "icon"])
              ], 10, _hoisted_1$b),
              ((_c = unref(playerCore)) == null ? void 0 : _c.type) === unref(PlayerCoreType).AvPlayer ? (openBlock(), createBlock(Popup, {
                key: 0,
                visible: menuVisible.value,
                "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => menuVisible.value = $event),
                trigger: buttonRef.value,
                placement: "top"
              }, {
                default: withCtx(() => [
                  createElementVNode("ul", {
                    class: normalizeClass([styles.menu.root])
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(playerCore).audioStreams, (stream) => {
                      return openBlock(), createElementBlock("li", {
                        key: stream.id
                      }, [
                        createElementVNode("a", {
                          class: normalizeClass([styles.menu.a, {
                            [styles.menu.active]: unref(playerCore).audioStreamId === stream.id
                          }]),
                          disabled: !unref(playerCore).isSupportStream(stream),
                          onClick: ($event) => unref(playerCore).setAudioStream(stream.id)
                        }, [
                          createElementVNode("span", {
                            class: normalizeClass([styles.menu.label])
                          }, toDisplayString(stream.id) + ". " + toDisplayString(stream.metadata.title ?? "Untitled"), 3),
                          createElementVNode("span", {
                            class: normalizeClass([styles.menu.desc])
                          }, toDisplayString(stream.metadata.language), 3)
                        ], 10, _hoisted_2$8)
                      ]);
                    }), 128))
                  ], 2)
                ]),
                _: 1
              }, 8, ["visible", "trigger"])) : createCommentVNode("", true)
            ], 64);
          };
        }
      });
      const _sfc_main$m = /* @__PURE__ */ defineComponent({
        __name: "FullscreenButton",
        setup(__props) {
          const { fullscreen } = usePlayerContext();
          const icon = computed(() => {
            return fullscreen.isFullscreen.value ? "material-symbols:fullscreen-exit-rounded" : "material-symbols:fullscreen-rounded";
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("button", {
              class: normalizeClass(["btn btn-ghost btn-circle tooltip", { "swap-active": !unref(fullscreen).isFullscreen.value }]),
              "data-tip": "全屏 (F)",
              onClick: _cache[0] || (_cache[0] = //@ts-ignore
              (...args) => unref(fullscreen).toggleFullscreen && unref(fullscreen).toggleFullscreen(...args))
            }, [
              createVNode(unref(Icon), {
                class: "size-7",
                icon: icon.value
              }, null, 8, ["icon"])
            ], 2);
          };
        }
      });
      const _hoisted_1$a = ["disabled"];
      const _hoisted_2$7 = ["onClick"];
      const _sfc_main$l = /* @__PURE__ */ defineComponent({
        __name: "PlaybackRateButton",
        setup(__props) {
          const styles = {
            ...controlStyles
          };
          const { playbackRate, playerCore } = usePlayerContext();
          const rateOptions = computed(
            () => [...playbackRate.rateOptions.value].reverse()
          );
          const menuVisible = shallowRef(false);
          const buttonRef = ref();
          const buttonText = computed(() => {
            return playbackRate.current.value === 1 ? "倍速" : `${playbackRate.current.value}X`;
          });
          function toggleSpeedMenu() {
            menuVisible.value = !menuVisible.value;
          }
          function handleSpeedChange(rate) {
            playbackRate.set(rate);
            menuVisible.value = false;
          }
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock(Fragment, null, [
              createElementVNode("button", {
                ref_key: "buttonRef",
                ref: buttonRef,
                class: normalizeClass([styles.btnText.root]),
                disabled: !((_a = unref(playerCore)) == null ? void 0 : _a.canplay),
                "data-tip": "倍速 (ArrowUp/ArrowDown)",
                onClick: toggleSpeedMenu
              }, toDisplayString(buttonText.value), 11, _hoisted_1$a),
              createVNode(Popup, {
                visible: menuVisible.value,
                "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => menuVisible.value = $event),
                trigger: buttonRef.value,
                placement: "top"
              }, {
                default: withCtx(() => [
                  createElementVNode("ul", {
                    class: normalizeClass([styles.menu.root])
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(rateOptions.value, (rate) => {
                      return openBlock(), createElementBlock("li", {
                        key: rate,
                        onClick: ($event) => handleSpeedChange(rate)
                      }, [
                        createElementVNode("a", {
                          class: normalizeClass([styles.menu.a, {
                            [styles.menu.active]: unref(playbackRate).current.value === rate
                          }])
                        }, toDisplayString(rate), 3)
                      ], 8, _hoisted_2$7);
                    }), 128))
                  ], 2)
                ]),
                _: 1
              }, 8, ["visible", "trigger"])
            ], 64);
          };
        }
      });
      const _hoisted_1$9 = ["disabled"];
      const _sfc_main$k = /* @__PURE__ */ defineComponent({
        __name: "PlayButton",
        setup(__props) {
          const styles = {
            btn: {
              ...controlStyles.btn,
              root: [controlStyles.btn.root, "before:ml-8"]
            }
          };
          const { playerCore } = usePlayerContext();
          return (_ctx, _cache) => {
            var _a, _b;
            return openBlock(), createElementBlock("button", {
              class: normalizeClass(["swap swap-rotate", [
                styles.btn.root,
                {
                  "swap-active": (_a = unref(playerCore)) == null ? void 0 : _a.paused
                }
              ]]),
              disabled: !((_b = unref(playerCore)) == null ? void 0 : _b.canplay),
              "data-tip": "播放/暂停 (Space)",
              onClick: _cache[0] || (_cache[0] = //@ts-ignore
              (...args) => {
                var _a2, _b2;
                return ((_a2 = unref(playerCore)) == null ? void 0 : _a2.togglePlay) && ((_b2 = unref(playerCore)) == null ? void 0 : _b2.togglePlay(...args));
              })
            }, [
              createVNode(unref(Icon), {
                icon: unref(ICON_PASUE),
                class: normalizeClass(["swap-off", [
                  styles.btn.icon
                ]])
              }, null, 8, ["icon", "class"]),
              createVNode(unref(Icon), {
                icon: unref(ICON_PLAY),
                class: normalizeClass(["swap-on", [
                  styles.btn.icon
                ]])
              }, null, 8, ["icon", "class"])
            ], 10, _hoisted_1$9);
          };
        }
      });
      const _hoisted_1$8 = ["disabled"];
      const _hoisted_2$6 = ["onClick"];
      const _sfc_main$j = /* @__PURE__ */ defineComponent({
        __name: "PlayerCoreButton",
        setup(__props) {
          const styles = {
            ...controlStyles,
            btn: {
              ...controlStyles.btn,
              root: [controlStyles.btn.root, "btn-"]
            }
          };
          const { source, playerCore } = usePlayerContext();
          const menuVisible = shallowRef(false);
          const buttonRef = shallowRef();
          function toggleVisible() {
            menuVisible.value = !menuVisible.value;
          }
          return (_ctx, _cache) => {
            var _a, _b, _c, _d, _e, _f, _g;
            return openBlock(), createElementBlock(Fragment, null, [
              createElementVNode("button", {
                ref_key: "buttonRef",
                ref: buttonRef,
                class: normalizeClass([styles.btn.root]),
                "data-tip": "播放器核心",
                disabled: ((_c = (_b = (_a = unref(source)) == null ? void 0 : _a.current) == null ? void 0 : _b.value) == null ? void 0 : _c.type) === "hls" || ((_e = (_d = unref(source)) == null ? void 0 : _d.isSwitching) == null ? void 0 : _e.value),
                onClick: toggleVisible
              }, [
                createVNode(unref(Icon), {
                  class: normalizeClass(["transition-transform", [styles.btn.icon, {
                    "rotate-90": menuVisible.value,
                    "motion-safe:animate-spin": (_g = (_f = unref(source)) == null ? void 0 : _f.isSwitching) == null ? void 0 : _g.value
                  }]]),
                  icon: unref(ICON_PLAYER_CORE)
                }, null, 8, ["class", "icon"])
              ], 10, _hoisted_1$8),
              createVNode(Popup, {
                visible: menuVisible.value,
                "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => menuVisible.value = $event),
                trigger: buttonRef.value,
                placement: "top"
              }, {
                default: withCtx(() => [
                  createElementVNode("ul", {
                    class: normalizeClass([styles.menu.root])
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList([unref(PlayerCoreType).Native, unref(PlayerCoreType).AvPlayer], (type) => {
                      var _a2;
                      return openBlock(), createElementBlock("li", { key: type }, [
                        createElementVNode("a", {
                          class: normalizeClass([
                            styles.menu.a,
                            {
                              [styles.menu.active]: ((_a2 = unref(playerCore)) == null ? void 0 : _a2.type) === type
                            }
                          ]),
                          onClick: ($event) => (unref(source).switchPlayerCore(type), menuVisible.value = false)
                        }, toDisplayString(type), 11, _hoisted_2$6)
                      ]);
                    }), 128))
                  ], 2)
                ]),
                _: 1
              }, 8, ["visible", "trigger"])
            ], 64);
          };
        }
      });
      const _hoisted_1$7 = ["data-tip"];
      const _hoisted_2$5 = ["onClick"];
      const _hoisted_3$3 = { class: "flex flex-col" };
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        __name: "PlayModeButton",
        setup(__props) {
          const ctx = usePlayerContext();
          const currentMode = computed(() => {
            return ctx.rootProps.currentPlayMode ?? PlayMode.STOP;
          });
          const modes = Object.values(PlayMode);
          const buttonRef = shallowRef();
          const menuVisible = shallowRef(false);
          function toggleMenu() {
            menuVisible.value = !menuVisible.value;
          }
          function handleModeChange(mode) {
            const setPlayMode = ctx.rootProps.setPlayMode;
            if (setPlayMode) {
              setPlayMode(mode);
              menuVisible.value = false;
            } else {
              console.error("设置播放模式回调函数未提供");
            }
          }
          const styles = {
            ...controlStyles
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createElementVNode("button", {
                ref_key: "buttonRef",
                ref: buttonRef,
                class: normalizeClass([styles.btn.root]),
                "data-tip": unref(PLAY_MODE_NAMES)[currentMode.value] || "播放模式",
                onClick: toggleMenu
              }, [
                createVNode(unref(Icon), {
                  icon: unref(PLAY_MODE_ICONS)[currentMode.value] || "material-symbols:pause-rounded",
                  class: normalizeClass(styles.btn.icon)
                }, null, 8, ["icon", "class"])
              ], 10, _hoisted_1$7),
              createVNode(Popup, {
                visible: menuVisible.value,
                "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => menuVisible.value = $event),
                trigger: buttonRef.value,
                placement: "top"
              }, {
                default: withCtx(() => [
                  createElementVNode("ul", {
                    class: normalizeClass(styles.menu.root)
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(modes), (mode) => {
                      return openBlock(), createElementBlock("li", {
                        key: mode,
                        onClick: ($event) => handleModeChange(mode)
                      }, [
                        createElementVNode("a", {
                          class: normalizeClass([
                            styles.menu.a,
                            currentMode.value === mode && styles.menu.active
                          ])
                        }, [
                          createVNode(unref(Icon), {
                            icon: unref(PLAY_MODE_ICONS)[mode],
                            class: normalizeClass(styles.menu.icon)
                          }, null, 8, ["icon", "class"]),
                          createElementVNode("div", _hoisted_3$3, [
                            createElementVNode("span", {
                              class: normalizeClass(styles.menu.label)
                            }, toDisplayString(unref(PLAY_MODE_NAMES)[mode]), 3),
                            createElementVNode("span", {
                              class: normalizeClass(styles.menu.desc)
                            }, toDisplayString(unref(PLAY_MODE_DESCRIPTIONS)[mode]), 3)
                          ])
                        ], 2)
                      ], 8, _hoisted_2$5);
                    }), 128))
                  ], 2)
                ]),
                _: 1
              }, 8, ["visible", "trigger"])
            ], 64);
          };
        }
      });
      function boundary(value, min, max) {
        if (value < min) {
          return min;
        }
        if (value > max) {
          return max;
        }
        return value;
      }
      const _hoisted_1$6 = ["height"];
      const _hoisted_2$4 = { key: 0 };
      const _hoisted_3$2 = { key: 1 };
      const DEFAULT_WIDTH = 250;
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        __name: "index",
        props: {
          visible: { type: Boolean },
          position: {},
          time: {},
          progressBarWidth: {}
        },
        emits: ["seek"],
        setup(__props, { emit: __emit }) {
          const props = __props;
          const emit = __emit;
          const styles = {
            root: ["absolute top-0", "[will-change:transform]"],
            image: {
              root: [
                "relative flex items-center justify-center rounded-xl overflow-hidden mb-2",
                "bg-black shadow-xs/30",
                "cursor-pointer transition-all duration-550 ease-out",
                "hover:scale-[1.02]"
              ],
              pressing: "ring-4 ring-base-content/90",
              loading: "absolute loading loading-spinner size-12 m-auto rounded-full text-base-content/80",
              error: "absolute inset-0 flex items-center justify-center"
            },
            timeBox: {
              container: "text-sm py-0.5 text-neutral-300 subpixel-antialiased text-center select-none text-shadow-[0_0_1px_rgb(0_0_0_/0.5),0_0_2px_rgb(55_55_55_/0.7)]"
            }
          };
          const { rootProps, source, progressBar } = usePlayerContext();
          function ratioHeight(width, ratioWidth, ratioHeight2) {
            return width * ratioHeight2 / ratioWidth;
          }
          const DEFAULT_HEIGHT = ratioHeight(DEFAULT_WIDTH, 16, 9);
          const isHoveringImage = ref(false);
          const { onThumbnailRequest } = rootProps;
          const thumbnailCanvas = shallowRef(null);
          const thumbnailContainerSize = shallowRef({
            width: DEFAULT_WIDTH,
            height: DEFAULT_HEIGHT
          });
          const lastTimer = shallowRef(null);
          const thumb = reactive({
            // 最后一次 hover 时间
            lastHoverTime: -1,
            // 最后一次请求时间
            lastRequestTime: -1,
            // 渲染时间
            renderTime: -1,
            // 渲染图片
            renderImage: void 0,
            // 错误
            error: void 0
          });
          const previewTransform = shallowRef(-1);
          const boxVisible = computed(() => props.visible && previewTransform.value > -1);
          const ctx = computed(() => {
            var _a;
            return (_a = thumbnailCanvas.value) == null ? void 0 : _a.getContext("2d");
          });
          const loading = computed(
            () => thumb.lastRequestTime >= 0 && thumb.lastRequestTime === thumb.lastHoverTime
          );
          watch(
            () => [props.position],
            async () => {
              if (!props.visible) {
                previewTransform.value = -1;
                return;
              }
              if (props.progressBarWidth < 0) {
                previewTransform.value = -1;
                return;
              }
              const thumbnailWidth = thumbnailContainerSize.value.width;
              const offsetCenter = -(thumbnailWidth / 2);
              const offsetX = props.progressBarWidth * (props.position / 100);
              const offset = offsetCenter + offsetX;
              const min = 0;
              const max = props.progressBarWidth - thumbnailWidth;
              const result = boundary(offset, min, max);
              previewTransform.value = result;
            }
          );
          async function updateThumbnail(hoverTime, isLast) {
            if (lastTimer.value) {
              clearTimeout(lastTimer.value);
              lastTimer.value = null;
            }
            thumb.renderImage = void 0;
            if (!isLast) {
              lastTimer.value = setTimeout(() => {
                if (hoverTime === thumb.lastHoverTime) {
                  updateThumbnail(hoverTime, true);
                }
              }, 50);
            }
            try {
              const cacheImage = await (onThumbnailRequest == null ? void 0 : onThumbnailRequest({
                type: "Cache",
                time: hoverTime,
                isLast
              }));
              if (cacheImage) {
                thumb.renderImage = cacheImage;
                thumb.renderTime = hoverTime;
                if (isLast) {
                  thumb.lastRequestTime = -1;
                }
                thumb.error = void 0;
                return;
              }
              thumb.lastRequestTime = hoverTime;
              const newImage = await (onThumbnailRequest == null ? void 0 : onThumbnailRequest({
                type: "Must",
                time: hoverTime,
                isLast
              }));
              if (!newImage)
                return;
              if (hoverTime === thumb.lastHoverTime && isLast) {
                thumb.lastRequestTime = -1;
                thumb.renderImage = newImage;
                thumb.renderTime = hoverTime;
                thumb.error = void 0;
              }
            } catch (error) {
              thumb.error = error;
            }
          }
          watch(
            () => [props.visible, props.time],
            async () => {
              if (!onThumbnailRequest)
                return;
              if (!props.visible || !props.time) {
                thumb.lastHoverTime = -1;
                thumb.renderImage = void 0;
                return;
              }
              const hoverTime = props.time;
              thumb.lastHoverTime = hoverTime;
              await updateThumbnail(hoverTime, false);
            }
          );
          watch(
            () => [thumb.renderImage, thumb.error],
            () => {
              if (thumb.error) {
                return;
              }
              if (thumbnailCanvas.value && ctx.value) {
                requestAnimationFrame(() => {
                  if (!ctx.value) {
                    throw new Error("ctx not found");
                  }
                  ctx.value.clearRect(0, 0, DEFAULT_WIDTH, DEFAULT_HEIGHT);
                  if (thumb.renderImage && thumb.renderTime === thumb.lastHoverTime) {
                    const imgWidth = thumb.renderImage.img.width;
                    const imgHeight = thumb.renderImage.img.height;
                    const { width: resizeWidth, height: resizeHeight } = getImageResize(
                      imgWidth,
                      imgHeight,
                      DEFAULT_WIDTH,
                      DEFAULT_HEIGHT
                    );
                    const dx = (DEFAULT_WIDTH - resizeWidth) / 2;
                    const dy = (DEFAULT_HEIGHT - resizeHeight) / 2;
                    ctx.value.fillStyle = "#000";
                    ctx.value.fillRect(0, 0, DEFAULT_WIDTH, DEFAULT_HEIGHT);
                    ctx.value.drawImage(
                      thumb.renderImage.img,
                      dx,
                      dy,
                      resizeWidth,
                      resizeHeight
                    );
                  }
                });
              }
            }
          );
          watch([source.list], () => {
            thumb.lastHoverTime = -1;
            thumb.lastRequestTime = -1;
            thumb.renderTime = -1;
            thumb.renderImage = void 0;
            if (lastTimer.value) {
              clearTimeout(lastTimer.value);
              lastTimer.value = null;
            }
          });
          function handleThumbnailMouseUp(e) {
            var _a;
            if ((_a = thumb.renderImage) == null ? void 0 : _a.frameTime) {
              e.stopPropagation();
              emit("seek", thumb.renderImage.frameTime);
            }
          }
          onUnmounted(() => {
            if (lastTimer.value) {
              clearTimeout(lastTimer.value);
              lastTimer.value = null;
            }
          });
          return (_ctx, _cache) => {
            var _a, _b;
            return withDirectives((openBlock(), createElementBlock("div", {
              class: normalizeClass(styles.root),
              style: normalizeStyle({
                transform: `translateX(${previewTransform.value}px) translateY(-100%)`
              })
            }, [
              createElementVNode("div", {
                class: normalizeClass([
                  styles.image.root,
                  {
                    [styles.image.pressing]: unref(progressBar).isDragging.value
                  }
                ]),
                style: normalizeStyle({
                  width: `${thumbnailContainerSize.value.width}px`,
                  height: `${thumbnailContainerSize.value.height}px`
                }),
                onMouseenter: _cache[0] || (_cache[0] = ($event) => isHoveringImage.value = true),
                onMouseleave: _cache[1] || (_cache[1] = ($event) => isHoveringImage.value = false),
                onMouseup: handleThumbnailMouseUp
              }, [
                createElementVNode("canvas", {
                  ref_key: "thumbnailCanvas",
                  ref: thumbnailCanvas,
                  width: DEFAULT_WIDTH,
                  height: unref(DEFAULT_HEIGHT)
                }, null, 8, _hoisted_1$6),
                createVNode(Transition, {
                  "enter-active-class": "transition-opacity duration-150 ease-out delay-60",
                  "leave-active-class": "transition-opacity duration-150 ease-out delay-60",
                  "enter-from-class": "opacity-0",
                  "leave-to-class": "opacity-0"
                }, {
                  default: withCtx(() => [
                    loading.value ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(styles.image.loading)
                    }, null, 2)) : createCommentVNode("", true)
                  ]),
                  _: 1
                }),
                thumb.error ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(styles.image.error)
                }, [
                  createVNode(_sfc_main$1$1, {
                    message: thumb.error,
                    size: "mini"
                  }, null, 8, ["message"])
                ], 2)) : createCommentVNode("", true)
              ], 38),
              createElementVNode("div", {
                class: normalizeClass(styles.timeBox.container)
              }, [
                isHoveringImage.value && ((_a = thumb.renderImage) == null ? void 0 : _a.frameTime) ? (openBlock(), createElementBlock("span", _hoisted_2$4, " 跳至 " + toDisplayString(unref(formatTime)(((_b = thumb.renderImage) == null ? void 0 : _b.frameTime) || 0)) + " 预览时间 ", 1)) : (openBlock(), createElementBlock("span", _hoisted_3$2, toDisplayString(unref(formatTime)(props.time)), 1))
              ], 2)
            ], 6)), [
              [vShow, boxVisible.value]
            ]);
          };
        }
      });
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        __name: "ProgressBar",
        setup(__props) {
          const styles = {
            progressBar: {
              root: "relative",
              wrapper: "py-2 cursor-pointer relative",
              track: "h-1 bg-base-content/30 relative transition-[height] duration-100 ease-linear shadow-xl/60"
            },
            thumb: {
              current: "absolute h-full bg-primary transition-[width] duration-100 linear",
              dragging: "transition-none",
              hover: "absolute h-full bg-primary pointer-events-none"
            },
            handle: {
              container: "absolute h-full -translate-x-1/2",
              base: [
                "absolute top-1/2 left-1/2 size-3.5",
                "bg-primary rounded-full drop-shadow-xs/60",
                "-translate-x-1/2 -translate-y-1/2 scale-0",
                "transition-all duration-100 ease-linear pointer-events-none"
              ],
              visible: "scale-100",
              dragging: "!scale-80 bg-base-content! duration-450 ring-4 ring-primary",
              original: "!bg-white/50 !scale-100"
            }
          };
          const { progressBar, playerCore: player, controls } = usePlayerContext();
          const progressValue = computed(() => {
            var _a, _b;
            return (((_a = player.value) == null ? void 0 : _a.currentTime) ?? 0) / (((_b = player.value) == null ? void 0 : _b.duration) ?? 1) * 100;
          });
          const duration2 = computed(() => {
            var _a;
            return ((_a = player.value) == null ? void 0 : _a.duration) ?? 0;
          });
          const progressBarWrapperRef = shallowRef(null);
          const { width: progressBarWidth } = useElementSize(progressBarWrapperRef);
          const isDragging = progressBar.isDragging;
          const isInProgressBar = shallowRef(false);
          const isHovering = computed(() => isInProgressBar.value || isDragging.value);
          const dragProgress = shallowRef(0);
          const originalProgress = shallowRef(0);
          const previewTime = shallowRef(0);
          const previewProgress = shallowRef(0);
          const isPreviewVisible = shallowRef(false);
          function calculatePosition(event, element) {
            const rect = element.getBoundingClientRect();
            const position = (event.clientX - rect.left) / rect.width;
            return Math.min(Math.max(position, 0), 1);
          }
          function handleBarWrapperMouseDown(event) {
            if (!progressBarWrapperRef.value)
              return;
            const position = calculatePosition(event, progressBarWrapperRef.value);
            startDragging(position);
          }
          function handleBarWrapperMouseEnter() {
            isInProgressBar.value = true;
            if (!isPreviewVisible.value) {
              showPreview();
            }
          }
          function handleBarWrapperMouseMove(event) {
            if (!progressBarWrapperRef.value)
              return;
            const position = calculatePosition(event, progressBarWrapperRef.value);
            updatePreview(position);
          }
          function handleBarWrapperMouseLeave() {
            isInProgressBar.value = false;
            hidePreview();
          }
          function handleGlobalMouseMove(event) {
            if (!progressBarWrapperRef.value)
              return;
            const position = calculatePosition(event, progressBarWrapperRef.value);
            updateDragging(position);
          }
          function handleGlobalMouseUp(event) {
            document.removeEventListener("mousemove", handleGlobalMouseMove);
            document.removeEventListener("mouseup", handleGlobalMouseUp);
            if (!progressBarWrapperRef.value)
              return;
            const position = calculatePosition(event, progressBarWrapperRef.value);
            stopDragging(position);
            if (!isInProgressBar.value) {
              hidePreview();
            }
          }
          function updatePreview(position) {
            previewProgress.value = position * 100;
            previewTime.value = position * duration2.value;
          }
          function startDragging(position) {
            controls.addDisabledAutoHide();
            controls.setDisabledHideOnMouseLeave(true);
            isDragging.value = true;
            originalProgress.value = progressValue.value;
            dragProgress.value = position * 100;
            previewTime.value = position * duration2.value;
            document.addEventListener("mousemove", handleGlobalMouseMove);
            document.addEventListener("mouseup", handleGlobalMouseUp);
          }
          function updateDragging(position) {
            if (!isDragging.value)
              return;
            dragProgress.value = position * 100;
            previewTime.value = position * duration2.value;
          }
          function stopDragging(position) {
            var _a;
            if (isDragging.value) {
              const finalTime = position * duration2.value;
              (_a = player.value) == null ? void 0 : _a.seek(finalTime);
              previewProgress.value = position * 100;
              previewTime.value = finalTime;
            }
            isDragging.value = false;
            controls.removeDisabledAutoHide();
            controls.setDisabledHideOnMouseLeave(false);
          }
          function showPreview() {
            isPreviewVisible.value = true;
          }
          function hidePreview() {
            if (!isDragging.value) {
              isPreviewVisible.value = false;
              previewProgress.value = 0;
              previewTime.value = 0;
            }
          }
          function handleThumbnailSeek(time) {
            var _a;
            (_a = player.value) == null ? void 0 : _a.seek(time);
            isDragging.value = false;
            hidePreview();
            document.removeEventListener("mousemove", handleGlobalMouseMove);
            document.removeEventListener("mouseup", handleGlobalMouseUp);
          }
          onUnmounted(() => {
            document.removeEventListener("mousemove", handleGlobalMouseMove);
            document.removeEventListener("mouseup", handleGlobalMouseUp);
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(styles.progressBar.root)
            }, [
              createElementVNode("div", {
                ref_key: "progressBarWrapperRef",
                ref: progressBarWrapperRef,
                class: normalizeClass(styles.progressBar.wrapper),
                onMousedown: handleBarWrapperMouseDown,
                onMouseenter: handleBarWrapperMouseEnter,
                onMousemove: handleBarWrapperMouseMove,
                onMouseleave: handleBarWrapperMouseLeave
              }, [
                createElementVNode("div", {
                  class: normalizeClass([styles.progressBar.track])
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(styles.thumb.current),
                    style: normalizeStyle({
                      width: `${progressValue.value}%`,
                      opacity: unref(isDragging) ? 0 : 1
                    })
                  }, null, 6),
                  unref(isDragging) && !unref(progressBar).isLongPressDragging.value ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass([styles.thumb.current, styles.thumb.dragging]),
                    style: normalizeStyle({ width: `${dragProgress.value}%` })
                  }, null, 6)) : createCommentVNode("", true),
                  withDirectives(createElementVNode("div", {
                    class: normalizeClass(styles.thumb.hover),
                    style: normalizeStyle({ width: `${previewProgress.value}%` })
                  }, null, 6), [
                    [vShow, isPreviewVisible.value && !unref(isDragging)]
                  ]),
                  unref(isDragging) ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(styles.handle.container),
                    style: normalizeStyle({ left: `${originalProgress.value}%` })
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass([styles.handle.base, styles.handle.original])
                    }, null, 2)
                  ], 6)) : createCommentVNode("", true),
                  createElementVNode("div", {
                    class: normalizeClass(styles.handle.container),
                    style: normalizeStyle({
                      left: `${unref(isDragging) ? dragProgress.value : progressValue.value}%`
                    })
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass([
                        styles.handle.base,
                        isHovering.value && styles.handle.visible,
                        unref(isDragging) && styles.handle.dragging
                      ])
                    }, null, 2)
                  ], 6)
                ], 2)
              ], 34),
              createVNode(_sfc_main$h, {
                visible: isPreviewVisible.value || unref(isDragging),
                position: unref(isDragging) ? dragProgress.value : previewProgress.value,
                time: previewTime.value,
                "progress-bar-width": unref(progressBarWidth),
                onSeek: handleThumbnailSeek
              }, null, 8, ["visible", "position", "time", "progress-bar-width"])
            ], 2);
          };
        }
      });
      const _hoisted_1$5 = ["onClick"];
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        __name: "QualityButton",
        setup(__props) {
          const styles = {
            ...controlStyles
          };
          const { source } = usePlayerContext();
          const menuVisible = shallowRef(false);
          const buttonRef = shallowRef();
          const currentQuality = computed(() => {
            if (!source.current.value)
              return "自动";
            const quality = source.current.value.displayQuality || source.current.value.quality;
            return typeof quality === "number" ? `${quality}P` : quality;
          });
          function toggleMenu() {
            menuVisible.value = !menuVisible.value;
          }
          function getDisplayQuality(sourceValue) {
            const quality = sourceValue.displayQuality || sourceValue.quality;
            return typeof quality === "number" ? `${quality}P` : quality;
          }
          async function handleQualityChange(sourceValue) {
            menuVisible.value = false;
            await source.changeQuality(sourceValue);
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createElementVNode("button", {
                ref_key: "buttonRef",
                ref: buttonRef,
                class: normalizeClass(styles.btnText.root),
                "data-tip": "画质",
                onClick: toggleMenu
              }, [
                createElementVNode("span", null, toDisplayString(currentQuality.value), 1)
              ], 2),
              createVNode(Popup, {
                visible: menuVisible.value,
                "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => menuVisible.value = $event),
                trigger: buttonRef.value,
                placement: "top"
              }, {
                default: withCtx(() => [
                  createElementVNode("ul", {
                    class: normalizeClass(styles.menu.root)
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(source).list.value, (item) => {
                      var _a;
                      return openBlock(), createElementBlock("li", {
                        key: item.quality
                      }, [
                        createElementVNode("a", {
                          class: normalizeClass([
                            styles.menu.a,
                            {
                              [styles.menu.active]: item.quality === ((_a = unref(source).current.value) == null ? void 0 : _a.quality)
                            }
                          ]),
                          onClick: ($event) => handleQualityChange(item)
                        }, toDisplayString(getDisplayQuality(item)), 11, _hoisted_1$5)
                      ]);
                    }), 128))
                  ], 2)
                ]),
                _: 1
              }, 8, ["visible", "trigger"])
            ], 64);
          };
        }
      });
      const _hoisted_1$4 = { class: "card card-sm bg-neutral-800" };
      const _hoisted_2$3 = { class: "card-body" };
      const _hoisted_3$1 = { class: "fieldset" };
      const _hoisted_4$1 = { class: "flex gap-2" };
      const _hoisted_5$1 = ["onClick"];
      const _hoisted_6$1 = { class: "fieldset" };
      const _hoisted_7$1 = ["checked"];
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        __name: "ThumbnailSettings",
        setup(__props) {
          const { thumbnailSettings } = usePlayerContext();
          const samplingIntervals = [30, 60, 120];
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", _hoisted_1$4, [
              createElementVNode("div", _hoisted_2$3, [
                _cache[3] || (_cache[3] = createElementVNode("h3", { class: "card-title flex justify-between" }, [
                  createTextVNode(" 预览图 "),
                  createElementVNode("span", { class: "text-xs font-normal text-base-content/50 text-center" }, "刷新后生效")
                ], -1)),
                createElementVNode("div", null, [
                  createElementVNode("fieldset", _hoisted_3$1, [
                    _cache[1] || (_cache[1] = createElementVNode("legend", { class: "fieldset-legend" }, " 采样间隔 (S) ", -1)),
                    createElementVNode("div", _hoisted_4$1, [
                      (openBlock(), createElementBlock(Fragment, null, renderList(samplingIntervals, (interval) => {
                        return createElementVNode("button", {
                          key: interval,
                          class: normalizeClass(["btn btn-sm bg-soft flex-1", { "btn-primary": unref(thumbnailSettings).samplingInterval.value === interval }]),
                          onClick: ($event) => unref(thumbnailSettings).setSamplingInterval(interval)
                        }, toDisplayString(interval), 11, _hoisted_5$1);
                      }), 64))
                    ])
                  ]),
                  createElementVNode("fieldset", _hoisted_6$1, [
                    _cache[2] || (_cache[2] = createElementVNode("legend", { class: "fieldset-legend" }, " 自动缓冲 ", -1)),
                    createElementVNode("input", {
                      type: "checkbox",
                      checked: unref(thumbnailSettings).autoLoadThumbnails.value,
                      class: "toggle toggle-sm toggle-primary",
                      onChange: _cache[0] || (_cache[0] = //@ts-ignore
                      (...args) => unref(thumbnailSettings).toggleAutoLoad && unref(thumbnailSettings).toggleAutoLoad(...args))
                    }, null, 40, _hoisted_7$1)
                  ])
                ])
              ])
            ]);
          };
        }
      });
      const _hoisted_1$3 = { class: "card card-sm bg-neutral-800" };
      const _hoisted_2$2 = { class: "card-body" };
      const _hoisted_3 = { class: "fieldset" };
      const _hoisted_4 = { class: "fieldset-legend w-full" };
      const _hoisted_5 = { class: "badge badge-sm" };
      const _hoisted_6 = { class: "flex gap-2" };
      const _hoisted_7 = ["disabled"];
      const _hoisted_8 = ["disabled"];
      const _hoisted_9 = { class: "fieldset" };
      const _hoisted_10 = { class: "flex gap-2" };
      const _hoisted_11 = { class: "transform rotate-90" };
      const _sfc_main$d = /* @__PURE__ */ defineComponent({
        __name: "TransformSettings",
        setup(__props) {
          const { transform } = usePlayerContext();
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", _hoisted_1$3, [
              createElementVNode("div", _hoisted_2$2, [
                _cache[9] || (_cache[9] = createElementVNode("h3", { class: "card-title" }, " 旋转与翻转 ", -1)),
                createElementVNode("div", null, [
                  createElementVNode("fieldset", _hoisted_3, [
                    createElementVNode("legend", _hoisted_4, [
                      _cache[5] || (_cache[5] = createTextVNode(" 旋转 ", -1)),
                      createElementVNode("span", _hoisted_5, toDisplayString(unref(transform).rotate.value) + "°", 1)
                    ]),
                    createElementVNode("div", _hoisted_6, [
                      createElementVNode("button", {
                        class: "btn btn-sm join-item flex-1",
                        disabled: unref(transform).rotate.value === -270,
                        onClick: _cache[0] || (_cache[0] = //@ts-ignore
                        (...args) => unref(transform).left && unref(transform).left(...args))
                      }, [
                        createVNode(unref(Icon), {
                          icon: unref(ICON_ROTATE_LEFT),
                          class: "size-4"
                        }, null, 8, ["icon"])
                      ], 8, _hoisted_7),
                      createElementVNode("button", {
                        class: "btn btn-sm join-item flex-1",
                        onClick: _cache[1] || (_cache[1] = //@ts-ignore
                        (...args) => unref(transform).normal && unref(transform).normal(...args))
                      }, [
                        createVNode(unref(Icon), {
                          icon: unref(ICON_ROTATE_NORMAL),
                          class: "size-4"
                        }, null, 8, ["icon"])
                      ]),
                      createElementVNode("button", {
                        class: "btn btn-sm join-item flex-1",
                        disabled: unref(transform).rotate.value === 270,
                        onClick: _cache[2] || (_cache[2] = //@ts-ignore
                        (...args) => unref(transform).right && unref(transform).right(...args))
                      }, [
                        createVNode(unref(Icon), {
                          icon: unref(ICON_ROTATE_RIGHT),
                          class: "size-4"
                        }, null, 8, ["icon"])
                      ], 8, _hoisted_8)
                    ])
                  ]),
                  createElementVNode("fieldset", _hoisted_9, [
                    _cache[8] || (_cache[8] = createElementVNode("legend", { class: "fieldset-legend" }, " 翻转 ", -1)),
                    createElementVNode("div", _hoisted_10, [
                      createElementVNode("button", {
                        class: normalizeClass(["btn btn-sm flex-1", { "btn-primary": unref(transform).flipX.value }]),
                        onClick: _cache[3] || (_cache[3] = //@ts-ignore
                        (...args) => unref(transform).toggleFlipX && unref(transform).toggleFlipX(...args))
                      }, [
                        createElementVNode("div", _hoisted_11, [
                          createVNode(unref(Icon), {
                            icon: unref(ICON_FLIP_X),
                            class: "size-4"
                          }, null, 8, ["icon"])
                        ]),
                        _cache[6] || (_cache[6] = createTextVNode(" 水平 ", -1))
                      ], 2),
                      createElementVNode("button", {
                        class: normalizeClass(["btn btn-sm flex-1", { "btn-primary": unref(transform).flipY.value }]),
                        onClick: _cache[4] || (_cache[4] = //@ts-ignore
                        (...args) => unref(transform).toggleFlipY && unref(transform).toggleFlipY(...args))
                      }, [
                        createVNode(unref(Icon), {
                          icon: unref(ICON_FLIP_Y),
                          class: "size-4"
                        }, null, 8, ["icon"]),
                        _cache[7] || (_cache[7] = createTextVNode(" 垂直 ", -1))
                      ], 2)
                    ])
                  ])
                ])
              ])
            ]);
          };
        }
      });
      const _sfc_main$c = /* @__PURE__ */ defineComponent({
        __name: "SettingsButton",
        setup(__props) {
          const styles = {
            ...controlStyles,
            panel: {
              root: "grid grid-cols-2 gap-3 p-1 w-full max-w-xl"
            },
            popup: "select-none"
          };
          const buttonRef = shallowRef();
          const menuVisible = shallowRef(false);
          function toggleMenu() {
            menuVisible.value = !menuVisible.value;
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createElementVNode("button", {
                ref_key: "buttonRef",
                ref: buttonRef,
                class: normalizeClass([styles.btn.root]),
                "data-tip": "设置",
                onClick: toggleMenu
              }, [
                createVNode(unref(Icon), {
                  class: normalizeClass(["transition-transform", [
                    styles.btn.icon,
                    {
                      "rotate-90": menuVisible.value
                    }
                  ]]),
                  icon: unref(ICON_SETTINGS)
                }, null, 8, ["class", "icon"])
              ], 2),
              createVNode(Popup, {
                visible: menuVisible.value,
                "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => menuVisible.value = $event),
                trigger: buttonRef.value,
                placement: "top",
                class: normalizeClass([styles.popup])
              }, {
                default: withCtx(() => [
                  createElementVNode("div", {
                    class: normalizeClass([styles.panel.root])
                  }, [
                    createVNode(_sfc_main$e),
                    createVNode(_sfc_main$d)
                  ], 2)
                ]),
                _: 1
              }, 8, ["visible", "trigger", "class"])
            ], 64);
          };
        }
      });
      const _sfc_main$b = /* @__PURE__ */ defineComponent({
        __name: "TimeDisplay",
        setup(__props) {
          const { playerCore } = usePlayerContext();
          const styles = {
            root: [controlStyles.text, "flex items-center gap-1.5 select-none"],
            separator: controlStyles.subtext
          };
          return (_ctx, _cache) => {
            var _a, _b, _c, _d;
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([[
                styles.root,
                {
                  "opacity-0": !((_a = unref(playerCore)) == null ? void 0 : _a.canplay),
                  "opacity-100": (_b = unref(playerCore)) == null ? void 0 : _b.canplay
                }
              ], "transition-opacity duration-200"])
            }, [
              createElementVNode("span", null, toDisplayString(unref(formatTime)((_c = unref(playerCore)) == null ? void 0 : _c.currentTime)), 1),
              createElementVNode("span", {
                class: normalizeClass(styles.separator)
              }, "/", 2),
              createElementVNode("span", null, toDisplayString(unref(formatTime)((_d = unref(playerCore)) == null ? void 0 : _d.duration)), 1)
            ], 2);
          };
        }
      });
      const _hoisted_1$2 = ["disabled"];
      const _hoisted_2$1 = ["value", "disabled"];
      const _sfc_main$a = /* @__PURE__ */ defineComponent({
        __name: "VolumeControl",
        setup(__props) {
          const { playerCore, hud } = usePlayerContext();
          const styles = computed(() => {
            var _a;
            return {
              root: "flex items-center gap-2 mr-2",
              btn: controlStyles.btn,
              range: ["range range-2xs w-24 range-primary"],
              tooltip: [
                "tooltip tooltip-top",
                {
                  "tooltip-open": (_a = playerCore == null ? void 0 : playerCore.value) == null ? void 0 : _a.isSuspended
                }
              ],
              tooltipContent: "tooltip-content py-2 px-4",
              resumeBtn: "cursor-pointer pointer-events-auto"
            };
          });
          const VolumeIcon = computed(() => {
            var _a, _b;
            return getVolumeIcon(
              ((_a = playerCore.value) == null ? void 0 : _a.volume) ?? 0,
              ((_b = playerCore.value) == null ? void 0 : _b.muted) ?? false
            );
          });
          function handleVolumeChange(event) {
            var _a;
            const value = Number(event.target.value);
            (_a = playerCore.value) == null ? void 0 : _a.setVolume(value);
          }
          return (_ctx, _cache) => {
            var _a, _b, _c, _d, _e, _f, _g;
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                styles.value.tooltip
              ])
            }, [
              ((_a = unref(playerCore)) == null ? void 0 : _a.isSuspended) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass([styles.value.tooltipContent])
              }, [
                createElementVNode("button", {
                  class: normalizeClass([styles.value.resumeBtn]),
                  onClick: _cache[0] || (_cache[0] = () => {
                    var _a2, _b2;
                    (_a2 = unref(playerCore)) == null ? void 0 : _a2.resumeSuspended();
                    (_b2 = unref(hud)) == null ? void 0 : _b2.showResumeSuspended();
                  })
                }, " 点击恢复音频 ", 2)
              ], 2)) : createCommentVNode("", true),
              createElementVNode("div", {
                class: normalizeClass([styles.value.root])
              }, [
                createElementVNode("button", {
                  class: normalizeClass(["swap swap-rotate", [styles.value.btn.root, {
                    "swap-active": (_b = unref(playerCore)) == null ? void 0 : _b.muted
                  }]]),
                  "data-tip": "静音 (M)",
                  disabled: !((_c = unref(playerCore)) == null ? void 0 : _c.canplay) || ((_d = unref(playerCore)) == null ? void 0 : _d.isSuspended),
                  onClick: _cache[1] || (_cache[1] = //@ts-ignore
                  (...args) => {
                    var _a2, _b2;
                    return ((_a2 = unref(playerCore)) == null ? void 0 : _a2.toggleMute) && ((_b2 = unref(playerCore)) == null ? void 0 : _b2.toggleMute(...args));
                  })
                }, [
                  createVNode(unref(Icon), {
                    class: normalizeClass(["swap-off", [styles.value.btn.icon]]),
                    icon: VolumeIcon.value
                  }, null, 8, ["class", "icon"]),
                  createVNode(unref(Icon), {
                    class: normalizeClass(["swap-on", [styles.value.btn.icon]]),
                    icon: VolumeIcon.value
                  }, null, 8, ["class", "icon"])
                ], 10, _hoisted_1$2),
                createElementVNode("input", {
                  type: "range",
                  class: normalizeClass([styles.value.range]),
                  min: "0",
                  max: "100",
                  value: ((_e = unref(playerCore)) == null ? void 0 : _e.volume) ?? 0,
                  disabled: !((_f = unref(playerCore)) == null ? void 0 : _f.canplay) || ((_g = unref(playerCore)) == null ? void 0 : _g.isSuspended),
                  onInput: handleVolumeChange
                }, null, 42, _hoisted_2$1)
              ], 2)
            ], 2);
          };
        }
      });
      const _sfc_main$9 = /* @__PURE__ */ defineComponent({
        __name: "ControlBar",
        setup(__props) {
          const styles = {
            controlBar: {
              main: "relative pointer-events-auto",
              bg: [
                "absolute inset-0 top-[-30px] pointer-events-none",
                "bg-linear-to-t from-black/50 from-10% to-transparent"
              ],
              mainContent: "relative px-5 py-3",
              bar: "flex justify-between items-center",
              trivialize: "opacity-0 transition-all duration-200 ease-out",
              left: "flex items-center gap-2",
              right: "flex items-center gap-2"
            }
          };
          const { controls, playerCore, progressBar } = usePlayerContext();
          const controlBarRef = shallowRef(null);
          useControlsMouseDetection(controlBarRef);
          const show = computed(() => {
            return controls.visible.value;
          });
          const canplay = computed(() => {
            var _a;
            return (_a = playerCore.value) == null ? void 0 : _a.canplay;
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              "enter-active-class": "transition-all duration-200 ease-out",
              "leave-active-class": "transition-all duration-200 ease-out",
              "enter-from-class": "opacity-0",
              "enter-to-class": "opacity-100",
              "leave-from-class": "opacity-100",
              "leave-to-class": "opacity-0"
            }, {
              default: withCtx(() => {
                var _a;
                return [
                  show.value ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref_key: "controlBarRef",
                    ref: controlBarRef,
                    class: normalizeClass(styles.controlBar.main)
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass([styles.controlBar.bg])
                    }, null, 2),
                    createElementVNode("div", {
                      ref: unref(controls).mainRef,
                      class: normalizeClass([styles.controlBar.mainContent])
                    }, [
                      createVNode(_sfc_main$g, {
                        class: normalizeClass({
                          "opacity-0 pointer-events-none": !canplay.value,
                          "opacity-100 pointer-events-auto": canplay.value
                        })
                      }, null, 8, ["class"]),
                      createElementVNode("div", {
                        class: normalizeClass([styles.controlBar.bar, {
                          [styles.controlBar.trivialize]: (_a = unref(progressBar)) == null ? void 0 : _a.isLongPressDragging.value
                        }])
                      }, [
                        createElementVNode("div", {
                          class: normalizeClass(styles.controlBar.left)
                        }, [
                          createVNode(_sfc_main$k),
                          createVNode(_sfc_main$a),
                          createVNode(_sfc_main$b)
                        ], 2),
                        createElementVNode("div", {
                          class: normalizeClass(styles.controlBar.right)
                        }, [
                          createVNode(_sfc_main$f),
                          createVNode(_sfc_main$l),
                          createVNode(_sfc_main$n),
                          createVNode(_sfc_main$i),
                          createVNode(_sfc_main$j),
                          createVNode(_sfc_main$c),
                          createVNode(_sfc_main$m)
                        ], 2)
                      ], 2)
                    ], 2)
                  ], 2)) : createCommentVNode("", true)
                ];
              }),
              _: 1
            });
          };
        }
      });
      const _sfc_main$8 = /* @__PURE__ */ defineComponent({
        __name: "ControlHeader",
        props: {
          title: {}
        },
        setup(__props) {
          const props = __props;
          const { controls, progressBar } = usePlayerContext();
          const styles = {
            root: "relative",
            content: {
              root: "relative flex justify-between items-center p-7",
              left: "flex-1 font-bold"
            },
            bg: "absolute inset-0 bottom-[-50px] bg-linear-to-b from-black/30 to-transparent pointer-events-none"
          };
          const controlHeaderRef = shallowRef(null);
          useControlsMouseDetection(controlHeaderRef);
          const show = computed(() => {
            return controls.visible.value && !progressBar.isLongPressDragging.value;
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              "enter-active-class": "transition-all duration-200 ease-out",
              "leave-active-class": "transition-all duration-200 ease-out",
              "enter-from-class": "opacity-0",
              "enter-to-class": "opacity-100",
              "leave-from-class": "opacity-100",
              "leave-to-class": "opacity-0"
            }, {
              default: withCtx(() => [
                show.value ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref_key: "controlHeaderRef",
                  ref: controlHeaderRef,
                  class: normalizeClass([styles.root])
                }, [
                  createElementVNode("div", {
                    class: normalizeClass([styles.bg])
                  }, null, 2),
                  createElementVNode("div", {
                    class: normalizeClass([
                      styles.content.root
                    ])
                  }, [
                    renderSlot(_ctx.$slots, "left"),
                    createElementVNode("div", {
                      class: normalizeClass([styles.content.left])
                    }, toDisplayString(props.title), 3)
                  ], 2)
                ], 2)) : createCommentVNode("", true)
              ]),
              _: 3
            });
          };
        }
      });
      const _sfc_main$7 = /* @__PURE__ */ defineComponent({
        __name: "ControlMask",
        setup(__props) {
          const styles = {
            mask: "relative flex-1"
          };
          const {
            fullscreen,
            playerCore: player,
            popupManager
          } = usePlayerContext();
          const maskRef = shallowRef();
          function handleClick() {
            var _a;
            (_a = player.value) == null ? void 0 : _a.togglePlay();
          }
          function handleDoubleClick() {
            fullscreen.toggleFullscreen();
          }
          onMounted(() => {
            popupManager == null ? void 0 : popupManager.addDisabledBubblingElement(maskRef.value);
          });
          onUnmounted(() => {
            popupManager == null ? void 0 : popupManager.removeDisabledBubblingElement(maskRef.value);
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "maskRef",
              ref: maskRef,
              class: normalizeClass(styles.mask),
              onClick: withModifiers(handleClick, ["self"]),
              onDblclick: withModifiers(handleDoubleClick, ["self"])
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 34);
          };
        }
      });
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        __name: "ControlsRight",
        setup(__props) {
          const styles = {
            root: [
              "absolute inset-y-0 right-0 flex flex-col justify-end items-center gap-2 px-7 pb-2"
            ]
          };
          const { progressBar, controls } = usePlayerContext();
          const controlRightRef = shallowRef(null);
          useControlsMouseDetection(controlRightRef);
          const show = computed(() => {
            return controls.visible.value && !progressBar.isLongPressDragging.value;
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              "enter-active-class": "transition-all duration-200 ease-out",
              "leave-active-class": "transition-all duration-200 ease-out",
              "enter-from-class": "opacity-0",
              "enter-to-class": "opacity-100",
              "leave-from-class": "opacity-100",
              "leave-to-class": "opacity-0"
            }, {
              default: withCtx(() => [
                show.value ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref_key: "controlRightRef",
                  ref: controlRightRef,
                  class: normalizeClass(styles.root)
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2)) : createCommentVNode("", true)
              ]),
              _: 3
            });
          };
        }
      });
      const _sfc_main$5 = /* @__PURE__ */ defineComponent({
        __name: "index",
        setup(__props) {
          const styles = {
            root: "absolute inset-0 flex flex-col"
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(styles.root)
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        __name: "index",
        props: {
          sources: {},
          videoId: { default: void 0 },
          showPlaylist: { type: Boolean },
          volume: {},
          muted: { type: Boolean },
          playbackRate: {},
          lastTime: {},
          autoLoadThumbnails: { type: Boolean },
          autoPlay: { type: Boolean },
          disabledHDR: { type: Boolean },
          thumbnailsSamplingInterval: {},
          hlsConfig: { default: () => ({}) },
          avPlayerConfig: { default: () => ({}) },
          onThumbnailRequest: { type: Function, default: void 0 },
          onCanplay: {},
          onTimeupdate: {},
          onSeeking: {},
          onSeeked: {},
          onIdled: {},
          getCurrentPlaylist: {},
          getCurrentPickCode: {},
          onChangeVideo: {},
          onPreviousVideo: {},
          onNextVideo: {},
          currentPlayMode: {},
          setPlayMode: {}
        },
        emits: ["update:showPlaylist", "update:volume", "update:muted", "update:playbackRate", "update:autoLoadThumbnails", "update:autoPlay", "update:disabledHDR", "update:thumbnailsSamplingInterval"],
        setup(__props, { expose: __expose, emit: __emit }) {
          var _a, _b;
          const props = __props;
          const emit = __emit;
          const styles = {
            root: "relative bg-black",
            fullscreen: "w-100vw h-100vh",
            videoPlayer: "flex items-center justify-center w-full h-full",
            error: "absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2",
            resumeContainer: "absolute inset-0 flex justify-center items-center bg-black/90 z-2",
            resumeButton: "btn"
          };
          const rootRef = shallowRef(null);
          const playerElementRef = shallowRef(null);
          const portalContext = usePortalProvider();
          watchEffect(() => {
            portalContext.container.value = rootRef.value ?? void 0;
          });
          const context = usePlayerProvide(
            {
              rootRef,
              playerElementRef
            },
            props,
            emit
          );
          const { fullscreen, source, transform, playerCore, controls } = context;
          watch(
            () => controls.visible.value,
            (visible) => {
              if (rootRef.value) {
                rootRef.value.style.cursor = visible ? "auto" : "none";
              }
            },
            { immediate: true }
          );
          __expose({
            togglePlay: (_a = playerCore.value) == null ? void 0 : _a.togglePlay,
            interruptSource: source.interruptSource,
            seekTo: (_b = playerCore.value) == null ? void 0 : _b.seek
          });
          return (_ctx, _cache) => {
            var _a2, _b2, _c;
            return openBlock(), createElementBlock("div", {
              ref_key: "rootRef",
              ref: rootRef,
              class: normalizeClass([
                styles.root,
                { [styles.fullscreen]: unref(fullscreen).isFullscreen }
              ])
            }, [
              createElementVNode("div", {
                ref_key: "playerElementRef",
                ref: playerElementRef,
                class: normalizeClass(styles.videoPlayer),
                style: normalizeStyle([
                  unref(transform).transformStyle.value
                ])
              }, null, 6),
              createVNode(_sfc_main$o),
              ((_a2 = unref(playerCore)) == null ? void 0 : _a2.loadError) ? (openBlock(), createBlock(_sfc_main$1$1, {
                key: 0,
                class: normalizeClass(styles.error),
                message: (_b2 = unref(playerCore)) == null ? void 0 : _b2.loadError
              }, null, 8, ["class", "message"])) : ((_c = unref(playerCore)) == null ? void 0 : _c.isLoading) ? (openBlock(), createBlock(Loading, { key: 1 })) : createCommentVNode("", true),
              createVNode(_sfc_main$5, null, {
                default: withCtx(() => [
                  createVNode(_sfc_main$8, null, {
                    left: withCtx(() => [
                      renderSlot(_ctx.$slots, "headerLeft")
                    ]),
                    _: 3
                  }),
                  createVNode(_sfc_main$7, null, {
                    default: withCtx(() => [
                      createVNode(_sfc_main$6, null, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "controlsRight")
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }),
                  createVNode(_sfc_main$9)
                ]),
                _: 3
              }),
              createVNode(_sfc_main$q),
              unref(source).isInterrupt.value ? (openBlock(), createElementBlock("div", {
                key: 2,
                class: normalizeClass(styles.resumeContainer)
              }, [
                createElementVNode("button", {
                  class: normalizeClass(styles.resumeButton),
                  onClick: _cache[0] || (_cache[0] = //@ts-ignore
                  (...args) => unref(source).resumeSource && unref(source).resumeSource(...args))
                }, " 恢复播放 ", 2)
              ], 2)) : createCommentVNode("", true)
            ], 2);
          };
        }
      });
      function useParamsVideoPage() {
        const pickCode = ref();
        const cid = ref();
        const getParams = () => {
          const params = new URLSearchParams(window.location.search);
          pickCode.value = params.get("pick_code") ?? void 0;
          cid.value = params.get("cid") ?? void 0;
        };
        getParams();
        return {
          pickCode,
          cid,
          getParams
        };
      }
      var duration$2 = { exports: {} };
      var duration$1 = duration$2.exports;
      var hasRequiredDuration;
      function requireDuration() {
        if (hasRequiredDuration) return duration$2.exports;
        hasRequiredDuration = 1;
        (function(module, exports) {
          !(function(t, s) {
            module.exports = s();
          })(duration$1, (function() {
            var t, s, n = 1e3, i = 6e4, e = 36e5, r = 864e5, o = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, u = 31536e6, d2 = 2628e6, a = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, h = { years: u, months: d2, days: r, hours: e, minutes: i, seconds: n, milliseconds: 1, weeks: 6048e5 }, c = function(t2) {
              return t2 instanceof g;
            }, f = function(t2, s2, n2) {
              return new g(t2, n2, s2.$l);
            }, m = function(t2) {
              return s.p(t2) + "s";
            }, l = function(t2) {
              return t2 < 0;
            }, $ = function(t2) {
              return l(t2) ? Math.ceil(t2) : Math.floor(t2);
            }, y = function(t2) {
              return Math.abs(t2);
            }, v = function(t2, s2) {
              return t2 ? l(t2) ? { negative: true, format: "" + y(t2) + s2 } : { negative: false, format: "" + t2 + s2 } : { negative: false, format: "" };
            }, g = (function() {
              function l2(t2, s2, n2) {
                var i2 = this;
                if (this.$d = {}, this.$l = n2, void 0 === t2 && (this.$ms = 0, this.parseFromMilliseconds()), s2) return f(t2 * h[m(s2)], this);
                if ("number" == typeof t2) return this.$ms = t2, this.parseFromMilliseconds(), this;
                if ("object" == typeof t2) return Object.keys(t2).forEach((function(s3) {
                  i2.$d[m(s3)] = t2[s3];
                })), this.calMilliseconds(), this;
                if ("string" == typeof t2) {
                  var e2 = t2.match(a);
                  if (e2) {
                    var r2 = e2.slice(2).map((function(t3) {
                      return null != t3 ? Number(t3) : 0;
                    }));
                    return this.$d.years = r2[0], this.$d.months = r2[1], this.$d.weeks = r2[2], this.$d.days = r2[3], this.$d.hours = r2[4], this.$d.minutes = r2[5], this.$d.seconds = r2[6], this.calMilliseconds(), this;
                  }
                }
                return this;
              }
              var y2 = l2.prototype;
              return y2.calMilliseconds = function() {
                var t2 = this;
                this.$ms = Object.keys(this.$d).reduce((function(s2, n2) {
                  return s2 + (t2.$d[n2] || 0) * h[n2];
                }), 0);
              }, y2.parseFromMilliseconds = function() {
                var t2 = this.$ms;
                this.$d.years = $(t2 / u), t2 %= u, this.$d.months = $(t2 / d2), t2 %= d2, this.$d.days = $(t2 / r), t2 %= r, this.$d.hours = $(t2 / e), t2 %= e, this.$d.minutes = $(t2 / i), t2 %= i, this.$d.seconds = $(t2 / n), t2 %= n, this.$d.milliseconds = t2;
              }, y2.toISOString = function() {
                var t2 = v(this.$d.years, "Y"), s2 = v(this.$d.months, "M"), n2 = +this.$d.days || 0;
                this.$d.weeks && (n2 += 7 * this.$d.weeks);
                var i2 = v(n2, "D"), e2 = v(this.$d.hours, "H"), r2 = v(this.$d.minutes, "M"), o2 = this.$d.seconds || 0;
                this.$d.milliseconds && (o2 += this.$d.milliseconds / 1e3, o2 = Math.round(1e3 * o2) / 1e3);
                var u2 = v(o2, "S"), d3 = t2.negative || s2.negative || i2.negative || e2.negative || r2.negative || u2.negative, a2 = e2.format || r2.format || u2.format ? "T" : "", h2 = (d3 ? "-" : "") + "P" + t2.format + s2.format + i2.format + a2 + e2.format + r2.format + u2.format;
                return "P" === h2 || "-P" === h2 ? "P0D" : h2;
              }, y2.toJSON = function() {
                return this.toISOString();
              }, y2.format = function(t2) {
                var n2 = t2 || "YYYY-MM-DDTHH:mm:ss", i2 = { Y: this.$d.years, YY: s.s(this.$d.years, 2, "0"), YYYY: s.s(this.$d.years, 4, "0"), M: this.$d.months, MM: s.s(this.$d.months, 2, "0"), D: this.$d.days, DD: s.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: s.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: s.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: s.s(this.$d.seconds, 2, "0"), SSS: s.s(this.$d.milliseconds, 3, "0") };
                return n2.replace(o, (function(t3, s2) {
                  return s2 || String(i2[t3]);
                }));
              }, y2.as = function(t2) {
                return this.$ms / h[m(t2)];
              }, y2.get = function(t2) {
                var s2 = this.$ms, n2 = m(t2);
                return "milliseconds" === n2 ? s2 %= 1e3 : s2 = "weeks" === n2 ? $(s2 / h[n2]) : this.$d[n2], s2 || 0;
              }, y2.add = function(t2, s2, n2) {
                var i2;
                return i2 = s2 ? t2 * h[m(s2)] : c(t2) ? t2.$ms : f(t2, this).$ms, f(this.$ms + i2 * (n2 ? -1 : 1), this);
              }, y2.subtract = function(t2, s2) {
                return this.add(t2, s2, true);
              }, y2.locale = function(t2) {
                var s2 = this.clone();
                return s2.$l = t2, s2;
              }, y2.clone = function() {
                return f(this.$ms, this);
              }, y2.humanize = function(s2) {
                return t().add(this.$ms, "ms").locale(this.$l).fromNow(!s2);
              }, y2.valueOf = function() {
                return this.asMilliseconds();
              }, y2.milliseconds = function() {
                return this.get("milliseconds");
              }, y2.asMilliseconds = function() {
                return this.as("milliseconds");
              }, y2.seconds = function() {
                return this.get("seconds");
              }, y2.asSeconds = function() {
                return this.as("seconds");
              }, y2.minutes = function() {
                return this.get("minutes");
              }, y2.asMinutes = function() {
                return this.as("minutes");
              }, y2.hours = function() {
                return this.get("hours");
              }, y2.asHours = function() {
                return this.as("hours");
              }, y2.days = function() {
                return this.get("days");
              }, y2.asDays = function() {
                return this.as("days");
              }, y2.weeks = function() {
                return this.get("weeks");
              }, y2.asWeeks = function() {
                return this.as("weeks");
              }, y2.months = function() {
                return this.get("months");
              }, y2.asMonths = function() {
                return this.as("months");
              }, y2.years = function() {
                return this.get("years");
              }, y2.asYears = function() {
                return this.as("years");
              }, l2;
            })(), p = function(t2, s2, n2) {
              return t2.add(s2.years() * n2, "y").add(s2.months() * n2, "M").add(s2.days() * n2, "d").add(s2.hours() * n2, "h").add(s2.minutes() * n2, "m").add(s2.seconds() * n2, "s").add(s2.milliseconds() * n2, "ms");
            };
            return function(n2, i2, e2) {
              t = e2, s = e2().$utils(), e2.duration = function(t2, s2) {
                var n3 = e2.locale();
                return f(t2, { $l: n3 }, s2);
              }, e2.isDuration = c;
              var r2 = i2.prototype.add, o2 = i2.prototype.subtract;
              i2.prototype.add = function(t2, s2) {
                return c(t2) ? p(this, t2, 1) : r2.bind(this)(t2, s2);
              }, i2.prototype.subtract = function(t2, s2) {
                return c(t2) ? p(this, t2, -1) : o2.bind(this)(t2, s2);
              };
            };
          }));
        })(duration$2);
        return duration$2.exports;
      }
      var durationExports = requireDuration();
      const duration = /* @__PURE__ */ getDefaultExportFromCjs(durationExports);
      dayjs.extend(duration);
      function formatFileSize(bytes) {
        if (!bytes)
          return "未知";
        const units = ["B", "KB", "MB", "GB", "TB"];
        let size = bytes;
        let unitIndex = 0;
        while (size >= 1024 && unitIndex < units.length - 1) {
          size /= 1024;
          unitIndex++;
        }
        return `${size.toFixed(2)} ${units[unitIndex]}`;
      }
      const _hoisted_1$1 = ["onClick"];
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        __name: "index",
        props: {
          fileInfo: {},
          playlist: {}
        },
        setup(__props) {
          const props = __props;
          const styles = {
            /** 容器样式 */
            container: {
              main: "flex items-center gap-4 w-full mx-2",
              error: "text-red-400",
              loading: "flex items-center"
            },
            /** 文件信息样式 */
            fileInfo: {
              container: "flex flex-col flex-1",
              file: "flex flex-wrap items-center gap-2",
              name: "font-bold text-base-content text-xl text-shadow-xs/60 line-clamp-2",
              size: "text-base-content/70 font-semibold text-shadow-xs/60 whitespace-nowrap flex-shrink-0",
              path: {
                container: ["breadcrumbs text-sm text-base-content/80"]
              }
            }
          };
          const path = computed(() => {
            var _a;
            if (!((_a = props.playlist.state) == null ? void 0 : _a.path)) {
              return [];
            }
            return props.playlist.state.path.filter(
              (item) => Number(item.cid) !== 0
            );
          });
          function handleOpenFolder(id) {
            window.open(`https://115.com/?cid=${id}&offset=0&mode=wangpan`, "_blank");
          }
          return (_ctx, _cache) => {
            var _a, _b, _c;
            return _ctx.fileInfo.error ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(styles.container.error)
            }, [
              _cache[0] || (_cache[0] = createElementVNode("div", null, "❌ 获取文件信息失败", -1)),
              createElementVNode("div", null, toDisplayString(_ctx.fileInfo.error), 1)
            ], 2)) : _ctx.fileInfo.isLoading || !_ctx.fileInfo.isLoading && !_ctx.fileInfo.isReady ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(styles.container.loading)
            }, [..._cache[1] || (_cache[1] = [
              createElementVNode("div", { class: "skeleton w-80 h-7 rounded-lg" }, null, -1)
            ])], 2)) : (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(styles.container.main)
            }, [
              createElementVNode("div", {
                class: normalizeClass(styles.fileInfo.container)
              }, [
                createElementVNode("div", {
                  class: normalizeClass(styles.fileInfo.file)
                }, [
                  createElementVNode("span", {
                    class: normalizeClass(styles.fileInfo.name)
                  }, toDisplayString((_b = (_a = _ctx.fileInfo.state) == null ? void 0 : _a.file_name) == null ? void 0 : _b.toUpperCase()), 3),
                  createElementVNode("span", {
                    class: normalizeClass(styles.fileInfo.size)
                  }, toDisplayString(unref(formatFileSize)(Number((_c = _ctx.fileInfo.state) == null ? void 0 : _c.file_size))), 3)
                ], 2),
                createElementVNode("div", {
                  class: normalizeClass(styles.fileInfo.path.container)
                }, [
                  createElementVNode("ul", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(path.value, (item) => {
                      return openBlock(), createElementBlock("li", {
                        key: item.cid,
                        onClick: ($event) => handleOpenFolder(item.cid)
                      }, [
                        createElementVNode("a", null, toDisplayString(item.name), 1)
                      ], 8, _hoisted_1$1);
                    }), 128))
                  ])
                ], 2)
              ], 2)
            ], 2));
          };
        }
      });
      const _hoisted_1 = ["src"];
      const _hoisted_2 = ["title"];
      const PLAYLIST_VIDEO_COVER_NUM = 1;
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        __name: "item",
        props: {
          item: {},
          active: { type: Boolean }
        },
        emits: ["play"],
        setup(__props, { emit: __emit }) {
          const props = __props;
          const emit = __emit;
          const styles = {
            item: {
              base: [
                "flex cursor-pointer break-words hover:bg-base-content/5",
                "rounded-lg",
                "transition-colors duration-200"
              ],
              active: "bg-primary/10 hover:bg-primary/15"
            },
            cover: {
              container: [
                "relative flex items-center justify-center flex-shrink-0",
                "overflow-hidden rounded-lg",
                "w-50 h-28 aspect-video",
                "before:content-[''] before:absolute before:inset-0 before:bg-black before:rounded-lg"
              ],
              skeleton: "relative skeleton w-full h-full rounded-lg",
              imageError: "relative!",
              image: "relative block w-full h-full object-contain"
            },
            duration: {
              container: [
                "absolute bottom-1.5 right-1.5 rounded-lg",
                "px-1.5 py-1",
                "backdrop-blur-xs",
                "text-xs bg-base-100/60 text-base-content/80"
              ]
            },
            progress: {
              container: "absolute bottom-0 right-0 w-full h-1",
              bar: "absolute top-0 left-0 w-0 h-full bg-primary opacity-80"
            },
            info: {
              container: "flex flex-col justify-between gap-1 p-2.5 px-4",
              title: "text-sm font-medium break-all leading-6 text-base-content line-clamp-3",
              titleActive: "text-primary",
              size: "text-xs text-base-content/60"
            }
          };
          const rootRef = shallowRef();
          const options = computed(() => ({
            pickCode: props.item.pc,
            sha1: props.item.sha,
            coverNum: PLAYLIST_VIDEO_COVER_NUM,
            duration: props.item.play_long
          }));
          const config = {
            elementRef: rootRef
          };
          const { videoCover } = useSmartVideoCover(options, config);
          const progressPercent = computed(() => {
            return props.item.current_time / props.item.play_long;
          });
          function handlePlay(item) {
            emit("play", item);
          }
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock("div", {
              ref_key: "rootRef",
              ref: rootRef,
              class: normalizeClass([styles.item.base, { [styles.item.active]: props.active }]),
              onClick: _cache[0] || (_cache[0] = ($event) => handlePlay(_ctx.item))
            }, [
              createElementVNode("div", {
                class: normalizeClass(styles.cover.container)
              }, [
                unref(videoCover).error ? (openBlock(), createBlock(_sfc_main$1$1, {
                  key: 0,
                  class: normalizeClass(styles.cover.imageError),
                  message: unref(videoCover).error,
                  size: "mini"
                }, null, 8, ["class", "message"])) : unref(videoCover).isLoading ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(styles.cover.skeleton)
                }, null, 2)) : unref(videoCover).isReady ? (openBlock(), createElementBlock("img", {
                  key: 2,
                  src: (_a = unref(videoCover).state[0]) == null ? void 0 : _a.img,
                  class: normalizeClass(styles.cover.image)
                }, null, 10, _hoisted_1)) : (openBlock(), createElementBlock("div", {
                  key: 3,
                  class: normalizeClass(styles.cover.skeleton)
                }, null, 2)),
                createElementVNode("div", {
                  class: normalizeClass(styles.duration.container)
                }, toDisplayString(unref(formatTime)(_ctx.item.play_long)), 3),
                _ctx.item.current_time > 0 ? (openBlock(), createElementBlock("div", {
                  key: 4,
                  class: normalizeClass(styles.progress.container)
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(styles.progress.bar),
                    style: normalizeStyle({ width: `${progressPercent.value * 100}%` })
                  }, null, 6)
                ], 2)) : createCommentVNode("", true)
              ], 2),
              createElementVNode("div", {
                class: normalizeClass(styles.info.container)
              }, [
                createElementVNode("div", {
                  class: normalizeClass([styles.info.title, { [styles.info.titleActive]: props.active }]),
                  title: _ctx.item.n
                }, toDisplayString(_ctx.item.n), 11, _hoisted_2),
                createElementVNode("div", {
                  class: normalizeClass(styles.info.size)
                }, toDisplayString(unref(formatFileSize)(_ctx.item.s)), 3)
              ], 2)
            ], 2);
          };
        }
      });
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        __name: "index",
        props: {
          playlist: {},
          pickCode: {}
        },
        emits: ["play", "close"],
        setup(__props, { emit: __emit }) {
          const props = __props;
          const emit = __emit;
          const styles = {
            playlist: {
              container: [
                "relative flex flex-col text-white box-border h-full",
                "bg-base-100",
                "border-l border-base-300/15",
                "[--app-playlist-space:calc(var(--spacing)*4)]",
                "[--app-playlist-header-height:calc(var(--spacing)*16)]"
              ],
              header: {
                root: [
                  "absolute inset-x-0 top-0 z-1",
                  "flex items-center justify-between flex-shrink-0",
                  "h-(--app-playlist-header-height)",
                  "px-(--app-playlist-space) py-4",
                  "text-base-content",
                  "bg-base-100/60",
                  "backdrop-blur-2xl backdrop-saturate-200 backdrop-brightness-50"
                ],
                title: "flex items-center text-xl gap-2.5",
                count: "text-xs text-base-content/50",
                close: "btn btn-ghost btn-circle",
                closeIcon: "size-8"
              },
              content: [
                "flex flex-col gap-5 flex-1",
                "overflow-y-auto",
                "px-(--app-playlist-space) pb-5 pt-[calc(var(--app-playlist-header-height)+var(--spacing)*5)]",
                "[&::-webkit-scrollbar-track]:mt-(--app-playlist-header-height)"
              ],
              divider: "divider w-1/3 mx-auto text-base-content/30"
            }
          };
          const playlistRef = ref(null);
          const playlistItemRefs = useTemplateRef("playlistItemRefs");
          const initedScroll = shallowRef(false);
          function handlePlay(item) {
            if (item.pc === props.pickCode) {
              return;
            }
            emit("play", item);
          }
          async function scrollToActiveItem(withAnimation = true) {
            if (initedScroll.value)
              return;
            await nextTick();
            if (!playlistItemRefs.value)
              return;
            initedScroll.value = true;
            const activeItem = playlistItemRefs.value.find((ref2) => ref2.$props.active);
            if (!activeItem || !playlistRef.value)
              return;
            const activeElement = activeItem.$el;
            const container = playlistRef.value;
            const elementTop = activeElement.offsetTop;
            const elementHeight = activeElement.offsetHeight;
            const containerHeight = container.clientHeight;
            const containerScrollTop = container.scrollTop;
            const elementBottom = elementTop + elementHeight;
            const isFullyVisible = elementTop >= containerScrollTop && elementBottom <= containerScrollTop + containerHeight;
            if (isFullyVisible && !withAnimation) {
              return;
            }
            const scrollTop = elementTop - (containerHeight - elementHeight) / 2;
            container.scrollTo({
              top: Math.max(0, scrollTop),
              behavior: withAnimation ? "smooth" : "instant"
            });
          }
          watch(
            [() => props.playlist.state, () => props.pickCode],
            () => scrollToActiveItem(false),
            {
              immediate: true
            }
          );
          return (_ctx, _cache) => {
            var _a, _b, _c;
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(styles.playlist.container)
            }, [
              createElementVNode("div", {
                class: normalizeClass(styles.playlist.header.root)
              }, [
                createElementVNode("div", {
                  class: normalizeClass(styles.playlist.header.title)
                }, [
                  createVNode(unref(Icon), {
                    icon: unref(ICON_PLAYLIST),
                    class: "size-8"
                  }, null, 8, ["icon"]),
                  _cache[1] || (_cache[1] = createTextVNode(" 播放列表 ", -1)),
                  ((_b = (_a = _ctx.playlist.state) == null ? void 0 : _a.data) == null ? void 0 : _b.length) && _ctx.playlist.state.data.length > 0 ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(styles.playlist.header.count)
                  }, "(" + toDisplayString(_ctx.playlist.state.data.length) + ")", 3)) : createCommentVNode("", true)
                ], 2),
                createElementVNode("button", {
                  class: normalizeClass(styles.playlist.header.close)
                }, [
                  createVNode(unref(Icon), {
                    icon: unref(ICON_CLOSE),
                    class: normalizeClass(styles.playlist.header.closeIcon),
                    onClick: _cache[0] || (_cache[0] = ($event) => emit("close"))
                  }, null, 8, ["icon", "class"])
                ], 2)
              ], 2),
              _ctx.playlist.error ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(styles.playlist.content)
              }, [
                createVNode(_sfc_main$1$1, {
                  message: _ctx.playlist.error
                }, null, 8, ["message"])
              ], 2)) : _ctx.playlist.isLoading || !_ctx.playlist.isLoading && !_ctx.playlist.isReady ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(styles.playlist.content)
              }, [..._cache[2] || (_cache[2] = [
                createElementVNode("div", { class: "skeleton h-24 w-full rounded-lg" }, null, -1)
              ])], 2)) : (openBlock(), createElementBlock("div", {
                key: 2,
                ref_key: "playlistRef",
                ref: playlistRef,
                class: normalizeClass(["custom-scrollbar", [styles.playlist.content]])
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(((_c = _ctx.playlist.state) == null ? void 0 : _c.data) || [], (item) => {
                  return openBlock(), createBlock(_sfc_main$2, {
                    ref_for: true,
                    ref_key: "playlistItemRefs",
                    ref: playlistItemRefs,
                    key: item.pc,
                    item,
                    active: item.pc === _ctx.pickCode,
                    onPlay: handlePlay
                  }, null, 8, ["item", "active"]);
                }), 128)),
                createElementVNode("div", {
                  class: normalizeClass(styles.playlist.divider)
                }, " 没有更多了 ", 2)
              ], 2))
            ], 2);
          };
        }
      });
      function useFileInfo() {
        const fileInfo = useAsyncState(async (pickCode) => {
          const response = await drive115.webApiGetFilesVideo({
            pickcode: pickCode,
            share_id: "0",
            local: "1"
          });
          return response;
        }, {}, {
          immediate: false
        });
        return reactive(fileInfo);
      }
      function useHistory() {
        const isinit = shallowRef(false);
        const pickcode = shallowRef("");
        const lastTime = shallowRef(0);
        const postHistory = async (time) => {
          if (!isinit.value || !pickcode.value) {
            return;
          }
          drive115.webApiPostWebApiFilesHistory({
            op: "update",
            pick_code: pickcode.value,
            share_id: "0",
            category: "1",
            definition: "0",
            time
          });
        };
        const handleTimeupdate = useThrottleFn(async (time) => {
          await postHistory(time);
        }, 5e3);
        const handleSeek = useDebounceFn(async (time) => {
          await postHistory(time);
        }, 2e3);
        const fetch = async (_pickcode) => {
          pickcode.value = _pickcode;
          try {
            const res = await drive115.webApiGetWebApiFilesHistory({
              fetch: "one",
              pick_code: pickcode.value,
              share_id: "0",
              category: "1"
            });
            if (!Number.isNaN(res.data.time)) {
              lastTime.value = Number(res.data.time ?? 0);
            }
          } finally {
            isinit.value = true;
          }
        };
        const clear = () => {
          isinit.value = false;
          pickcode.value = "";
          lastTime.value = 0;
        };
        onUnmounted(() => {
          isinit.value = false;
        });
        return {
          isinit,
          lastTime,
          handleTimeupdate,
          handleSeek,
          fetch,
          clear
        };
      }
      var MarkStatus;
      (function(MarkStatus2) {
        MarkStatus2["Mark"] = "1";
        MarkStatus2["Unmark"] = "0";
      })(MarkStatus || (MarkStatus = {}));
      function useMark(DataFileInfo) {
        const isMark = shallowRef(null);
        const toggleMark = async () => {
          const res = await drive115.webApiPostFilesStar({
            file_id: DataFileInfo.state.file_id,
            star: isMark.value ? MarkStatus.Unmark : MarkStatus.Mark
          });
          if (res.state) {
            isMark.value = !isMark.value;
          }
        };
        watch(() => DataFileInfo.state.is_mark, (newVal) => {
          isMark.value = newVal !== void 0 ? newVal === MarkStatus.Mark : null;
        });
        return {
          toggleMark,
          isMark
        };
      }
      function usePlaylist() {
        const playlist = useAsyncState(async (cid) => {
          const res = await drive115.getPlaylist(cid);
          return res;
        }, null, {
          immediate: false
        });
        const updateItem = (pickCode, data) => {
          if (!playlist.state.value || !playlist.state.value.data)
            return;
          const index = playlist.state.value.data.findIndex((i) => i.pc === pickCode);
          if (index !== -1) {
            playlist.state.value.data[index] = {
              ...playlist.state.value.data[index],
              ...data
            };
          }
        };
        const updateItemTime = (pickCode, time) => {
          updateItem(pickCode, { current_time: time });
        };
        const updateItemMark = (pickCode, mark) => {
          updateItem(pickCode, { m: mark ? 1 : 0 });
        };
        return reactive({
          ...playlist,
          updateItemTime,
          updateItemMark
        });
      }
      function usePreferences() {
        const preferences = useStorage("x-player-preferences", {
          // 音量
          volume: 100,
          // 静音
          muted: true,
          // 播放速率
          playbackRate: 1,
          // 显示播放列表
          showPlaylist: false,
          // 自动加载缩略图
          autoLoadThumbnails: true,
          // 禁用HDR
          disabledHDR: false,
          // 缩略图采样间隔
          thumbnailsSamplingInterval: 60,
          // 自动播放（固定开启，无用户设置选项）
          autoPlay: true,
          // 播放模式
          playMode: PlayMode.STOP
        }, void 0, {
          listenToStorageChanges: false
        });
        return preferences;
      }
      function intervalArray(start, end, interval) {
        const diff = end - start;
        const array = [];
        for (let i = 0; i < diff; i += interval) {
          array.push(i);
        }
        return array;
      }
      const CLIPPER_OPTIONS = {
        maxWidth: 320,
        maxHeight: 320
      };
      const LANE_CONFIG = {
        // 缓冲车道
        buffer: {
          name: "buffer",
          priority: 2,
          maxConcurrent: 4
        }
      };
      const SCHEDULER_OPTIONS = {
        // 最大并发数
        maxConcurrent: 4,
        // 最大队列长度
        maxQueueLength: 1e3,
        // 车道配置
        laneConfig: LANE_CONFIG
      };
      const DEFAULT_SAMPLING_INTERVAL = 30;
      function useThumbnails(preferences) {
        let clipper;
        const scheduler = new Scheduler(SCHEDULER_OPTIONS);
        const isInited = shallowRef(false);
        const isAutoBufferExecuted = shallowRef(false);
        const samplingInterval = shallowRef(DEFAULT_SAMPLING_INTERVAL);
        const cahceThumbnails = /* @__PURE__ */ new Map();
        const state = shallowRef({
          error: void 0
        });
        const findLowestQualityHLS = (sources) => {
          let lowestQuality = null;
          sources.forEach((source) => {
            if (source.type === "hls") {
              if (!lowestQuality || source.quality < lowestQuality.quality) {
                lowestQuality = source;
              }
            }
          });
          return lowestQuality;
        };
        const initialize = async (sources, interval) => {
          try {
            isInited.value = false;
            const source = findLowestQualityHLS(sources);
            if (!source) {
              throw FRIENDLY_ERROR_MESSAGE.CANNOT_VIDEO_COVER_WITHOUT_TRANSCODING;
            }
            clipper = new M3U8ClipperNew({
              url: source.url
            });
            await clipper.open();
            samplingInterval.value = interval ?? DEFAULT_SAMPLING_INTERVAL;
            isInited.value = true;
          } catch (error) {
            state.value.error = error;
          }
        };
        const seekThumbnail = async (seekTime, seekBlurTime) => {
          const result = await clipper.seek(seekBlurTime, true);
          if (!result) {
            return void 0;
          }
          try {
            const resize = getImageResize(result.videoFrame.displayWidth, result.videoFrame.displayHeight, CLIPPER_OPTIONS.maxWidth, CLIPPER_OPTIONS.maxHeight);
            const imageBitmap = await createImageBitmap(result.videoFrame, {
              resizeQuality: "pixelated",
              resizeWidth: resize.width,
              resizeHeight: resize.height
            });
            const thumbnail = {
              img: imageBitmap,
              seekTime,
              seekBlurTime,
              frameTime: result.frameTime,
              consumedTime: result.consumedTime
            };
            cahceThumbnails.set(seekBlurTime, thumbnail);
            return thumbnail;
          } finally {
            result.videoFrame.close();
          }
        };
        const onThumbnailRequest = async ({ time, isLast }) => {
          if (state.value.error) {
            throw state.value.error;
          }
          if (!isInited || Number.isNaN(time)) {
            return;
          }
          const seekBlurTime = blurTime(time, samplingInterval.value, clipper.hlsIo.duration);
          const cache = cahceThumbnails.get(seekBlurTime);
          if (cache) {
            return cache;
          }
          if (!isLast) {
            return;
          }
          return await seekThumbnail(time, seekBlurTime);
        };
        const autoBuffer = async () => {
          if (state.value.error) {
            throw state.value.error;
          }
          if (preferences.value.autoLoadThumbnails === false) {
            return;
          }
          if (isAutoBufferExecuted.value) {
            return;
          }
          isAutoBufferExecuted.value = true;
          const times = shuffle(
            // 生成缩略图时间点
            intervalArray(0, clipper.hlsIo.duration, samplingInterval.value).filter((time) => !cahceThumbnails.has(time))
          );
          for (const time of times) {
            scheduler.add(async () => {
              const seekTime = blurTime(time, samplingInterval.value, clipper.hlsIo.duration);
              if (cahceThumbnails.has(seekTime)) {
                return null;
              }
              return await seekThumbnail(time, seekTime);
            }, {
              id: time.toString(),
              lane: LANE_CONFIG.buffer.name,
              priority: 1,
              immediate: true,
              action: "unshift"
            }).catch((error) => {
              if (error instanceof SchedulerError.QueueCleared) {
                throw error;
              }
            });
          }
        };
        const releaseCache = () => {
          cahceThumbnails.forEach((thumbnail) => {
            var _a;
            (_a = thumbnail == null ? void 0 : thumbnail.img) == null ? void 0 : _a.close();
          });
          cahceThumbnails.clear();
        };
        const clear = () => {
          clipper.destroy();
          scheduler.clear();
          releaseCache();
          isInited.value = false;
          isAutoBufferExecuted.value = false;
        };
        tryOnUnmounted(() => {
          clear();
        });
        return {
          isInited,
          isAutoBufferExecuted,
          initialize,
          autoBuffer,
          onThumbnailRequest,
          clear
        };
      }
      function getFileExtensionByUrl(url) {
        const newUrl = new URL(url);
        const result = newUrl.pathname.split(".").pop();
        return result;
      }
      function useVideoSource() {
        const list = ref([]);
        const fetch = async (pickCode) => {
          const [download, m3u8List] = await Promise.allSettled([
            drive115.getFileDownloadUrl(pickCode),
            drive115.getM3u8(pickCode)
          ]);
          if (download.status === "fulfilled") {
            if (download.value.url.auth_cookie) {
              console.warn("设置cookie", download.value.url.auth_cookie);
              try {
                await setVideoCookie({
                  name: download.value.url.auth_cookie.name,
                  value: download.value.url.auth_cookie.value,
                  path: "/",
                  domain: ".115cdn.net",
                  secure: true,
                  expirationDate: Number(download.value.url.auth_cookie.expire),
                  sameSite: "no_restriction"
                });
              } catch (error) {
                alert("设置cookie失败，请升级浏览器和油猴版本");
                throw error;
              }
            }
            const extension = getFileExtensionByUrl(download.value.url.url) ?? VideoSourceExtension.unknown;
            list.value.unshift({
              name: "Ultra",
              url: download.value.url.url,
              type: "auto",
              extension,
              quality: 99999,
              displayQuality: "Ultra"
            });
          }
          if (m3u8List.status === "fulfilled") {
            list.value.push(...m3u8List.value.map((item) => ({
              name: `${item.quality}P`,
              url: item.url,
              type: "hls",
              extension: VideoSourceExtension.m3u8,
              quality: item.quality,
              displayQuality: qualityNumMap[item.quality]
            })));
          } else {
            console.error("m3u8", m3u8List.reason);
          }
        };
        const clear = () => {
          list.value = [];
        };
        return {
          list,
          fetch,
          clear
        };
      }
      const _sfc_main = exports("default", /* @__PURE__ */ defineComponent({
        __name: "index",
        setup(__props) {
          const styles = {
            // 容器样式
            container: {
              main: [
                "flex flex-col items-center",
                "min-h-screen gap-5",
                "bg-base-100 text-gray-100",
                "[--app-playlist-width:min(400px,30vw)]"
              ],
              pageMain: ["relative w-full h-screen overflow-hidden"],
              pageFlow: "flex flex-col gap-8 px-6 xl:px-36 py-8 w-full"
            },
            // 播放器样式
            player: {
              container: "relative w-full h-screen flex items-center justify-center transition-all duration-200 ease-in-out transform-gpu",
              containerFold: "w-[calc(100%-var(--app-playlist-width))]!",
              video: "absolute m-auto w-full h-full overflow-hidden"
            },
            // 播放列表样式
            playlist: {
              container: "fixed top-0 right-0 h-screen z-50 w-(--app-playlist-width)! bg-base-200",
              content: "h-full"
            },
            // 控制样式
            controls: {
              btn: controlRightStyles.btn
            }
          };
          const xplayerRef = ref();
          const preferences = usePreferences();
          const params = useParamsVideoPage();
          const DataVideoSources = useVideoSource();
          const DataThumbnails = useThumbnails(preferences);
          const DataFileInfo = useFileInfo();
          const DataPlaylist = usePlaylist();
          const DataHistory = useHistory();
          const DataMark = useMark(DataFileInfo);
          const changeing = shallowRef(false);
          const videoSize = computed(() => {
            var _a, _b;
            return {
              width: Number((_a = DataFileInfo.state) == null ? void 0 : _a.width) ?? 1920,
              height: Number((_b = DataFileInfo.state) == null ? void 0 : _b.height) ?? 1080
            };
          });
          const videoRatio = computed(() => {
            return videoSize.value.width / videoSize.value.height;
          });
          const aspectRatio = computed(() => {
            if (videoRatio.value < 1) {
              return "1/1";
            }
            if (videoRatio.value > 1.78) {
              return "16/10";
            }
            return `${videoSize.value.width} / ${videoSize.value.height}`;
          });
          async function handleChangeVideo(item) {
            try {
              changeing.value = true;
              if (!params.cid.value) {
                throw new Error("cid is required");
              }
              goToPlayer({
                cid: params.cid.value,
                pickCode: item.pc
              });
              params.getParams();
              DataVideoSources.clear();
              DataThumbnails.clear();
              DataHistory.clear();
              await nextTick();
              await loadData(false);
            } finally {
              changeing.value = false;
            }
          }
          function handleStartAutoBuffer() {
            DataThumbnails.autoBuffer();
          }
          function handleTimeupdate(time) {
            if (changeing.value) {
              return;
            }
            if (!DataHistory.isinit.value) {
              return;
            }
            if (time <= 0) {
              return;
            }
            DataHistory.handleTimeupdate(time);
            if (!params.pickCode.value) {
              throw new Error("pickCode is required");
            }
            DataPlaylist.updateItemTime(params.pickCode.value, time);
          }
          function handleClosePlaylist() {
            preferences.value.showPlaylist = false;
          }
          function togglePlaylist() {
            preferences.value.showPlaylist = !preferences.value.showPlaylist;
          }
          function getCurrentPlaylist() {
            return DataPlaylist.state;
          }
          function getCurrentPickCode() {
            return params.pickCode.value || null;
          }
          async function onChangeVideo(pickCode) {
            const playlist = DataPlaylist.state;
            if (!(playlist == null ? void 0 : playlist.data)) {
              console.error("播放列表不存在");
              return;
            }
            const item = playlist.data.find((item2) => item2.pc === pickCode);
            if (!item) {
              console.error(`找不到播放项: ${pickCode}`);
              return;
            }
            await handleChangeVideo(item);
          }
          function setPlayMode(mode) {
            preferences.value.playMode = mode;
            console.log(`🎮 播放模式已设置为: ${mode}`);
          }
          async function loadData(isFirst = true) {
            if (!params.pickCode.value) {
              throw new Error("pickCode is required");
            }
            if (!params.cid.value) {
              throw new Error("cid is required");
            }
            try {
              await DataHistory.fetch(params.pickCode.value);
            } catch (error) {
              console.error(error);
            }
            DataVideoSources.fetch(params.pickCode.value).then(() => {
              DataThumbnails.initialize(
                DataVideoSources.list.value,
                preferences.value.thumbnailsSamplingInterval
              );
            });
            DataFileInfo.execute(0, params.pickCode.value).then(() => {
              useTitle(DataFileInfo.state.file_name || "");
            });
            isFirst && DataPlaylist.execute(0, params.cid.value);
          }
          onMounted(async () => {
            await loadData();
          });
          const canGoPrevious = computed(() => {
            var _a;
            if (!((_a = DataPlaylist.state) == null ? void 0 : _a.data) || !DataFileInfo.state.pick_code) {
              return false;
            }
            const currentIndex = DataPlaylist.state.data.findIndex((item) => item.pc === DataFileInfo.state.pick_code);
            return currentIndex > 0;
          });
          const canGoNext = computed(() => {
            var _a;
            if (!((_a = DataPlaylist.state) == null ? void 0 : _a.data) || !DataFileInfo.state.pick_code) {
              return false;
            }
            const currentIndex = DataPlaylist.state.data.findIndex((item) => item.pc === DataFileInfo.state.pick_code);
            return currentIndex >= 0 && currentIndex < DataPlaylist.state.data.length - 1;
          });
          async function goToPreviousVideo() {
            var _a;
            try {
              if (!((_a = DataPlaylist.state) == null ? void 0 : _a.data) || !DataFileInfo.state.pick_code) {
                console.warn("播放列表或当前视频信息不存在");
                return;
              }
              const currentIndex = DataPlaylist.state.data.findIndex((item) => item.pc === DataFileInfo.state.pick_code);
              if (currentIndex > 0) {
                const previousItem = DataPlaylist.state.data[currentIndex - 1];
                console.log("📺 跳转上一集:", previousItem.n);
                await onChangeVideo(previousItem.pc);
              } else {
                console.log("🙅 已经是第一集了");
              }
            } catch (error) {
              console.error("跳转上一集失败:", error);
            }
          }
          async function goToNextVideo() {
            var _a;
            try {
              if (!((_a = DataPlaylist.state) == null ? void 0 : _a.data) || !DataFileInfo.state.pick_code) {
                console.warn("播放列表或当前视频信息不存在");
                return;
              }
              const currentIndex = DataPlaylist.state.data.findIndex((item) => item.pc === DataFileInfo.state.pick_code);
              if (currentIndex >= 0 && currentIndex < DataPlaylist.state.data.length - 1) {
                const nextItem = DataPlaylist.state.data[currentIndex + 1];
                console.log("📺 跳转下一集:", nextItem.n);
                await onChangeVideo(nextItem.pc);
              } else {
                console.log("🙅 已经是最后一集了");
              }
            } catch (error) {
              console.error("跳转下一集失败:", error);
            }
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(styles.container.main)
            }, [
              createElementVNode("div", {
                class: normalizeClass(styles.container.pageMain)
              }, [
                createElementVNode("div", {
                  class: normalizeClass([
                    styles.player.container,
                    unref(preferences).showPlaylist && styles.player.containerFold
                  ])
                }, [
                  createVNode(_sfc_main$4, {
                    ref_key: "xplayerRef",
                    ref: xplayerRef,
                    "show-playlist": unref(preferences).showPlaylist,
                    "onUpdate:showPlaylist": _cache[0] || (_cache[0] = ($event) => unref(preferences).showPlaylist = $event),
                    volume: unref(preferences).volume,
                    "onUpdate:volume": _cache[1] || (_cache[1] = ($event) => unref(preferences).volume = $event),
                    muted: unref(preferences).muted,
                    "onUpdate:muted": _cache[2] || (_cache[2] = ($event) => unref(preferences).muted = $event),
                    "playback-rate": unref(preferences).playbackRate,
                    "onUpdate:playbackRate": _cache[3] || (_cache[3] = ($event) => unref(preferences).playbackRate = $event),
                    "auto-load-thumbnails": unref(preferences).autoLoadThumbnails,
                    "onUpdate:autoLoadThumbnails": _cache[4] || (_cache[4] = ($event) => unref(preferences).autoLoadThumbnails = $event),
                    "disabled-h-d-r": unref(preferences).disabledHDR,
                    "onUpdate:disabledHDR": _cache[5] || (_cache[5] = ($event) => unref(preferences).disabledHDR = $event),
                    "thumbnails-sampling-interval": unref(preferences).thumbnailsSamplingInterval,
                    "onUpdate:thumbnailsSamplingInterval": _cache[6] || (_cache[6] = ($event) => unref(preferences).thumbnailsSamplingInterval = $event),
                    "auto-play": unref(preferences).autoPlay,
                    "onUpdate:autoPlay": _cache[7] || (_cache[7] = ($event) => unref(preferences).autoPlay = $event),
                    class: normalizeClass([styles.player.video]),
                    style: normalizeStyle({
                      aspectRatio: aspectRatio.value
                    }),
                    "video-id": unref(params).pickCode.value,
                    sources: unref(DataVideoSources).list,
                    "last-time": unref(DataHistory).lastTime.value,
                    "on-thumbnail-request": unref(DataThumbnails).onThumbnailRequest,
                    "on-timeupdate": handleTimeupdate,
                    "on-seeking": unref(DataHistory).handleSeek,
                    "on-seeked": unref(DataHistory).handleSeek,
                    "on-canplay": handleStartAutoBuffer,
                    "get-current-playlist": getCurrentPlaylist,
                    "get-current-pick-code": getCurrentPickCode,
                    "on-change-video": onChangeVideo,
                    "current-play-mode": unref(preferences).playMode,
                    "set-play-mode": setPlayMode,
                    "on-previous-video": goToPreviousVideo,
                    "on-next-video": goToNextVideo
                  }, {
                    headerLeft: withCtx(() => [
                      createVNode(_sfc_main$3, {
                        "file-info": unref(DataFileInfo),
                        playlist: unref(DataPlaylist)
                      }, null, 8, ["file-info", "playlist"])
                    ]),
                    controlsRight: withCtx(() => {
                      var _a, _b;
                      return [
                        createVNode(_sfc_main$s, {
                          "is-mark": unref(DataMark).isMark.value,
                          "on-toggle-mark": unref(DataMark).toggleMark
                        }, null, 8, ["is-mark", "on-toggle-mark"]),
                        createElementVNode("button", {
                          class: normalizeClass([
                            styles.controls.btn.root,
                            unref(preferences).showPlaylist && "btn-active btn-primary"
                          ]),
                          "data-tip": "播放列表(B)",
                          onClick: togglePlaylist
                        }, [
                          createVNode(unref(Icon), {
                            icon: unref(ICON_PLAYLIST),
                            class: normalizeClass([styles.controls.btn.icon])
                          }, null, 8, ["icon", "class"])
                        ], 2),
                        ((_a = unref(DataPlaylist).state) == null ? void 0 : _a.data) && canGoPrevious.value ? (openBlock(), createElementBlock("button", {
                          key: 0,
                          class: normalizeClass([styles.controls.btn.root]),
                          "data-tip": "上一集 (←)",
                          onClick: goToPreviousVideo
                        }, [
                          createVNode(unref(Icon), {
                            icon: unref(ICON_SKIP_PREVIOUS),
                            class: normalizeClass([styles.controls.btn.icon])
                          }, null, 8, ["icon", "class"])
                        ], 2)) : createCommentVNode("", true),
                        ((_b = unref(DataPlaylist).state) == null ? void 0 : _b.data) && canGoNext.value ? (openBlock(), createElementBlock("button", {
                          key: 1,
                          class: normalizeClass([styles.controls.btn.root]),
                          "data-tip": "下一集 (→)",
                          onClick: goToNextVideo
                        }, [
                          createVNode(unref(Icon), {
                            icon: unref(ICON_SKIP_NEXT),
                            class: normalizeClass([styles.controls.btn.icon])
                          }, null, 8, ["icon", "class"])
                        ], 2)) : createCommentVNode("", true)
                      ];
                    }),
                    _: 1
                  }, 8, ["show-playlist", "volume", "muted", "playback-rate", "auto-load-thumbnails", "disabled-h-d-r", "thumbnails-sampling-interval", "auto-play", "class", "style", "video-id", "sources", "last-time", "on-thumbnail-request", "on-seeking", "on-seeked", "current-play-mode"])
                ], 2)
              ], 2),
              unref(PLUS_VERSION) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(styles.container.pageFlow)
              }, null, 2)) : createCommentVNode("", true),
              unref(preferences).showPlaylist ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(styles.playlist.container)
              }, [
                createVNode(_sfc_main$1, {
                  class: normalizeClass(styles.playlist.content),
                  "pick-code": unref(params).pickCode.value,
                  playlist: unref(DataPlaylist),
                  visible: unref(preferences).showPlaylist,
                  onPlay: handleChangeVideo,
                  onClose: handleClosePlaylist
                }, null, 8, ["class", "pick-code", "playlist", "visible"])
              ], 2)) : createCommentVNode("", true)
            ], 2);
          };
        }
      }));

    })
  };
}));

System.import("./__entry.js", "./");